import{g as A2,c as Co}from"./commonjsHelpers.Cpj98o6Y.js";function P2(Eo,Ao){for(var _a=0;_a<Ao.length;_a++){const vs=Ao[_a];if(typeof vs!="string"&&!Array.isArray(vs)){for(const d in vs)if(d!=="default"&&!(d in Eo)){const st=Object.getOwnPropertyDescriptor(vs,d);st&&Object.defineProperty(Eo,d,st.get?st:{enumerable:!0,get:()=>vs[d]})}}}return Object.freeze(Object.defineProperty(Eo,Symbol.toStringTag,{value:"Module"}))}var ld={exports:{}};(function(Eo,Ao){var _a=Object.defineProperty,vs=(st,te,xt)=>te in st?_a(st,te,{enumerable:!0,configurable:!0,writable:!0,value:xt}):st[te]=xt,d=(st,te,xt)=>(vs(st,typeof te!="symbol"?te+"":te,xt),xt);(function(st,te){te(Ao)})(Co,function(st){const te="mapv";function xt(s,t){if(s.className===void 0)s.className=t;else if(s.className!==t){const e=s.className.split(/ +/);e.indexOf(t)===-1&&(e.push(t),s.className=e.join(" ").replace(/^\s+/,"").replace(/\s+$/,""))}return s}const hd={},yh="141dev",l0=0,cd=1,h0=2,ud=1,c0=2,va=3,Fn=0,pi=1,ce=2,Bn=0,ar=1,xa=2,dd=3,pd=4,md=5,or=100,u0=101,d0=102,fd=103,gd=104,_d=200,Po=201,p0=202,m0=203,vd=204,xd=205,f0=206,g0=207,_0=208,v0=209,x0=210,y0=0,b0=1,M0=2,bh=3,w0=4,S0=5,T0=6,C0=7,Ro=0,E0=1,A0=2,cn=0,P0=1,yd=2,R0=3,D0=4,L0=5,lr=301,hr=302,Do=303,Mh=304,xs=306,ze=1e3,ue=1001,Lo=1002,Ft=1003,wh=1004,Sh=1005,Wt=1006,bd=1007,ys=1008,Vn=1009,I0=1010,O0=1011,Md=1012,z0=1013,bs=1014,Ve=1015,be=1016,k0=1017,N0=1018,Ms=1020,U0=1021,F0=1022,$t=1023,B0=1024,V0=1025,ws=1026,Ss=1027,H0=1028,j0=1029,G0=1030,W0=1031,X0=1033,Th=33776,Ch=33777,Eh=33778,Ah=33779,wd=35840,Sd=35841,Td=35842,Cd=35843,q0=36196,Ed=37492,Ad=37496,Pd=37808,Rd=37809,Dd=37810,Ld=37811,Id=37812,Od=37813,zd=37814,kd=37815,Nd=37816,Ud=37817,Fd=37818,Bd=37819,Vd=37820,Hd=37821,jd=36492,ya=2300,cr=2301,Ph=2302,ur=2400,dr=2401,Io=2402,Y0=2500,Gd=2,un=3e3,Bt=3001,Z0=3201,Hn=0,J0=1,dn="srgb",Ts="srgb-linear",ba=7680,pr=35044,Rh="300 es",Dh=1035;/**
   * @license
   * Copyright 2010-2022 Three.js Authors
   * SPDX-License-Identifier: MIT
   */class pn{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const n=i.indexOf(e);n!==-1&&i.splice(n,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const e=this._listeners[t.type];if(e!==void 0){t.target=this;const i=e.slice(0);for(let n=0,r=i.length;n<r;n++)i[n].call(this,t);t.target=null}}}const Re=[];for(let s=0;s<256;s++)Re[s]=(s<16?"0":"")+s.toString(16);let Wd=1234567;const Ma=Math.PI/180,wa=180/Math.PI;function Ei(){const s=4294967295*Math.random()|0,t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(Re[255&s]+Re[s>>8&255]+Re[s>>16&255]+Re[s>>24&255]+"-"+Re[255&t]+Re[t>>8&255]+"-"+Re[t>>16&15|64]+Re[t>>24&255]+"-"+Re[63&e|128]+Re[e>>8&255]+"-"+Re[e>>16&255]+Re[e>>24&255]+Re[255&i]+Re[i>>8&255]+Re[i>>16&255]+Re[i>>24&255]).toLowerCase()}function ke(s,t,e){return Math.max(t,Math.min(e,s))}function Lh(s,t){return(s%t+t)%t}function Sa(s,t,e){return(1-e)*s+e*t}function Ih(s){return(s&s-1)==0&&s!==0}function Xd(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function Oo(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}var re=Object.freeze({__proto__:null,DEG2RAD:Ma,RAD2DEG:wa,generateUUID:Ei,clamp:ke,euclideanModulo:Lh,mapLinear:function(s,t,e,i,n){return i+(s-t)*(n-i)/(e-t)},inverseLerp:function(s,t,e){return s!==t?(e-s)/(t-s):0},lerp:Sa,damp:function(s,t,e,i){return Sa(s,t,1-Math.exp(-e*i))},pingpong:function(s,t=1){return t-Math.abs(Lh(s,2*t)-t)},smoothstep:function(s,t,e){return s<=t?0:s>=e?1:(s=(s-t)/(e-t))*s*(3-2*s)},smootherstep:function(s,t,e){return s<=t?0:s>=e?1:(s=(s-t)/(e-t))*s*s*(s*(6*s-15)+10)},randInt:function(s,t){return s+Math.floor(Math.random()*(t-s+1))},randFloat:function(s,t){return s+Math.random()*(t-s)},randFloatSpread:function(s){return s*(.5-Math.random())},seededRandom:function(s){s!==void 0&&(Wd=s);let t=Wd+=1831565813;return t=Math.imul(t^t>>>15,1|t),t^=t+Math.imul(t^t>>>7,61|t),((t^t>>>14)>>>0)/4294967296},degToRad:function(s){return s*Ma},radToDeg:function(s){return s*wa},isPowerOfTwo:Ih,ceilPowerOfTwo:Xd,floorPowerOfTwo:Oo,setQuaternionFromProperEuler:function(s,t,e,i,n){const r=Math.cos,a=Math.sin,o=r(e/2),l=a(e/2),h=r((t+i)/2),c=a((t+i)/2),u=r((t-i)/2),p=a((t-i)/2),m=r((i-t)/2),f=a((i-t)/2);switch(n){case"XYX":s.set(o*c,l*u,l*p,o*h);break;case"YZY":s.set(l*p,o*c,l*u,o*h);break;case"ZXZ":s.set(l*u,l*p,o*c,o*h);break;case"XZX":s.set(o*c,l*f,l*m,o*h);break;case"YXY":s.set(l*m,o*c,l*f,o*h);break;case"ZYZ":s.set(l*f,l*m,o*c,o*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}},normalize:function(s,t){switch(t.constructor){case Float32Array:return s;case Uint16Array:return Math.round(65535*s);case Uint8Array:return Math.round(255*s);case Int16Array:return Math.round(32767*s);case Int8Array:return Math.round(127*s);default:throw new Error("Invalid component type.")}},denormalize:function(s,t){switch(t.constructor){case Float32Array:return s;case Uint16Array:return s/65535;case Uint8Array:return s/255;case Int16Array:return Math.max(s/32767,-1);case Int8Array:return Math.max(s/127,-1);default:throw new Error("Invalid component type.")}}});class j{constructor(t=0,e=0){this.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6],this.y=n[1]*e+n[4]*i+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),n=Math.sin(e),r=this.x-t.x,a=this.y-t.y;return this.x=r*i-a*n+t.x,this.y=r*n+a*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Ke{constructor(){this.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,n,r,a,o,l,h){const c=this.elements;return c[0]=t,c[1]=n,c[2]=o,c[3]=e,c[4]=r,c[5]=l,c[6]=i,c[7]=a,c[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,r=this.elements,a=i[0],o=i[3],l=i[6],h=i[1],c=i[4],u=i[7],p=i[2],m=i[5],f=i[8],g=n[0],_=n[3],v=n[6],x=n[1],y=n[4],b=n[7],S=n[2],w=n[5],C=n[8];return r[0]=a*g+o*x+l*S,r[3]=a*_+o*y+l*w,r[6]=a*v+o*b+l*C,r[1]=h*g+c*x+u*S,r[4]=h*_+c*y+u*w,r[7]=h*v+c*b+u*C,r[2]=p*g+m*x+f*S,r[5]=p*_+m*y+f*w,r[8]=p*v+m*b+f*C,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],n=t[2],r=t[3],a=t[4],o=t[5],l=t[6],h=t[7],c=t[8];return e*a*c-e*o*h-i*r*c+i*o*l+n*r*h-n*a*l}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],r=t[3],a=t[4],o=t[5],l=t[6],h=t[7],c=t[8],u=c*a-o*h,p=o*l-c*r,m=h*r-a*l,f=e*u+i*p+n*m;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/f;return t[0]=u*g,t[1]=(n*h-c*i)*g,t[2]=(o*i-n*a)*g,t[3]=p*g,t[4]=(c*e-n*l)*g,t[5]=(n*r-o*e)*g,t[6]=m*g,t[7]=(i*l-h*e)*g,t[8]=(a*e-i*r)*g,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,n,r,a,o){const l=Math.cos(r),h=Math.sin(r);return this.set(i*l,i*h,-i*(l*a+h*o)+a+t,-n*h,n*l,-n*(-h*a+l*o)+o+e,0,0,1),this}scale(t,e){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=e,i[4]*=e,i[7]*=e,this}rotate(t){const e=Math.cos(t),i=Math.sin(t),n=this.elements,r=n[0],a=n[3],o=n[6],l=n[1],h=n[4],c=n[7];return n[0]=e*r+i*l,n[3]=e*a+i*h,n[6]=e*o+i*c,n[1]=-i*r+e*l,n[4]=-i*a+e*h,n[7]=-i*o+e*c,this}translate(t,e){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=e*i[2],i[4]+=e*i[5],i[7]+=e*i[8],this}equals(t){const e=this.elements,i=t.elements;for(let n=0;n<9;n++)if(e[n]!==i[n])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}function qd(s){for(let t=s.length-1;t>=0;--t)if(s[t]>65535)return!0;return!1}function Ta(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}function Cs(s){return s<.04045?.0773993808*s:Math.pow(.9478672986*s+.0521327014,2.4)}function zo(s){return s<.0031308?12.92*s:1.055*Math.pow(s,.41666)-.055}const Oh={[dn]:{[Ts]:Cs},[Ts]:{[dn]:zo}},Ai={legacyMode:!0,get workingColorSpace(){return Ts},set workingColorSpace(s){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(s,t,e){if(this.legacyMode||t===e||!t||!e)return s;if(Oh[t]&&Oh[t][e]!==void 0){const i=Oh[t][e];return s.r=i(s.r),s.g=i(s.g),s.b=i(s.b),s}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(s,t){return this.convert(s,this.workingColorSpace,t)},toWorkingColorSpace:function(s,t){return this.convert(s,t,this.workingColorSpace)}},Yd={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Me={r:0,g:0,b:0},Pi={h:0,s:0,l:0},ko={h:0,s:0,l:0};function zh(s,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?s+6*(t-s)*e:e<.5?t:e<2/3?s+6*(t-s)*(2/3-e):s}function No(s,t){return t.r=s.r,t.g=s.g,t.b=s.b,t}class tt{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,e===void 0&&i===void 0?this.set(t):this.setRGB(t,e,i)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=dn){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,Ai.toWorkingColorSpace(this,e),this}setRGB(t,e,i,n=Ts){return this.r=t,this.g=e,this.b=i,Ai.toWorkingColorSpace(this,n),this}setHSL(t,e,i,n=Ts){if(t=Lh(t,1),e=ke(e,0,1),i=ke(i,0,1),e===0)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+e):i+e-i*e,a=2*i-r;this.r=zh(a,r,t+1/3),this.g=zh(a,r,t),this.b=zh(a,r,t-1/3)}return Ai.toWorkingColorSpace(this,n),this}setStyle(t,e=dn){function i(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let r;const a=n[1],o=n[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,Ai.toWorkingColorSpace(this,e),i(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,Ai.toWorkingColorSpace(this,e),i(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const l=parseFloat(r[1])/360,h=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return i(r[4]),this.setHSL(l,h,c,e)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=n[1],a=r.length;if(a===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,Ai.toWorkingColorSpace(this,e),this;if(a===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,Ai.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=dn){const i=Yd[t.toLowerCase()];return i!==void 0?this.setHex(i,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Cs(t.r),this.g=Cs(t.g),this.b=Cs(t.b),this}copyLinearToSRGB(t){return this.r=zo(t.r),this.g=zo(t.g),this.b=zo(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=dn){return Ai.fromWorkingColorSpace(No(this,Me),t),ke(255*Me.r,0,255)<<16^ke(255*Me.g,0,255)<<8^ke(255*Me.b,0,255)<<0}getHexString(t=dn){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=Ts){Ai.fromWorkingColorSpace(No(this,Me),e);const i=Me.r,n=Me.g,r=Me.b,a=Math.max(i,n,r),o=Math.min(i,n,r);let l,h;const c=(o+a)/2;if(o===a)l=0,h=0;else{const u=a-o;switch(h=c<=.5?u/(a+o):u/(2-a-o),a){case i:l=(n-r)/u+(n<r?6:0);break;case n:l=(r-i)/u+2;break;case r:l=(i-n)/u+4}l/=6}return t.h=l,t.s=h,t.l=c,t}getRGB(t,e=Ts){return Ai.fromWorkingColorSpace(No(this,Me),e),t.r=Me.r,t.g=Me.g,t.b=Me.b,t}getStyle(t=dn){return Ai.fromWorkingColorSpace(No(this,Me),t),t!==dn?`color(${t} ${Me.r} ${Me.g} ${Me.b})`:`rgb(${255*Me.r|0},${255*Me.g|0},${255*Me.b|0})`}offsetHSL(t,e,i){return this.getHSL(Pi),Pi.h+=t,Pi.s+=e,Pi.l+=i,this.setHSL(Pi.h,Pi.s,Pi.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(Pi),t.getHSL(ko);const i=Sa(Pi.h,ko.h,e),n=Sa(Pi.s,ko.s,e),r=Sa(Pi.l,ko.l,e);return this.setHSL(i,n,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let mr;tt.NAMES=Yd;class Zd{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{mr===void 0&&(mr=Ta("canvas")),mr.width=t.width,mr.height=t.height;const i=mr.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=mr}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=Ta("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const n=i.getImageData(0,0,t.width,t.height),r=n.data;for(let a=0;a<r.length;a++)r[a]=255*Cs(r[a]/255);return i.putImageData(n,0,0),e}if(t.data){const e=t.data.slice(0);for(let i=0;i<e.length;i++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[i]=Math.floor(255*Cs(e[i]/255)):e[i]=Cs(e[i]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class Jd{constructor(t=null){this.isSource=!0,this.uuid=Ei(),this.data=t,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const i={uuid:this.uuid,url:""},n=this.data;if(n!==null){let r;if(Array.isArray(n)){r=[];for(let a=0,o=n.length;a<o;a++)n[a].isDataTexture?r.push(kh(n[a].image)):r.push(kh(n[a]))}else r=kh(n);i.url=r}return e||(t.images[this.uuid]=i),i}}function kh(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?Zd.getDataURL(s):s.data?{data:Array.prototype.slice.call(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let K0=0;class ne extends pn{constructor(t=ne.DEFAULT_IMAGE,e=ne.DEFAULT_MAPPING,i=ue,n=ue,r=Wt,a=ys,o=$t,l=Vn,h=1,c=un){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:K0++}),this.uuid=Ei(),this.name="",this.source=new Jd(t),this.mipmaps=[],this.mapping=e,this.wrapS=i,this.wrapT=n,this.magFilter=r,this.minFilter=a,this.anisotropy=h,this.format=o,this.internalFormat=null,this.type=l,this.offset=new j(0,0),this.repeat=new j(1,1),this.center=new j(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ke,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==300)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case ze:t.x=t.x-Math.floor(t.x);break;case ue:t.x=t.x<0?0:1;break;case Lo:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case ze:t.y=t.y-Math.floor(t.y);break;case ue:t.y=t.y<0?0:1;break;case Lo:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}}ne.DEFAULT_IMAGE=null,ne.DEFAULT_MAPPING=300;class Lt{constructor(t=0,e=0,i=0,n=1){this.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=n}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,n){return this.x=t,this.y=e,this.z=i,this.w=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,r=this.w,a=t.elements;return this.x=a[0]*e+a[4]*i+a[8]*n+a[12]*r,this.y=a[1]*e+a[5]*i+a[9]*n+a[13]*r,this.z=a[2]*e+a[6]*i+a[10]*n+a[14]*r,this.w=a[3]*e+a[7]*i+a[11]*n+a[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,n,r;const l=t.elements,h=l[0],c=l[4],u=l[8],p=l[1],m=l[5],f=l[9],g=l[2],_=l[6],v=l[10];if(Math.abs(c-p)<.01&&Math.abs(u-g)<.01&&Math.abs(f-_)<.01){if(Math.abs(c+p)<.1&&Math.abs(u+g)<.1&&Math.abs(f+_)<.1&&Math.abs(h+m+v-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const y=(h+1)/2,b=(m+1)/2,S=(v+1)/2,w=(c+p)/4,C=(u+g)/4,L=(f+_)/4;return y>b&&y>S?y<.01?(i=0,n=.707106781,r=.707106781):(i=Math.sqrt(y),n=w/i,r=C/i):b>S?b<.01?(i=.707106781,n=0,r=.707106781):(n=Math.sqrt(b),i=w/n,r=L/n):S<.01?(i=.707106781,n=.707106781,r=0):(r=Math.sqrt(S),i=C/r,n=L/r),this.set(i,n,r,e),this}let x=Math.sqrt((_-f)*(_-f)+(u-g)*(u-g)+(p-c)*(p-c));return Math.abs(x)<.001&&(x=1),this.x=(_-f)/x,this.y=(u-g)/x,this.z=(p-c)/x,this.w=Math.acos((h+m+v-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class de extends pn{constructor(t,e,i={}){super(),this.isWebGLRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new Lt(0,0,t,e),this.scissorTest=!1,this.viewport=new Lt(0,0,t,e);const n={width:t,height:e,depth:1};this.texture=new ne(n,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=i.generateMipmaps!==void 0&&i.generateMipmaps,this.texture.internalFormat=i.internalFormat!==void 0?i.internalFormat:null,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:Wt,this.depthBuffer=i.depthBuffer===void 0||i.depthBuffer,this.stencilBuffer=i.stencilBuffer!==void 0&&i.stencilBuffer,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null,this.samples=i.samples!==void 0?i.samples:0}setSize(t,e,i=1){this.width===t&&this.height===e&&this.depth===i||(this.width=t,this.height=e,this.depth=i,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Jd(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Kd extends ne{constructor(t=null,e=1,i=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:i,depth:n},this.magFilter=Ft,this.minFilter=Ft,this.wrapR=ue,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Q0 extends de{constructor(t,e,i,n={}){super(t,e,n),this.isWebGLMultipleRenderTargets=!0;const r=this.texture;this.texture=[];for(let a=0;a<i;a++)this.texture[a]=r.clone(),this.texture[a].isRenderTargetTexture=!0}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let n=0,r=this.texture.length;n<r;n++)this.texture[n].image.width=t,this.texture[n].image.height=e,this.texture[n].image.depth=i;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.texture.length=0;for(let e=0,i=t.texture.length;e<i;e++)this.texture[e]=t.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}class Ht{constructor(t=0,e=0,i=0,n=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=n}static slerp(t,e,i,n){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,e,n)}static slerpFlat(t,e,i,n,r,a,o){let l=i[n+0],h=i[n+1],c=i[n+2],u=i[n+3];const p=r[a+0],m=r[a+1],f=r[a+2],g=r[a+3];if(o===0)return t[e+0]=l,t[e+1]=h,t[e+2]=c,void(t[e+3]=u);if(o===1)return t[e+0]=p,t[e+1]=m,t[e+2]=f,void(t[e+3]=g);if(u!==g||l!==p||h!==m||c!==f){let _=1-o;const v=l*p+h*m+c*f+u*g,x=v>=0?1:-1,y=1-v*v;if(y>Number.EPSILON){const S=Math.sqrt(y),w=Math.atan2(S,v*x);_=Math.sin(_*w)/S,o=Math.sin(o*w)/S}const b=o*x;if(l=l*_+p*b,h=h*_+m*b,c=c*_+f*b,u=u*_+g*b,_===1-o){const S=1/Math.sqrt(l*l+h*h+c*c+u*u);l*=S,h*=S,c*=S,u*=S}}t[e]=l,t[e+1]=h,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,i,n,r,a){const o=i[n],l=i[n+1],h=i[n+2],c=i[n+3],u=r[a],p=r[a+1],m=r[a+2],f=r[a+3];return t[e]=o*f+c*u+l*m-h*p,t[e+1]=l*f+c*p+h*u-o*m,t[e+2]=h*f+c*m+o*p-l*u,t[e+3]=c*f-o*u-l*p-h*m,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,n){return this._x=t,this._y=e,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,n=t._y,r=t._z,a=t._order,o=Math.cos,l=Math.sin,h=o(i/2),c=o(n/2),u=o(r/2),p=l(i/2),m=l(n/2),f=l(r/2);switch(a){case"XYZ":this._x=p*c*u+h*m*f,this._y=h*m*u-p*c*f,this._z=h*c*f+p*m*u,this._w=h*c*u-p*m*f;break;case"YXZ":this._x=p*c*u+h*m*f,this._y=h*m*u-p*c*f,this._z=h*c*f-p*m*u,this._w=h*c*u+p*m*f;break;case"ZXY":this._x=p*c*u-h*m*f,this._y=h*m*u+p*c*f,this._z=h*c*f+p*m*u,this._w=h*c*u-p*m*f;break;case"ZYX":this._x=p*c*u-h*m*f,this._y=h*m*u+p*c*f,this._z=h*c*f-p*m*u,this._w=h*c*u+p*m*f;break;case"YZX":this._x=p*c*u+h*m*f,this._y=h*m*u+p*c*f,this._z=h*c*f-p*m*u,this._w=h*c*u-p*m*f;break;case"XZY":this._x=p*c*u-h*m*f,this._y=h*m*u-p*c*f,this._z=h*c*f+p*m*u,this._w=h*c*u+p*m*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,n=Math.sin(i);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],n=e[4],r=e[8],a=e[1],o=e[5],l=e[9],h=e[2],c=e[6],u=e[10],p=i+o+u;if(p>0){const m=.5/Math.sqrt(p+1);this._w=.25/m,this._x=(c-l)*m,this._y=(r-h)*m,this._z=(a-n)*m}else if(i>o&&i>u){const m=2*Math.sqrt(1+i-o-u);this._w=(c-l)/m,this._x=.25*m,this._y=(n+a)/m,this._z=(r+h)/m}else if(o>u){const m=2*Math.sqrt(1+o-i-u);this._w=(r-h)/m,this._x=(n+a)/m,this._y=.25*m,this._z=(l+c)/m}else{const m=2*Math.sqrt(1+u-i-o);this._w=(a-n)/m,this._x=(r+h)/m,this._y=(l+c)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ke(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const n=Math.min(1,e/i);return this.slerp(t,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,n=t._y,r=t._z,a=t._w,o=e._x,l=e._y,h=e._z,c=e._w;return this._x=i*c+a*o+n*h-r*l,this._y=n*c+a*l+r*o-i*h,this._z=r*c+a*h+i*l-n*o,this._w=a*c-i*o-n*l-r*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,n=this._y,r=this._z,a=this._w;let o=a*t._w+i*t._x+n*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=a,this._x=i,this._y=n,this._z=r,this;const l=1-o*o;if(l<=Number.EPSILON){const m=1-e;return this._w=m*a+e*this._w,this._x=m*i+e*this._x,this._y=m*n+e*this._y,this._z=m*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(l),c=Math.atan2(h,o),u=Math.sin((1-e)*c)/h,p=Math.sin(e*c)/h;return this._w=a*u+this._w*p,this._x=i*u+this._x*p,this._y=n*u+this._y*p,this._z=r*u+this._z*p,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=Math.random(),e=Math.sqrt(1-t),i=Math.sqrt(t),n=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(n),i*Math.sin(r),i*Math.cos(r),e*Math.sin(n))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class M{constructor(t=0,e=0,i=0){this.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Qd.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Qd.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6]*n,this.y=r[1]*e+r[4]*i+r[7]*n,this.z=r[2]*e+r[5]*i+r[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,r=t.elements,a=1/(r[3]*e+r[7]*i+r[11]*n+r[15]);return this.x=(r[0]*e+r[4]*i+r[8]*n+r[12])*a,this.y=(r[1]*e+r[5]*i+r[9]*n+r[13])*a,this.z=(r[2]*e+r[6]*i+r[10]*n+r[14])*a,this}applyQuaternion(t){const e=this.x,i=this.y,n=this.z,r=t.x,a=t.y,o=t.z,l=t.w,h=l*e+a*n-o*i,c=l*i+o*e-r*n,u=l*n+r*i-a*e,p=-r*e-a*i-o*n;return this.x=h*l+p*-r+c*-o-u*-a,this.y=c*l+p*-a+u*-r-h*-o,this.z=u*l+p*-o+h*-a-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*n,this.y=r[1]*e+r[5]*i+r[9]*n,this.z=r[2]*e+r[6]*i+r[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,n=t.y,r=t.z,a=e.x,o=e.y,l=e.z;return this.x=n*l-r*o,this.y=r*a-i*l,this.z=i*o-n*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return Nh.copy(this).projectOnVector(t),this.sub(Nh)}reflect(t){return this.sub(Nh.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(ke(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,n=this.z-t.z;return e*e+i*i+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const n=Math.sin(e)*t;return this.x=n*Math.sin(i),this.y=Math.cos(e)*t,this.z=n*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=n,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(e),this.y=i*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Nh=new M,Qd=new Ht;class He{constructor(t=new M(1/0,1/0,1/0),e=new M(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,i=1/0,n=1/0,r=-1/0,a=-1/0,o=-1/0;for(let l=0,h=t.length;l<h;l+=3){const c=t[l],u=t[l+1],p=t[l+2];c<e&&(e=c),u<i&&(i=u),p<n&&(n=p),c>r&&(r=c),u>a&&(a=u),p>o&&(o=p)}return this.min.set(e,i,n),this.max.set(r,a,o),this}setFromBufferAttribute(t){let e=1/0,i=1/0,n=1/0,r=-1/0,a=-1/0,o=-1/0;for(let l=0,h=t.count;l<h;l++){const c=t.getX(l),u=t.getY(l),p=t.getZ(l);c<e&&(e=c),u<i&&(i=u),p<n&&(n=p),c>r&&(r=c),u>a&&(a=u),p>o&&(o=p)}return this.min.set(e,i,n),this.max.set(r,a,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=Es.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(i!==void 0)if(e&&i.attributes!=null&&i.attributes.position!==void 0){const r=i.attributes.position;for(let a=0,o=r.count;a<o;a++)Es.fromBufferAttribute(r,a).applyMatrix4(t.matrixWorld),this.expandByPoint(Es)}else i.boundingBox===null&&i.computeBoundingBox(),Uh.copy(i.boundingBox),Uh.applyMatrix4(t.matrixWorld),this.union(Uh);const n=t.children;for(let r=0,a=n.length;r<a;r++)this.expandByObject(n[r],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Es),Es.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Ca),Uo.subVectors(this.max,Ca),fr.subVectors(t.a,Ca),gr.subVectors(t.b,Ca),_r.subVectors(t.c,Ca),jn.subVectors(gr,fr),Gn.subVectors(_r,gr),As.subVectors(fr,_r);let e=[0,-jn.z,jn.y,0,-Gn.z,Gn.y,0,-As.z,As.y,jn.z,0,-jn.x,Gn.z,0,-Gn.x,As.z,0,-As.x,-jn.y,jn.x,0,-Gn.y,Gn.x,0,-As.y,As.x,0];return!!Fh(e,fr,gr,_r,Uo)&&(e=[1,0,0,0,1,0,0,0,1],!!Fh(e,fr,gr,_r,Uo)&&(Fo.crossVectors(jn,Gn),e=[Fo.x,Fo.y,Fo.z],Fh(e,fr,gr,_r,Uo)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Es.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(Es).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(mn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),mn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),mn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),mn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),mn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),mn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),mn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),mn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(mn)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const mn=[new M,new M,new M,new M,new M,new M,new M,new M],Es=new M,Uh=new He,fr=new M,gr=new M,_r=new M,jn=new M,Gn=new M,As=new M,Ca=new M,Uo=new M,Fo=new M,Ps=new M;function Fh(s,t,e,i,n){for(let r=0,a=s.length-3;r<=a;r+=3){Ps.fromArray(s,r);const o=n.x*Math.abs(Ps.x)+n.y*Math.abs(Ps.y)+n.z*Math.abs(Ps.z),l=t.dot(Ps),h=e.dot(Ps),c=i.dot(Ps);if(Math.max(-Math.max(l,h,c),Math.min(l,h,c))>o)return!1}return!0}const $0=new He,$d=new M,Bo=new M,Bh=new M;class mi{constructor(t=new M,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):$0.setFromPoints(t).getCenter(i);let n=0;for(let r=0,a=t.length;r<a;r++)n=Math.max(n,i.distanceToSquared(t[r]));return this.radius=Math.sqrt(n),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Bh.subVectors(t,this.center);const e=Bh.lengthSq();if(e>this.radius*this.radius){const i=Math.sqrt(e),n=.5*(i-this.radius);this.center.add(Bh.multiplyScalar(n/i)),this.radius+=n}return this}union(t){return this.center.equals(t.center)===!0?Bo.set(0,0,1).multiplyScalar(t.radius):Bo.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint($d.copy(t.center).add(Bo)),this.expandByPoint($d.copy(t.center).sub(Bo)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const fn=new M,Vh=new M,Vo=new M,Wn=new M,Hh=new M,Ho=new M,jh=new M;class vr{constructor(t=new M,e=new M(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,fn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=fn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(fn.copy(this.direction).multiplyScalar(e).add(this.origin),fn.distanceToSquared(t))}distanceSqToSegment(t,e,i,n){Vh.copy(t).add(e).multiplyScalar(.5),Vo.copy(e).sub(t).normalize(),Wn.copy(this.origin).sub(Vh);const r=.5*t.distanceTo(e),a=-this.direction.dot(Vo),o=Wn.dot(this.direction),l=-Wn.dot(Vo),h=Wn.lengthSq(),c=Math.abs(1-a*a);let u,p,m,f;if(c>0)if(u=a*l-o,p=a*o-l,f=r*c,u>=0)if(p>=-f)if(p<=f){const g=1/c;u*=g,p*=g,m=u*(u+a*p+2*o)+p*(a*u+p+2*l)+h}else p=r,u=Math.max(0,-(a*p+o)),m=-u*u+p*(p+2*l)+h;else p=-r,u=Math.max(0,-(a*p+o)),m=-u*u+p*(p+2*l)+h;else p<=-f?(u=Math.max(0,-(-a*r+o)),p=u>0?-r:Math.min(Math.max(-r,-l),r),m=-u*u+p*(p+2*l)+h):p<=f?(u=0,p=Math.min(Math.max(-r,-l),r),m=p*(p+2*l)+h):(u=Math.max(0,-(a*r+o)),p=u>0?r:Math.min(Math.max(-r,-l),r),m=-u*u+p*(p+2*l)+h);else p=a>0?-r:r,u=Math.max(0,-(a*p+o)),m=-u*u+p*(p+2*l)+h;return i&&i.copy(this.direction).multiplyScalar(u).add(this.origin),n&&n.copy(Vo).multiplyScalar(p).add(Vh),m}intersectSphere(t,e){fn.subVectors(t.center,this.origin);const i=fn.dot(this.direction),n=fn.dot(fn)-i*i,r=t.radius*t.radius;if(n>r)return null;const a=Math.sqrt(r-n),o=i-a,l=i+a;return o<0&&l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0?!0:t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,n,r,a,o,l;const h=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,p=this.origin;return h>=0?(i=(t.min.x-p.x)*h,n=(t.max.x-p.x)*h):(i=(t.max.x-p.x)*h,n=(t.min.x-p.x)*h),c>=0?(r=(t.min.y-p.y)*c,a=(t.max.y-p.y)*c):(r=(t.max.y-p.y)*c,a=(t.min.y-p.y)*c),i>a||r>n?null:((r>i||i!=i)&&(i=r),(a<n||n!=n)&&(n=a),u>=0?(o=(t.min.z-p.z)*u,l=(t.max.z-p.z)*u):(o=(t.max.z-p.z)*u,l=(t.min.z-p.z)*u),i>l||o>n?null:((o>i||i!=i)&&(i=o),(l<n||n!=n)&&(n=l),n<0?null:this.at(i>=0?i:n,e)))}intersectsBox(t){return this.intersectBox(t,fn)!==null}intersectTriangle(t,e,i,n,r){Hh.subVectors(e,t),Ho.subVectors(i,t),jh.crossVectors(Hh,Ho);let a,o=this.direction.dot(jh);if(o>0){if(n)return null;a=1}else{if(!(o<0))return null;a=-1,o=-o}Wn.subVectors(this.origin,t);const l=a*this.direction.dot(Ho.crossVectors(Wn,Ho));if(l<0)return null;const h=a*this.direction.dot(Hh.cross(Wn));if(h<0||l+h>o)return null;const c=-a*Wn.dot(jh);return c<0?null:this.at(c/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class rt{constructor(){this.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,n,r,a,o,l,h,c,u,p,m,f,g,_){const v=this.elements;return v[0]=t,v[4]=e,v[8]=i,v[12]=n,v[1]=r,v[5]=a,v[9]=o,v[13]=l,v[2]=h,v[6]=c,v[10]=u,v[14]=p,v[3]=m,v[7]=f,v[11]=g,v[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new rt().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,n=1/xr.setFromMatrixColumn(t,0).length(),r=1/xr.setFromMatrixColumn(t,1).length(),a=1/xr.setFromMatrixColumn(t,2).length();return e[0]=i[0]*n,e[1]=i[1]*n,e[2]=i[2]*n,e[3]=0,e[4]=i[4]*r,e[5]=i[5]*r,e[6]=i[6]*r,e[7]=0,e[8]=i[8]*a,e[9]=i[9]*a,e[10]=i[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,i=t.x,n=t.y,r=t.z,a=Math.cos(i),o=Math.sin(i),l=Math.cos(n),h=Math.sin(n),c=Math.cos(r),u=Math.sin(r);if(t.order==="XYZ"){const p=a*c,m=a*u,f=o*c,g=o*u;e[0]=l*c,e[4]=-l*u,e[8]=h,e[1]=m+f*h,e[5]=p-g*h,e[9]=-o*l,e[2]=g-p*h,e[6]=f+m*h,e[10]=a*l}else if(t.order==="YXZ"){const p=l*c,m=l*u,f=h*c,g=h*u;e[0]=p+g*o,e[4]=f*o-m,e[8]=a*h,e[1]=a*u,e[5]=a*c,e[9]=-o,e[2]=m*o-f,e[6]=g+p*o,e[10]=a*l}else if(t.order==="ZXY"){const p=l*c,m=l*u,f=h*c,g=h*u;e[0]=p-g*o,e[4]=-a*u,e[8]=f+m*o,e[1]=m+f*o,e[5]=a*c,e[9]=g-p*o,e[2]=-a*h,e[6]=o,e[10]=a*l}else if(t.order==="ZYX"){const p=a*c,m=a*u,f=o*c,g=o*u;e[0]=l*c,e[4]=f*h-m,e[8]=p*h+g,e[1]=l*u,e[5]=g*h+p,e[9]=m*h-f,e[2]=-h,e[6]=o*l,e[10]=a*l}else if(t.order==="YZX"){const p=a*l,m=a*h,f=o*l,g=o*h;e[0]=l*c,e[4]=g-p*u,e[8]=f*u+m,e[1]=u,e[5]=a*c,e[9]=-o*c,e[2]=-h*c,e[6]=m*u+f,e[10]=p-g*u}else if(t.order==="XZY"){const p=a*l,m=a*h,f=o*l,g=o*h;e[0]=l*c,e[4]=-u,e[8]=h*c,e[1]=p*u+g,e[5]=a*c,e[9]=m*u-f,e[2]=f*u-m,e[6]=o*c,e[10]=g*u+p}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(tv,t,ev)}lookAt(t,e,i){const n=this.elements;return si.subVectors(t,e),si.lengthSq()===0&&(si.z=1),si.normalize(),Xn.crossVectors(i,si),Xn.lengthSq()===0&&(Math.abs(i.z)===1?si.x+=1e-4:si.z+=1e-4,si.normalize(),Xn.crossVectors(i,si)),Xn.normalize(),jo.crossVectors(si,Xn),n[0]=Xn.x,n[4]=jo.x,n[8]=si.x,n[1]=Xn.y,n[5]=jo.y,n[9]=si.y,n[2]=Xn.z,n[6]=jo.z,n[10]=si.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,r=this.elements,a=i[0],o=i[4],l=i[8],h=i[12],c=i[1],u=i[5],p=i[9],m=i[13],f=i[2],g=i[6],_=i[10],v=i[14],x=i[3],y=i[7],b=i[11],S=i[15],w=n[0],C=n[4],L=n[8],T=n[12],E=n[1],I=n[5],z=n[9],B=n[13],O=n[2],F=n[6],Q=n[10],k=n[14],X=n[3],U=n[7],H=n[11],Z=n[15];return r[0]=a*w+o*E+l*O+h*X,r[4]=a*C+o*I+l*F+h*U,r[8]=a*L+o*z+l*Q+h*H,r[12]=a*T+o*B+l*k+h*Z,r[1]=c*w+u*E+p*O+m*X,r[5]=c*C+u*I+p*F+m*U,r[9]=c*L+u*z+p*Q+m*H,r[13]=c*T+u*B+p*k+m*Z,r[2]=f*w+g*E+_*O+v*X,r[6]=f*C+g*I+_*F+v*U,r[10]=f*L+g*z+_*Q+v*H,r[14]=f*T+g*B+_*k+v*Z,r[3]=x*w+y*E+b*O+S*X,r[7]=x*C+y*I+b*F+S*U,r[11]=x*L+y*z+b*Q+S*H,r[15]=x*T+y*B+b*k+S*Z,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],n=t[8],r=t[12],a=t[1],o=t[5],l=t[9],h=t[13],c=t[2],u=t[6],p=t[10],m=t[14];return t[3]*(+r*l*u-n*h*u-r*o*p+i*h*p+n*o*m-i*l*m)+t[7]*(+e*l*m-e*h*p+r*a*p-n*a*m+n*h*c-r*l*c)+t[11]*(+e*h*u-e*o*m-r*a*u+i*a*m+r*o*c-i*h*c)+t[15]*(-n*o*c-e*l*u+e*o*p+n*a*u-i*a*p+i*l*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=e,n[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],r=t[3],a=t[4],o=t[5],l=t[6],h=t[7],c=t[8],u=t[9],p=t[10],m=t[11],f=t[12],g=t[13],_=t[14],v=t[15],x=u*_*h-g*p*h+g*l*m-o*_*m-u*l*v+o*p*v,y=f*p*h-c*_*h-f*l*m+a*_*m+c*l*v-a*p*v,b=c*g*h-f*u*h+f*o*m-a*g*m-c*o*v+a*u*v,S=f*u*l-c*g*l-f*o*p+a*g*p+c*o*_-a*u*_,w=e*x+i*y+n*b+r*S;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/w;return t[0]=x*C,t[1]=(g*p*r-u*_*r-g*n*m+i*_*m+u*n*v-i*p*v)*C,t[2]=(o*_*r-g*l*r+g*n*h-i*_*h-o*n*v+i*l*v)*C,t[3]=(u*l*r-o*p*r-u*n*h+i*p*h+o*n*m-i*l*m)*C,t[4]=y*C,t[5]=(c*_*r-f*p*r+f*n*m-e*_*m-c*n*v+e*p*v)*C,t[6]=(f*l*r-a*_*r-f*n*h+e*_*h+a*n*v-e*l*v)*C,t[7]=(a*p*r-c*l*r+c*n*h-e*p*h-a*n*m+e*l*m)*C,t[8]=b*C,t[9]=(f*u*r-c*g*r-f*i*m+e*g*m+c*i*v-e*u*v)*C,t[10]=(a*g*r-f*o*r+f*i*h-e*g*h-a*i*v+e*o*v)*C,t[11]=(c*o*r-a*u*r-c*i*h+e*u*h+a*i*m-e*o*m)*C,t[12]=S*C,t[13]=(c*g*n-f*u*n+f*i*p-e*g*p-c*i*_+e*u*_)*C,t[14]=(f*o*n-a*g*n-f*i*l+e*g*l+a*i*_-e*o*_)*C,t[15]=(a*u*n-c*o*n+c*i*l-e*u*l-a*i*p+e*o*p)*C,this}scale(t){const e=this.elements,i=t.x,n=t.y,r=t.z;return e[0]*=i,e[4]*=n,e[8]*=r,e[1]*=i,e[5]*=n,e[9]*=r,e[2]*=i,e[6]*=n,e[10]*=r,e[3]*=i,e[7]*=n,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,n))}makeTranslation(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),n=Math.sin(e),r=1-i,a=t.x,o=t.y,l=t.z,h=r*a,c=r*o;return this.set(h*a+i,h*o-n*l,h*l+n*o,0,h*o+n*l,c*o+i,c*l-n*a,0,h*l-n*o,c*l+n*a,r*l*l+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,n,r,a){return this.set(1,i,r,0,t,1,a,0,e,n,1,0,0,0,0,1),this}compose(t,e,i){const n=this.elements,r=e._x,a=e._y,o=e._z,l=e._w,h=r+r,c=a+a,u=o+o,p=r*h,m=r*c,f=r*u,g=a*c,_=a*u,v=o*u,x=l*h,y=l*c,b=l*u,S=i.x,w=i.y,C=i.z;return n[0]=(1-(g+v))*S,n[1]=(m+b)*S,n[2]=(f-y)*S,n[3]=0,n[4]=(m-b)*w,n[5]=(1-(p+v))*w,n[6]=(_+x)*w,n[7]=0,n[8]=(f+y)*C,n[9]=(_-x)*C,n[10]=(1-(p+g))*C,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,e,i){const n=this.elements;let r=xr.set(n[0],n[1],n[2]).length();const a=xr.set(n[4],n[5],n[6]).length(),o=xr.set(n[8],n[9],n[10]).length();this.determinant()<0&&(r=-r),t.x=n[12],t.y=n[13],t.z=n[14],Ri.copy(this);const l=1/r,h=1/a,c=1/o;return Ri.elements[0]*=l,Ri.elements[1]*=l,Ri.elements[2]*=l,Ri.elements[4]*=h,Ri.elements[5]*=h,Ri.elements[6]*=h,Ri.elements[8]*=c,Ri.elements[9]*=c,Ri.elements[10]*=c,e.setFromRotationMatrix(Ri),i.x=r,i.y=a,i.z=o,this}makePerspective(t,e,i,n,r,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*r/(e-t),h=2*r/(i-n),c=(e+t)/(e-t),u=(i+n)/(i-n),p=-(a+r)/(a-r),m=-2*a*r/(a-r);return o[0]=l,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=h,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=p,o[14]=m,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,i,n,r,a){const o=this.elements,l=1/(e-t),h=1/(i-n),c=1/(a-r),u=(e+t)*l,p=(i+n)*h,m=(a+r)*c;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-p,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-m,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let n=0;n<16;n++)if(e[n]!==i[n])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const xr=new M,Ri=new rt,tv=new M(0,0,0),ev=new M(1,1,1),Xn=new M,jo=new M,si=new M,tp=new rt,ep=new Ht;class Wi{constructor(t=0,e=0,i=0,n=Wi.DefaultOrder){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=n}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,n=this._order){return this._x=t,this._y=e,this._z=i,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const n=t.elements,r=n[0],a=n[4],o=n[8],l=n[1],h=n[5],c=n[9],u=n[2],p=n[6],m=n[10];switch(e){case"XYZ":this._y=Math.asin(ke(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,m),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(p,h),this._z=0);break;case"YXZ":this._x=Math.asin(-ke(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,m),this._z=Math.atan2(l,h)):(this._y=Math.atan2(-u,r),this._z=0);break;case"ZXY":this._x=Math.asin(ke(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-u,m),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-ke(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(p,m),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,h));break;case"YZX":this._z=Math.asin(ke(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,h),this._y=Math.atan2(-u,r)):(this._x=0,this._y=Math.atan2(o,m));break;case"XZY":this._z=Math.asin(-ke(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(p,h),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-c,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return tp.makeRotationFromQuaternion(t),this.setFromRotationMatrix(tp,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return ep.setFromEuler(this),this.setFromQuaternion(ep,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}Wi.DefaultOrder="XYZ",Wi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Gh{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}isEnabled(t){return(this.mask&(1<<t|0))!=0}}let iv=0;const ip=new M,yr=new Ht,gn=new rt,Go=new M,Ea=new M,nv=new M,sv=new Ht,np=new M(1,0,0),sp=new M(0,1,0),rp=new M(0,0,1),rv={type:"added"},ap={type:"removed"};class St extends pn{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:iv++}),this.uuid=Ei(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=St.DefaultUp.clone();const t=new M,e=new Wi,i=new Ht,n=new M(1,1,1);e._onChange(function(){i.setFromEuler(e,!1)}),i._onChange(function(){e.setFromQuaternion(i,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new rt},normalMatrix:{value:new Ke}}),this.matrix=new rt,this.matrixWorld=new rt,this.matrixAutoUpdate=St.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Gh,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return yr.setFromAxisAngle(t,e),this.quaternion.multiply(yr),this}rotateOnWorldAxis(t,e){return yr.setFromAxisAngle(t,e),this.quaternion.premultiply(yr),this}rotateX(t){return this.rotateOnAxis(np,t)}rotateY(t){return this.rotateOnAxis(sp,t)}rotateZ(t){return this.rotateOnAxis(rp,t)}translateOnAxis(t,e){return ip.copy(t).applyQuaternion(this.quaternion),this.position.add(ip.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(np,t)}translateY(t){return this.translateOnAxis(sp,t)}translateZ(t){return this.translateOnAxis(rp,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(gn.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?Go.copy(t):Go.set(t,e,i);const n=this.parent;this.updateWorldMatrix(!0,!1),Ea.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?gn.lookAt(Ea,Go,this.up):gn.lookAt(Go,Ea,this.up),this.quaternion.setFromRotationMatrix(gn),n&&(gn.extractRotation(n.matrixWorld),yr.setFromRotationMatrix(gn),this.quaternion.premultiply(yr.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(rv)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(ap)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(ap)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),gn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),gn.multiply(t.parent.matrixWorld)),t.applyMatrix4(gn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,n=this.children.length;i<n;i++){const r=this.children[i].getObjectByProperty(t,e);if(r!==void 0)return r}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ea,t,nv),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ea,sv,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(t===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const n=this.children;for(let r=0,a=n.length;r<a;r++)n[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const n={};function r(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(t)),l.uuid}if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(n.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=r(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let h=0,c=l.length;h<c;h++){const u=l[h];r(t.shapes,u)}else r(t.shapes,l)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,h=this.material.length;l<h;l++)o.push(r(t.materials,this.material[l]));n.material=o}else n.material=r(t.materials,this.material);if(this.children.length>0){n.children=[];for(let o=0;o<this.children.length;o++)n.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){n.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];n.animations.push(r(t.animations,l))}}if(e){const o=a(t.geometries),l=a(t.materials),h=a(t.textures),c=a(t.images),u=a(t.shapes),p=a(t.skeletons),m=a(t.animations),f=a(t.nodes);o.length>0&&(i.geometries=o),l.length>0&&(i.materials=l),h.length>0&&(i.textures=h),c.length>0&&(i.images=c),u.length>0&&(i.shapes=u),p.length>0&&(i.skeletons=p),m.length>0&&(i.animations=m),f.length>0&&(i.nodes=f)}return i.object=n,i;function a(o){const l=[];for(const h in o){const c=o[h];delete c.metadata,l.push(c)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let i=0;i<t.children.length;i++){const n=t.children[i];this.add(n.clone())}return this}}St.DefaultUp=new M(0,1,0),St.DefaultMatrixAutoUpdate=!0;const Di=new M,_n=new M,Wh=new M,vn=new M,br=new M,Mr=new M,op=new M,Xh=new M,qh=new M,Yh=new M;class xn{constructor(t=new M,e=new M,i=new M){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,n){n.subVectors(i,e),Di.subVectors(t,e),n.cross(Di);const r=n.lengthSq();return r>0?n.multiplyScalar(1/Math.sqrt(r)):n.set(0,0,0)}static getBarycoord(t,e,i,n,r){Di.subVectors(n,e),_n.subVectors(i,e),Wh.subVectors(t,e);const a=Di.dot(Di),o=Di.dot(_n),l=Di.dot(Wh),h=_n.dot(_n),c=_n.dot(Wh),u=a*h-o*o;if(u===0)return r.set(-2,-1,-1);const p=1/u,m=(h*l-o*c)*p,f=(a*c-o*l)*p;return r.set(1-m-f,f,m)}static containsPoint(t,e,i,n){return this.getBarycoord(t,e,i,n,vn),vn.x>=0&&vn.y>=0&&vn.x+vn.y<=1}static getUV(t,e,i,n,r,a,o,l){return this.getBarycoord(t,e,i,n,vn),l.set(0,0),l.addScaledVector(r,vn.x),l.addScaledVector(a,vn.y),l.addScaledVector(o,vn.z),l}static isFrontFacing(t,e,i,n){return Di.subVectors(i,e),_n.subVectors(t,e),Di.cross(_n).dot(n)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,n){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[n]),this}setFromAttributeAndIndices(t,e,i,n){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,n),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Di.subVectors(this.c,this.b),_n.subVectors(this.a,this.b),.5*Di.cross(_n).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return xn.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return xn.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,i,n,r){return xn.getUV(t,this.a,this.b,this.c,e,i,n,r)}containsPoint(t){return xn.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return xn.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,n=this.b,r=this.c;let a,o;br.subVectors(n,i),Mr.subVectors(r,i),Xh.subVectors(t,i);const l=br.dot(Xh),h=Mr.dot(Xh);if(l<=0&&h<=0)return e.copy(i);qh.subVectors(t,n);const c=br.dot(qh),u=Mr.dot(qh);if(c>=0&&u<=c)return e.copy(n);const p=l*u-c*h;if(p<=0&&l>=0&&c<=0)return a=l/(l-c),e.copy(i).addScaledVector(br,a);Yh.subVectors(t,r);const m=br.dot(Yh),f=Mr.dot(Yh);if(f>=0&&m<=f)return e.copy(r);const g=m*h-l*f;if(g<=0&&h>=0&&f<=0)return o=h/(h-f),e.copy(i).addScaledVector(Mr,o);const _=c*f-m*u;if(_<=0&&u-c>=0&&m-f>=0)return op.subVectors(r,n),o=(u-c)/(u-c+(m-f)),e.copy(n).addScaledVector(op,o);const v=1/(_+g+p);return a=g*v,o=p*v,e.copy(i).addScaledVector(br,a).addScaledVector(Mr,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let av=0;class ve extends pn{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:av++}),this.uuid=Ei(),this.name="",this.type="Material",this.blending=ar,this.side=Fn,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=vd,this.blendDst=xd,this.blendEquation=or,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=bh,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ba,this.stencilZFail=ba,this.stencilZPass=ba,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const i=t[e];if(i===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===1;continue}const n=this[e];n!==void 0?n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[e]=i:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function n(r){const a=[];for(const o in r){const l=r[o];delete l.metadata,a.push(l)}return a}if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==ar&&(i.blending=this.blending),this.side!==Fn&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),e){const r=n(t.textures),a=n(t.images);r.length>0&&(i.textures=r),a.length>0&&(i.images=a)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(e!==null){const n=e.length;i=new Array(n);for(let r=0;r!==n;++r)i[r]=e[r].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}get vertexTangents(){return console.warn("THREE."+this.type+": .vertexTangents has been removed."),!1}set vertexTangents(t){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}ve.fromType=function(){return null};class ae extends ve{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new tt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ro,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const xe=new M,Wo=new j;class se{constructor(t,e,i){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=i===!0,this.usage=pr,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let n=0,r=this.itemSize;n<r;n++)this.array[t+n]=e.array[i+n];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let i=0;for(let n=0,r=t.length;n<r;n++){let a=t[n];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",n),a=new tt),e[i++]=a.r,e[i++]=a.g,e[i++]=a.b}return this}copyVector2sArray(t){const e=this.array;let i=0;for(let n=0,r=t.length;n<r;n++){let a=t[n];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",n),a=new j),e[i++]=a.x,e[i++]=a.y}return this}copyVector3sArray(t){const e=this.array;let i=0;for(let n=0,r=t.length;n<r;n++){let a=t[n];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",n),a=new M),e[i++]=a.x,e[i++]=a.y,e[i++]=a.z}return this}copyVector4sArray(t){const e=this.array;let i=0;for(let n=0,r=t.length;n<r;n++){let a=t[n];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",n),a=new Lt),e[i++]=a.x,e[i++]=a.y,e[i++]=a.z,e[i++]=a.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,i=this.count;e<i;e++)Wo.fromBufferAttribute(this,e),Wo.applyMatrix3(t),this.setXY(e,Wo.x,Wo.y);else if(this.itemSize===3)for(let e=0,i=this.count;e<i;e++)xe.fromBufferAttribute(this,e),xe.applyMatrix3(t),this.setXYZ(e,xe.x,xe.y,xe.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)xe.fromBufferAttribute(this,e),xe.applyMatrix4(t),this.setXYZ(e,xe.x,xe.y,xe.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)xe.fromBufferAttribute(this,e),xe.applyNormalMatrix(t),this.setXYZ(e,xe.x,xe.y,xe.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)xe.fromBufferAttribute(this,e),xe.transformDirection(t),this.setXYZ(e,xe.x,xe.y,xe.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this}setXYZW(t,e,i,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==pr&&(t.usage=this.usage),this.updateRange.offset===0&&this.updateRange.count===-1||(t.updateRange=this.updateRange),t}}class lp extends se{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class Zh extends se{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class et extends se{constructor(t,e,i){super(new Float32Array(t),e,i)}}let ov=0;const fi=new rt,Jh=new St,wr=new M,ri=new He,Aa=new He,Te=new M;class Pt extends pn{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:ov++}),this.uuid=Ei(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(qd(t)?Zh:lp)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const r=new Ke().getNormalMatrix(t);i.applyNormalMatrix(r),i.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(t),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return fi.makeRotationFromQuaternion(t),this.applyMatrix4(fi),this}rotateX(t){return fi.makeRotationX(t),this.applyMatrix4(fi),this}rotateY(t){return fi.makeRotationY(t),this.applyMatrix4(fi),this}rotateZ(t){return fi.makeRotationZ(t),this.applyMatrix4(fi),this}translate(t,e,i){return fi.makeTranslation(t,e,i),this.applyMatrix4(fi),this}scale(t,e,i){return fi.makeScale(t,e,i),this.applyMatrix4(fi),this}lookAt(t){return Jh.lookAt(t),Jh.updateMatrix(),this.applyMatrix4(Jh.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(wr).negate(),this.translate(wr.x,wr.y,wr.z),this}setFromPoints(t){const e=[];for(let i=0,n=t.length;i<n;i++){const r=t[i];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new et(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new He);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new M(-1/0,-1/0,-1/0),new M(1/0,1/0,1/0));if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let i=0,n=e.length;i<n;i++){const r=e[i];ri.setFromBufferAttribute(r),this.morphTargetsRelative?(Te.addVectors(this.boundingBox.min,ri.min),this.boundingBox.expandByPoint(Te),Te.addVectors(this.boundingBox.max,ri.max),this.boundingBox.expandByPoint(Te)):(this.boundingBox.expandByPoint(ri.min),this.boundingBox.expandByPoint(ri.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new mi);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new M,1/0);if(t){const i=this.boundingSphere.center;if(ri.setFromBufferAttribute(t),e)for(let r=0,a=e.length;r<a;r++){const o=e[r];Aa.setFromBufferAttribute(o),this.morphTargetsRelative?(Te.addVectors(ri.min,Aa.min),ri.expandByPoint(Te),Te.addVectors(ri.max,Aa.max),ri.expandByPoint(Te)):(ri.expandByPoint(Aa.min),ri.expandByPoint(Aa.max))}ri.getCenter(i);let n=0;for(let r=0,a=t.count;r<a;r++)Te.fromBufferAttribute(t,r),n=Math.max(n,i.distanceToSquared(Te));if(e)for(let r=0,a=e.length;r<a;r++){const o=e[r],l=this.morphTargetsRelative;for(let h=0,c=o.count;h<c;h++)Te.fromBufferAttribute(o,h),l&&(wr.fromBufferAttribute(t,h),Te.add(wr)),n=Math.max(n,i.distanceToSquared(Te))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const i=t.array,n=e.position.array,r=e.normal.array,a=e.uv.array,o=n.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new se(new Float32Array(4*o),4));const l=this.getAttribute("tangent").array,h=[],c=[];for(let E=0;E<o;E++)h[E]=new M,c[E]=new M;const u=new M,p=new M,m=new M,f=new j,g=new j,_=new j,v=new M,x=new M;function y(E,I,z){u.fromArray(n,3*E),p.fromArray(n,3*I),m.fromArray(n,3*z),f.fromArray(a,2*E),g.fromArray(a,2*I),_.fromArray(a,2*z),p.sub(u),m.sub(u),g.sub(f),_.sub(f);const B=1/(g.x*_.y-_.x*g.y);isFinite(B)&&(v.copy(p).multiplyScalar(_.y).addScaledVector(m,-g.y).multiplyScalar(B),x.copy(m).multiplyScalar(g.x).addScaledVector(p,-_.x).multiplyScalar(B),h[E].add(v),h[I].add(v),h[z].add(v),c[E].add(x),c[I].add(x),c[z].add(x))}let b=this.groups;b.length===0&&(b=[{start:0,count:i.length}]);for(let E=0,I=b.length;E<I;++E){const z=b[E],B=z.start;for(let O=B,F=B+z.count;O<F;O+=3)y(i[O+0],i[O+1],i[O+2])}const S=new M,w=new M,C=new M,L=new M;function T(E){C.fromArray(r,3*E),L.copy(C);const I=h[E];S.copy(I),S.sub(C.multiplyScalar(C.dot(I))).normalize(),w.crossVectors(L,I);const z=w.dot(c[E])<0?-1:1;l[4*E]=S.x,l[4*E+1]=S.y,l[4*E+2]=S.z,l[4*E+3]=z}for(let E=0,I=b.length;E<I;++E){const z=b[E],B=z.start;for(let O=B,F=B+z.count;O<F;O+=3)T(i[O+0]),T(i[O+1]),T(i[O+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new se(new Float32Array(3*e.count),3),this.setAttribute("normal",i);else for(let p=0,m=i.count;p<m;p++)i.setXYZ(p,0,0,0);const n=new M,r=new M,a=new M,o=new M,l=new M,h=new M,c=new M,u=new M;if(t)for(let p=0,m=t.count;p<m;p+=3){const f=t.getX(p+0),g=t.getX(p+1),_=t.getX(p+2);n.fromBufferAttribute(e,f),r.fromBufferAttribute(e,g),a.fromBufferAttribute(e,_),c.subVectors(a,r),u.subVectors(n,r),c.cross(u),o.fromBufferAttribute(i,f),l.fromBufferAttribute(i,g),h.fromBufferAttribute(i,_),o.add(c),l.add(c),h.add(c),i.setXYZ(f,o.x,o.y,o.z),i.setXYZ(g,l.x,l.y,l.z),i.setXYZ(_,h.x,h.y,h.z)}else for(let p=0,m=e.count;p<m;p+=3)n.fromBufferAttribute(e,p+0),r.fromBufferAttribute(e,p+1),a.fromBufferAttribute(e,p+2),c.subVectors(a,r),u.subVectors(n,r),c.cross(u),i.setXYZ(p+0,c.x,c.y,c.z),i.setXYZ(p+1,c.x,c.y,c.z),i.setXYZ(p+2,c.x,c.y,c.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const n in i){if(t.attributes[n]===void 0)continue;const r=i[n].array,a=t.attributes[n],o=a.array,l=a.itemSize*e,h=Math.min(o.length,r.length-l);for(let c=0,u=l;c<h;c++,u++)r[u]=o[c]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)Te.fromBufferAttribute(t,e),Te.normalize(),t.setXYZ(e,Te.x,Te.y,Te.z)}toNonIndexed(){function t(o,l){const h=o.array,c=o.itemSize,u=o.normalized,p=new h.constructor(l.length*c);let m=0,f=0;for(let g=0,_=l.length;g<_;g++){m=o.isInterleavedBufferAttribute?l[g]*o.data.stride+o.offset:l[g]*c;for(let v=0;v<c;v++)p[f++]=h[m++]}return new se(p,c,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Pt,i=this.index.array,n=this.attributes;for(const o in n){const l=t(n[o],i);e.setAttribute(o,l)}const r=this.morphAttributes;for(const o in r){const l=[],h=r[o];for(let c=0,u=h.length;c<u;c++){const p=t(h[c],i);l.push(p)}e.morphAttributes[o]=l}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const h=a[o];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const h in l)l[h]!==void 0&&(t[h]=l[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const l in i){const h=i[l];t.data.attributes[l]=h.toJSON(t.data)}const n={};let r=!1;for(const l in this.morphAttributes){const h=this.morphAttributes[l],c=[];for(let u=0,p=h.length;u<p;u++){const m=h[u];c.push(m.toJSON(t.data))}c.length>0&&(n[l]=c,r=!0)}r&&(t.data.morphAttributes=n,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;i!==null&&this.setIndex(i.clone(e));const n=t.attributes;for(const h in n){const c=n[h];this.setAttribute(h,c.clone(e))}const r=t.morphAttributes;for(const h in r){const c=[],u=r[h];for(let p=0,m=u.length;p<m;p++)c.push(u[p].clone(e));this.morphAttributes[h]=c}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let h=0,c=a.length;h<c;h++){const u=a[h];this.addGroup(u.start,u.count,u.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const hp=new rt,Sr=new vr,Kh=new mi,qn=new M,Yn=new M,Zn=new M,Qh=new M,$h=new M,tc=new M,Xo=new M,qo=new M,Yo=new M,Zo=new j,Jo=new j,Ko=new j,ec=new M,Qo=new M;class lt extends St{constructor(t=new Pt,e=new ae){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=i.length;n<r;n++){const a=i[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}raycast(t,e){const i=this.geometry,n=this.material,r=this.matrixWorld;if(n===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),Kh.copy(i.boundingSphere),Kh.applyMatrix4(r),t.ray.intersectsSphere(Kh)===!1)||(hp.copy(r).invert(),Sr.copy(t.ray).applyMatrix4(hp),i.boundingBox!==null&&Sr.intersectsBox(i.boundingBox)===!1))return;let a;const o=i.index,l=i.attributes.position,h=i.morphAttributes.position,c=i.morphTargetsRelative,u=i.attributes.uv,p=i.attributes.uv2,m=i.groups,f=i.drawRange;if(o!==null)if(Array.isArray(n))for(let g=0,_=m.length;g<_;g++){const v=m[g],x=n[v.materialIndex];for(let y=Math.max(v.start,f.start),b=Math.min(o.count,Math.min(v.start+v.count,f.start+f.count));y<b;y+=3){const S=o.getX(y),w=o.getX(y+1),C=o.getX(y+2);a=$o(this,x,t,Sr,l,h,c,u,p,S,w,C),a&&(a.faceIndex=Math.floor(y/3),a.face.materialIndex=v.materialIndex,e.push(a))}}else for(let g=Math.max(0,f.start),_=Math.min(o.count,f.start+f.count);g<_;g+=3){const v=o.getX(g),x=o.getX(g+1),y=o.getX(g+2);a=$o(this,n,t,Sr,l,h,c,u,p,v,x,y),a&&(a.faceIndex=Math.floor(g/3),e.push(a))}else if(l!==void 0)if(Array.isArray(n))for(let g=0,_=m.length;g<_;g++){const v=m[g],x=n[v.materialIndex];for(let y=Math.max(v.start,f.start),b=Math.min(l.count,Math.min(v.start+v.count,f.start+f.count));y<b;y+=3)a=$o(this,x,t,Sr,l,h,c,u,p,y,y+1,y+2),a&&(a.faceIndex=Math.floor(y/3),a.face.materialIndex=v.materialIndex,e.push(a))}else for(let g=Math.max(0,f.start),_=Math.min(l.count,f.start+f.count);g<_;g+=3)a=$o(this,n,t,Sr,l,h,c,u,p,g,g+1,g+2),a&&(a.faceIndex=Math.floor(g/3),e.push(a))}}function $o(s,t,e,i,n,r,a,o,l,h,c,u){qn.fromBufferAttribute(n,h),Yn.fromBufferAttribute(n,c),Zn.fromBufferAttribute(n,u);const p=s.morphTargetInfluences;if(r&&p){Xo.set(0,0,0),qo.set(0,0,0),Yo.set(0,0,0);for(let f=0,g=r.length;f<g;f++){const _=p[f],v=r[f];_!==0&&(Qh.fromBufferAttribute(v,h),$h.fromBufferAttribute(v,c),tc.fromBufferAttribute(v,u),a?(Xo.addScaledVector(Qh,_),qo.addScaledVector($h,_),Yo.addScaledVector(tc,_)):(Xo.addScaledVector(Qh.sub(qn),_),qo.addScaledVector($h.sub(Yn),_),Yo.addScaledVector(tc.sub(Zn),_)))}qn.add(Xo),Yn.add(qo),Zn.add(Yo)}s.isSkinnedMesh&&(s.boneTransform(h,qn),s.boneTransform(c,Yn),s.boneTransform(u,Zn));const m=function(f,g,_,v,x,y,b,S){let w;if(w=g.side===pi?v.intersectTriangle(b,y,x,!0,S):v.intersectTriangle(x,y,b,g.side!==ce,S),w===null)return null;Qo.copy(S),Qo.applyMatrix4(f.matrixWorld);const C=_.ray.origin.distanceTo(Qo);return C<_.near||C>_.far?null:{distance:C,point:Qo.clone(),object:f}}(s,t,e,i,qn,Yn,Zn,ec);if(m){o&&(Zo.fromBufferAttribute(o,h),Jo.fromBufferAttribute(o,c),Ko.fromBufferAttribute(o,u),m.uv=xn.getUV(ec,qn,Yn,Zn,Zo,Jo,Ko,new j)),l&&(Zo.fromBufferAttribute(l,h),Jo.fromBufferAttribute(l,c),Ko.fromBufferAttribute(l,u),m.uv2=xn.getUV(ec,qn,Yn,Zn,Zo,Jo,Ko,new j));const f={a:h,b:c,c:u,normal:new M,materialIndex:0};xn.getNormal(qn,Yn,Zn,f.normal),m.face=f}return m}class oe extends Pt{constructor(t=1,e=1,i=1,n=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:n,heightSegments:r,depthSegments:a};const o=this;n=Math.floor(n),r=Math.floor(r),a=Math.floor(a);const l=[],h=[],c=[],u=[];let p=0,m=0;function f(g,_,v,x,y,b,S,w,C,L,T){const E=b/C,I=S/L,z=b/2,B=S/2,O=w/2,F=C+1,Q=L+1;let k=0,X=0;const U=new M;for(let H=0;H<Q;H++){const Z=H*I-B;for(let mt=0;mt<F;mt++){const _t=mt*E-z;U[g]=_t*x,U[_]=Z*y,U[v]=O,h.push(U.x,U.y,U.z),U[g]=0,U[_]=0,U[v]=w>0?1:-1,c.push(U.x,U.y,U.z),u.push(mt/C),u.push(1-H/L),k+=1}}for(let H=0;H<L;H++)for(let Z=0;Z<C;Z++){const mt=p+Z+F*H,_t=p+Z+F*(H+1),Mt=p+(Z+1)+F*(H+1),wt=p+(Z+1)+F*H;l.push(mt,_t,wt),l.push(_t,Mt,wt),X+=6}o.addGroup(m,X,T),m+=X,p+=k}f("z","y","x",-1,-1,i,e,t,a,r,0),f("z","y","x",1,-1,i,e,-t,a,r,1),f("x","z","y",1,1,t,i,e,n,a,2),f("x","z","y",1,-1,t,i,-e,n,a,3),f("x","y","z",1,-1,t,e,i,n,r,4),f("x","y","z",-1,-1,t,e,-i,n,r,5),this.setIndex(l),this.setAttribute("position",new et(h,3)),this.setAttribute("normal",new et(c,3)),this.setAttribute("uv",new et(u,2))}static fromJSON(t){return new oe(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Tr(s){const t={};for(const e in s){t[e]={};for(const i in s[e]){const n=s[e][i];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?t[e][i]=n.clone():Array.isArray(n)?t[e][i]=n.slice():t[e][i]=n}}return t}function Ne(s){const t={};for(let e=0;e<s.length;e++){const i=Tr(s[e]);for(const n in i)t[n]=i[n]}return t}const pt={clone:Tr,merge:Ne};class Zt extends ve{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,this.fragmentShader=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Tr(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?e.uniforms[n]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[n]={type:"m4",value:r.toArray()}:e.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const i={};for(const n in this.extensions)this.extensions[n]===!0&&(i[n]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}class cp extends St{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new rt,this.projectionMatrix=new rt,this.projectionMatrixInverse=new rt}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class ye extends cp{constructor(t=50,e=1,i=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=n,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*wa*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Ma*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*wa*Math.atan(Math.tan(.5*Ma*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,i,n,r,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Ma*this.fov)/this.zoom,i=2*e,n=this.aspect*i,r=-.5*n;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,h=a.fullHeight;r+=a.offsetX*n/l,e-=a.offsetY*i/h,n*=a.width/l,i*=a.height/h}const o=this.filmOffset;o!==0&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+n,e,e-i,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const Cr=90;class lv extends St{constructor(t,e,i){if(super(),this.type="CubeCamera",i.isWebGLCubeRenderTarget!==!0)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=i;const n=new ye(Cr,1,t,e);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new M(1,0,0)),this.add(n);const r=new ye(Cr,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new M(-1,0,0)),this.add(r);const a=new ye(Cr,1,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new M(0,1,0)),this.add(a);const o=new ye(Cr,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new M(0,-1,0)),this.add(o);const l=new ye(Cr,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new M(0,0,1)),this.add(l);const h=new ye(Cr,1,t,e);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new M(0,0,-1)),this.add(h)}update(t,e){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[n,r,a,o,l,h]=this.children,c=t.getRenderTarget(),u=t.toneMapping,p=t.xr.enabled;t.toneMapping=cn,t.xr.enabled=!1;const m=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0),t.render(e,n),t.setRenderTarget(i,1),t.render(e,r),t.setRenderTarget(i,2),t.render(e,a),t.setRenderTarget(i,3),t.render(e,o),t.setRenderTarget(i,4),t.render(e,l),i.texture.generateMipmaps=m,t.setRenderTarget(i,5),t.render(e,h),t.setRenderTarget(c),t.toneMapping=u,t.xr.enabled=p,i.texture.needsPMREMUpdate=!0}}class tl extends ne{constructor(t,e,i,n,r,a,o,l,h,c){super(t=t!==void 0?t:[],e=e!==void 0?e:lr,i,n,r,a,o,l,h,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class hv extends de{constructor(t,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const i={width:t,height:t,depth:1},n=[i,i,i,i,i,i];this.texture=new tl(n,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0&&e.generateMipmaps,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Wt}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},n=new oe(5,5,5),r=new Zt({name:"CubemapFromEquirect",uniforms:Tr(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:pi,blending:Bn});r.uniforms.tEquirect.value=e;const a=new lt(n,r),o=e.minFilter;return e.minFilter===ys&&(e.minFilter=Wt),new lv(1,10,this).update(t,a),e.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,i,n){const r=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,i,n);t.setRenderTarget(r)}}const ic=new M,cv=new M,uv=new Ke;class ai{constructor(t=new M(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,n){return this.normal.set(t,e,i),this.constant=n,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const n=ic.subVectors(i,e).cross(cv.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const i=t.delta(ic),n=this.normal.dot(i);if(n===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/n;return r<0||r>1?null:e.copy(i).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||uv.getNormalMatrix(t),n=this.coplanarPoint(ic).applyMatrix4(t),r=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Er=new mi,el=new M;class Pa{constructor(t=new ai,e=new ai,i=new ai,n=new ai,r=new ai,a=new ai){this.planes=[t,e,i,n,r,a]}set(t,e,i,n,r,a){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(i),o[3].copy(n),o[4].copy(r),o[5].copy(a),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const e=this.planes,i=t.elements,n=i[0],r=i[1],a=i[2],o=i[3],l=i[4],h=i[5],c=i[6],u=i[7],p=i[8],m=i[9],f=i[10],g=i[11],_=i[12],v=i[13],x=i[14],y=i[15];return e[0].setComponents(o-n,u-l,g-p,y-_).normalize(),e[1].setComponents(o+n,u+l,g+p,y+_).normalize(),e[2].setComponents(o+r,u+h,g+m,y+v).normalize(),e[3].setComponents(o-r,u-h,g-m,y-v).normalize(),e[4].setComponents(o-a,u-c,g-f,y-x).normalize(),e[5].setComponents(o+a,u+c,g+f,y+x).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),Er.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Er)}intersectsSprite(t){return Er.center.set(0,0,0),Er.radius=.7071067811865476,Er.applyMatrix4(t.matrixWorld),this.intersectsSphere(Er)}intersectsSphere(t){const e=this.planes,i=t.center,n=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(i)<n)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const n=e[i];if(el.x=n.normal.x>0?t.max.x:t.min.x,el.y=n.normal.y>0?t.max.y:t.min.y,el.z=n.normal.z>0?t.max.z:t.min.z,n.distanceToPoint(el)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function up(){let s=null,t=!1,e=null,i=null;function n(r,a){e(r,a),i=s.requestAnimationFrame(n)}return{start:function(){t!==!0&&e!==null&&(i=s.requestAnimationFrame(n),t=!0)},stop:function(){s.cancelAnimationFrame(i),t=!1},setAnimationLoop:function(r){e=r},setContext:function(r){s=r}}}function dv(s,t){const e=t.isWebGL2,i=new WeakMap;return{get:function(n){return n.isInterleavedBufferAttribute&&(n=n.data),i.get(n)},remove:function(n){n.isInterleavedBufferAttribute&&(n=n.data);const r=i.get(n);r&&(s.deleteBuffer(r.buffer),i.delete(n))},update:function(n,r){if(n.isGLBufferAttribute){const o=i.get(n);return void((!o||o.version<n.version)&&i.set(n,{buffer:n.buffer,type:n.type,bytesPerElement:n.elementSize,version:n.version}))}n.isInterleavedBufferAttribute&&(n=n.data);const a=i.get(n);a===void 0?i.set(n,function(o,l){const h=o.array,c=o.usage,u=s.createBuffer();let p;if(s.bindBuffer(l,u),s.bufferData(l,h,c),o.onUploadCallback(),h instanceof Float32Array)p=5126;else if(h instanceof Uint16Array)if(o.isFloat16BufferAttribute){if(!e)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");p=5131}else p=5123;else if(h instanceof Int16Array)p=5122;else if(h instanceof Uint32Array)p=5125;else if(h instanceof Int32Array)p=5124;else if(h instanceof Int8Array)p=5120;else if(h instanceof Uint8Array)p=5121;else{if(!(h instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);p=5121}return{buffer:u,type:p,bytesPerElement:h.BYTES_PER_ELEMENT,version:o.version}}(n,r)):a.version<n.version&&(function(o,l,h){const c=l.array,u=l.updateRange;s.bindBuffer(h,o),u.count===-1?s.bufferSubData(h,0,c):(e?s.bufferSubData(h,u.offset*c.BYTES_PER_ELEMENT,c,u.offset,u.count):s.bufferSubData(h,u.offset*c.BYTES_PER_ELEMENT,c.subarray(u.offset,u.offset+u.count)),u.count=-1)}(a.buffer,n,r),a.version=n.version)}}}class Rs extends Pt{constructor(t=1,e=1,i=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:n};const r=t/2,a=e/2,o=Math.floor(i),l=Math.floor(n),h=o+1,c=l+1,u=t/o,p=e/l,m=[],f=[],g=[],_=[];for(let v=0;v<c;v++){const x=v*p-a;for(let y=0;y<h;y++){const b=y*u-r;f.push(b,-x,0),g.push(0,0,1),_.push(y/o),_.push(1-v/l)}}for(let v=0;v<l;v++)for(let x=0;x<o;x++){const y=x+h*v,b=x+h*(v+1),S=x+1+h*(v+1),w=x+1+h*v;m.push(y,b,w),m.push(b,S,w)}this.setIndex(m),this.setAttribute("position",new et(f,3)),this.setAttribute("normal",new et(g,3)),this.setAttribute("uv",new et(_,2))}static fromJSON(t){return new Rs(t.width,t.height,t.widthSegments,t.heightSegments)}}const dt={alphamap_fragment:`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,alphamap_pars_fragment:`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment:`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,alphatest_pars_fragment:`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment:`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment:`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs:`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,iridescence_fragment:`#ifdef USE_IRIDESCENCE
const mat3 XYZ_TO_REC709 = mat3(
    3.2404542, -0.9692660,  0.0556434,
   -1.5371385,  1.8760108, -0.2040259,
   -0.4985314,  0.0415560,  1.0572252
);
vec3 Fresnel0ToIor( vec3 fresnel0 ) {
   vec3 sqrtF0 = sqrt( fresnel0 );
   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
}
vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
}
float IorToFresnel0( float transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
}
vec3 evalSensitivity( float OPD, vec3 shift ) {
   float phase = 2.0 * PI * OPD * 1.0e-9;
   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );
   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );
   xyz /= 1.0685e-7;
   vec3 srgb = XYZ_TO_REC709 * xyz;
   return srgb;
}
vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
   vec3 I;
   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
   float cosTheta2Sq = 1.0 - sinTheta2Sq;
   if ( cosTheta2Sq < 0.0 ) {
       return vec3( 1.0 );
   }
   float cosTheta2 = sqrt( cosTheta2Sq );
   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
   float R12 = F_Schlick( R0, 1.0, cosTheta1 );
   float R21 = R12;
   float T121 = 1.0 - R12;
   float phi12 = 0.0;
   if ( iridescenceIOR < outsideIOR ) phi12 = PI;
   float phi21 = PI - phi12;
   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
   vec3 phi23 = vec3( 0.0 );
   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;
   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;
   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;
   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
   vec3 phi = vec3( phi21 ) + phi23;
   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
   vec3 r123 = sqrt( R123 );
   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
   vec3 C0 = R12 + Rs;
   I = C0;
   vec3 Cm = Rs - T121;
   for ( int m = 1; m <= 2; ++m ) {
       Cm *= r123;
       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
       I += Cm * Sm;
   }
   return max( I, vec3( 0.0 ) );
}
#endif`,bumpmap_pars_fragment:`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment:`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,clipping_planes_pars_fragment:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex:`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment:`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex:`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common:`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,cube_uv_reflection_fragment:`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex:`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex:`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex:`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment:`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment:`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,envmap_fragment:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment:`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment:`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex:`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_physical_pars_fragment:`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			#if defined( ENVMAP_TYPE_CUBE_UV )
				vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
				vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );
			#else
				vec4 envMapColor = textureCube( envMap, worldNormal );
			#endif
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			#if defined( ENVMAP_TYPE_CUBE_UV )
				vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			#else
				vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
				vec4 envMapColor = textureCube( envMap, queryReflectVec );
			#endif
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,envmap_vertex:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex:`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex:`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment:`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment:`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment:`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,lightmap_fragment:`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,lightmap_pars_fragment:`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_vertex:`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,lights_pars_begin:`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,lights_toon_fragment:`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment:`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,lights_phong_fragment:`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment:`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,lights_physical_fragment:`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,lights_physical_pars_fragment:`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin:`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
float dotNVi = saturate( dot( normal, geometry.viewDir ) );
if ( material.iridescenceThickness == 0.0 ) {
	material.iridescence = 0.0;
} else {
	material.iridescence = saturate( material.iridescence );
}
if ( material.iridescence > 0.0 ) {
	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps:`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && ( defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE ) )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end:`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,logdepthbuf_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment:`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment:`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment:`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment:`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphcolor_vertex:`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex:`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,morphtarget_pars_vertex:`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,morphtarget_vertex:`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,normal_fragment_begin:`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,normal_fragment_maps:`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment:`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex:`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex:`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment:`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,clearcoat_normal_fragment_begin:`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,clearcoat_normal_fragment_maps:`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,clearcoat_pars_fragment:`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,iridescence_pars_fragment:`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,output_fragment:`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing:`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,premultiplied_alpha_fragment:`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex:`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment:`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment:`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment:`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment:`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,shadowmask_pars_fragment:`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex:`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex:`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,skinning_vertex:`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex:`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment:`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment:`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment:`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment:`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment:`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,transmission_pars_fragment:`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,uv_pars_fragment:`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,uv_pars_vertex:`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,uv_vertex:`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,uv2_pars_fragment:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,uv2_pars_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,uv2_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,worldpos_vertex:`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,background_frag:`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,cube_frag:`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,depth_vert:`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,meshbasic_vert:`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,shadow_vert:`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`},ot={common:{diffuse:{value:new tt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Ke},uv2Transform:{value:new Ke},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new j(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new tt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new tt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Ke}},sprite:{diffuse:{value:new tt(16777215)},opacity:{value:1},center:{value:new j(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Ke}}},oi={basic:{uniforms:Ne([ot.common,ot.specularmap,ot.envmap,ot.aomap,ot.lightmap,ot.fog]),vertexShader:dt.meshbasic_vert,fragmentShader:dt.meshbasic_frag},lambert:{uniforms:Ne([ot.common,ot.specularmap,ot.envmap,ot.aomap,ot.lightmap,ot.emissivemap,ot.fog,ot.lights,{emissive:{value:new tt(0)}}]),vertexShader:dt.meshlambert_vert,fragmentShader:dt.meshlambert_frag},phong:{uniforms:Ne([ot.common,ot.specularmap,ot.envmap,ot.aomap,ot.lightmap,ot.emissivemap,ot.bumpmap,ot.normalmap,ot.displacementmap,ot.fog,ot.lights,{emissive:{value:new tt(0)},specular:{value:new tt(1118481)},shininess:{value:30}}]),vertexShader:dt.meshphong_vert,fragmentShader:dt.meshphong_frag},standard:{uniforms:Ne([ot.common,ot.envmap,ot.aomap,ot.lightmap,ot.emissivemap,ot.bumpmap,ot.normalmap,ot.displacementmap,ot.roughnessmap,ot.metalnessmap,ot.fog,ot.lights,{emissive:{value:new tt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:dt.meshphysical_vert,fragmentShader:dt.meshphysical_frag},toon:{uniforms:Ne([ot.common,ot.aomap,ot.lightmap,ot.emissivemap,ot.bumpmap,ot.normalmap,ot.displacementmap,ot.gradientmap,ot.fog,ot.lights,{emissive:{value:new tt(0)}}]),vertexShader:dt.meshtoon_vert,fragmentShader:dt.meshtoon_frag},matcap:{uniforms:Ne([ot.common,ot.bumpmap,ot.normalmap,ot.displacementmap,ot.fog,{matcap:{value:null}}]),vertexShader:dt.meshmatcap_vert,fragmentShader:dt.meshmatcap_frag},points:{uniforms:Ne([ot.points,ot.fog]),vertexShader:dt.points_vert,fragmentShader:dt.points_frag},dashed:{uniforms:Ne([ot.common,ot.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:dt.linedashed_vert,fragmentShader:dt.linedashed_frag},depth:{uniforms:Ne([ot.common,ot.displacementmap]),vertexShader:dt.depth_vert,fragmentShader:dt.depth_frag},normal:{uniforms:Ne([ot.common,ot.bumpmap,ot.normalmap,ot.displacementmap,{opacity:{value:1}}]),vertexShader:dt.meshnormal_vert,fragmentShader:dt.meshnormal_frag},sprite:{uniforms:Ne([ot.sprite,ot.fog]),vertexShader:dt.sprite_vert,fragmentShader:dt.sprite_frag},background:{uniforms:{uvTransform:{value:new Ke},t2D:{value:null}},vertexShader:dt.background_vert,fragmentShader:dt.background_frag},cube:{uniforms:Ne([ot.envmap,{opacity:{value:1}}]),vertexShader:dt.cube_vert,fragmentShader:dt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:dt.equirect_vert,fragmentShader:dt.equirect_frag},distanceRGBA:{uniforms:Ne([ot.common,ot.displacementmap,{referencePosition:{value:new M},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:dt.distanceRGBA_vert,fragmentShader:dt.distanceRGBA_frag},shadow:{uniforms:Ne([ot.lights,ot.fog,{color:{value:new tt(0)},opacity:{value:1}}]),vertexShader:dt.shadow_vert,fragmentShader:dt.shadow_frag}};function pv(s,t,e,i,n,r){const a=new tt(0);let o,l,h=n===!0?0:1,c=null,u=0,p=null;function m(f,g){e.buffers.color.setClear(f.r,f.g,f.b,g,r)}return{getClearColor:function(){return a},setClearColor:function(f,g=1){a.set(f),h=g,m(a,h)},getClearAlpha:function(){return h},setClearAlpha:function(f){h=f,m(a,h)},render:function(f,g){let _=!1,v=g.isScene===!0?g.background:null;v&&v.isTexture&&(v=t.get(v));const x=s.xr,y=x.getSession&&x.getSession();y&&y.environmentBlendMode==="additive"&&(v=null),v===null?m(a,h):v&&v.isColor&&(m(v,1),_=!0),(s.autoClear||_)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),v&&(v.isCubeTexture||v.mapping===xs)?(l===void 0&&(l=new lt(new oe(1,1,1),new Zt({name:"BackgroundCubeMaterial",uniforms:Tr(oi.cube.uniforms),vertexShader:oi.cube.vertexShader,fragmentShader:oi.cube.fragmentShader,side:pi,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(b,S,w){this.matrixWorld.copyPosition(w.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(l)),l.material.uniforms.envMap.value=v,l.material.uniforms.flipEnvMap.value=v.isCubeTexture&&v.isRenderTargetTexture===!1?-1:1,c===v&&u===v.version&&p===s.toneMapping||(l.material.needsUpdate=!0,c=v,u=v.version,p=s.toneMapping),l.layers.enableAll(),f.unshift(l,l.geometry,l.material,0,0,null)):v&&v.isTexture&&(o===void 0&&(o=new lt(new Rs(2,2),new Zt({name:"BackgroundMaterial",uniforms:Tr(oi.background.uniforms),vertexShader:oi.background.vertexShader,fragmentShader:oi.background.fragmentShader,side:Fn,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=v,v.matrixAutoUpdate===!0&&v.updateMatrix(),o.material.uniforms.uvTransform.value.copy(v.matrix),c===v&&u===v.version&&p===s.toneMapping||(o.material.needsUpdate=!0,c=v,u=v.version,p=s.toneMapping),o.layers.enableAll(),f.unshift(o,o.geometry,o.material,0,0,null))}}}function mv(s,t,e,i){const n=s.getParameter(34921),r=i.isWebGL2?null:t.get("OES_vertex_array_object"),a=i.isWebGL2||r!==null,o={},l=m(null);let h=l,c=!1;function u(S){return i.isWebGL2?s.bindVertexArray(S):r.bindVertexArrayOES(S)}function p(S){return i.isWebGL2?s.deleteVertexArray(S):r.deleteVertexArrayOES(S)}function m(S){const w=[],C=[],L=[];for(let T=0;T<n;T++)w[T]=0,C[T]=0,L[T]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:w,enabledAttributes:C,attributeDivisors:L,object:S,attributes:{},index:null}}function f(){const S=h.newAttributes;for(let w=0,C=S.length;w<C;w++)S[w]=0}function g(S){_(S,0)}function _(S,w){const C=h.newAttributes,L=h.enabledAttributes,T=h.attributeDivisors;C[S]=1,L[S]===0&&(s.enableVertexAttribArray(S),L[S]=1),T[S]!==w&&((i.isWebGL2?s:t.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](S,w),T[S]=w)}function v(){const S=h.newAttributes,w=h.enabledAttributes;for(let C=0,L=w.length;C<L;C++)w[C]!==S[C]&&(s.disableVertexAttribArray(C),w[C]=0)}function x(S,w,C,L,T,E){i.isWebGL2!==!0||C!==5124&&C!==5125?s.vertexAttribPointer(S,w,C,L,T,E):s.vertexAttribIPointer(S,w,C,T,E)}function y(){b(),c=!0,h!==l&&(h=l,u(h.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(S,w,C,L,T){let E=!1;if(a){const I=function(z,B,O){const F=O.wireframe===!0;let Q=o[z.id];Q===void 0&&(Q={},o[z.id]=Q);let k=Q[B.id];k===void 0&&(k={},Q[B.id]=k);let X=k[F];return X===void 0&&(X=m(i.isWebGL2?s.createVertexArray():r.createVertexArrayOES()),k[F]=X),X}(L,C,w);h!==I&&(h=I,u(h.object)),E=function(z,B,O,F){const Q=h.attributes,k=B.attributes;let X=0;const U=O.getAttributes();for(const H in U)if(U[H].location>=0){const Z=Q[H];let mt=k[H];if(mt===void 0&&(H==="instanceMatrix"&&z.instanceMatrix&&(mt=z.instanceMatrix),H==="instanceColor"&&z.instanceColor&&(mt=z.instanceColor)),Z===void 0||Z.attribute!==mt||mt&&Z.data!==mt.data)return!0;X++}return h.attributesNum!==X||h.index!==F}(S,L,C,T),E&&function(z,B,O,F){const Q={},k=B.attributes;let X=0;const U=O.getAttributes();for(const H in U)if(U[H].location>=0){let Z=k[H];Z===void 0&&(H==="instanceMatrix"&&z.instanceMatrix&&(Z=z.instanceMatrix),H==="instanceColor"&&z.instanceColor&&(Z=z.instanceColor));const mt={};mt.attribute=Z,Z&&Z.data&&(mt.data=Z.data),Q[H]=mt,X++}h.attributes=Q,h.attributesNum=X,h.index=F}(S,L,C,T)}else{const I=w.wireframe===!0;h.geometry===L.id&&h.program===C.id&&h.wireframe===I||(h.geometry=L.id,h.program=C.id,h.wireframe=I,E=!0)}T!==null&&e.update(T,34963),(E||c)&&(c=!1,function(I,z,B,O){if(i.isWebGL2===!1&&(I.isInstancedMesh||O.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;f();const F=O.attributes,Q=B.getAttributes(),k=z.defaultAttributeValues;for(const X in Q){const U=Q[X];if(U.location>=0){let H=F[X];if(H===void 0&&(X==="instanceMatrix"&&I.instanceMatrix&&(H=I.instanceMatrix),X==="instanceColor"&&I.instanceColor&&(H=I.instanceColor)),H!==void 0){const Z=H.normalized,mt=H.itemSize,_t=e.get(H);if(_t===void 0)continue;const Mt=_t.buffer,wt=_t.type,R=_t.bytesPerElement;if(H.isInterleavedBufferAttribute){const A=H.data,G=A.stride,it=H.offset;if(A.isInstancedInterleavedBuffer){for(let V=0;V<U.locationSize;V++)_(U.location+V,A.meshPerAttribute);I.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=A.meshPerAttribute*A.count)}else for(let V=0;V<U.locationSize;V++)g(U.location+V);s.bindBuffer(34962,Mt);for(let V=0;V<U.locationSize;V++)x(U.location+V,mt/U.locationSize,wt,Z,G*R,(it+mt/U.locationSize*V)*R)}else{if(H.isInstancedBufferAttribute){for(let A=0;A<U.locationSize;A++)_(U.location+A,H.meshPerAttribute);I.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=H.meshPerAttribute*H.count)}else for(let A=0;A<U.locationSize;A++)g(U.location+A);s.bindBuffer(34962,Mt);for(let A=0;A<U.locationSize;A++)x(U.location+A,mt/U.locationSize,wt,Z,mt*R,mt/U.locationSize*A*R)}}else if(k!==void 0){const Z=k[X];if(Z!==void 0)switch(Z.length){case 2:s.vertexAttrib2fv(U.location,Z);break;case 3:s.vertexAttrib3fv(U.location,Z);break;case 4:s.vertexAttrib4fv(U.location,Z);break;default:s.vertexAttrib1fv(U.location,Z)}}}}v()}(S,w,C,L),T!==null&&s.bindBuffer(34963,e.get(T).buffer))},reset:y,resetDefaultState:b,dispose:function(){y();for(const S in o){const w=o[S];for(const C in w){const L=w[C];for(const T in L)p(L[T].object),delete L[T];delete w[C]}delete o[S]}},releaseStatesOfGeometry:function(S){if(o[S.id]===void 0)return;const w=o[S.id];for(const C in w){const L=w[C];for(const T in L)p(L[T].object),delete L[T];delete w[C]}delete o[S.id]},releaseStatesOfProgram:function(S){for(const w in o){const C=o[w];if(C[S.id]===void 0)continue;const L=C[S.id];for(const T in L)p(L[T].object),delete L[T];delete C[S.id]}},initAttributes:f,enableAttribute:g,disableUnusedAttributes:v}}function fv(s,t,e,i){const n=i.isWebGL2;let r;this.setMode=function(a){r=a},this.render=function(a,o){s.drawArrays(r,a,o),e.update(o,r,1)},this.renderInstances=function(a,o,l){if(l===0)return;let h,c;if(n)h=s,c="drawArraysInstanced";else if(h=t.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",h===null)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[c](r,a,o,l),e.update(o,r,l)}}function gv(s,t,e){let i;function n(b){if(b==="highp"){if(s.getShaderPrecisionFormat(35633,36338).precision>0&&s.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";b="mediump"}return b==="mediump"&&s.getShaderPrecisionFormat(35633,36337).precision>0&&s.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const r=typeof WebGL2RenderingContext<"u"&&s instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&s instanceof WebGL2ComputeRenderingContext;let a=e.precision!==void 0?e.precision:"highp";const o=n(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=r||t.has("WEBGL_draw_buffers"),h=e.logarithmicDepthBuffer===!0,c=s.getParameter(34930),u=s.getParameter(35660),p=s.getParameter(3379),m=s.getParameter(34076),f=s.getParameter(34921),g=s.getParameter(36347),_=s.getParameter(36348),v=s.getParameter(36349),x=u>0,y=r||t.has("OES_texture_float");return{isWebGL2:r,drawBuffers:l,getMaxAnisotropy:function(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const b=t.get("EXT_texture_filter_anisotropic");i=s.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:n,precision:a,logarithmicDepthBuffer:h,maxTextures:c,maxVertexTextures:u,maxTextureSize:p,maxCubemapSize:m,maxAttributes:f,maxVertexUniforms:g,maxVaryings:_,maxFragmentUniforms:v,vertexTextures:x,floatFragmentTextures:y,floatVertexTextures:x&&y,maxSamples:r?s.getParameter(36183):0}}function _v(s){const t=this;let e=null,i=0,n=!1,r=!1;const a=new ai,o=new Ke,l={value:null,needsUpdate:!1};function h(){l.value!==e&&(l.value=e,l.needsUpdate=i>0),t.numPlanes=i,t.numIntersection=0}function c(u,p,m,f){const g=u!==null?u.length:0;let _=null;if(g!==0){if(_=l.value,f!==!0||_===null){const v=m+4*g,x=p.matrixWorldInverse;o.getNormalMatrix(x),(_===null||_.length<v)&&(_=new Float32Array(v));for(let y=0,b=m;y!==g;++y,b+=4)a.copy(u[y]).applyMatrix4(x,o),a.normal.toArray(_,b),_[b+3]=a.constant}l.value=_,l.needsUpdate=!0}return t.numPlanes=g,t.numIntersection=0,_}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,p,m){const f=u.length!==0||p||i!==0||n;return n=p,e=c(u,m,0),i=u.length,f},this.beginShadows=function(){r=!0,c(null)},this.endShadows=function(){r=!1,h()},this.setState=function(u,p,m){const f=u.clippingPlanes,g=u.clipIntersection,_=u.clipShadows,v=s.get(u);if(!n||f===null||f.length===0||r&&!_)r?c(null):h();else{const x=r?0:i,y=4*x;let b=v.clippingState||null;l.value=b,b=c(f,p,y,m);for(let S=0;S!==y;++S)b[S]=e[S];v.clippingState=b,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=x}}}function vv(s){let t=new WeakMap;function e(n,r){return r===Do?n.mapping=lr:r===Mh&&(n.mapping=hr),n}function i(n){const r=n.target;r.removeEventListener("dispose",i);const a=t.get(r);a!==void 0&&(t.delete(r),a.dispose())}return{get:function(n){if(n&&n.isTexture&&n.isRenderTargetTexture===!1){const r=n.mapping;if(r===Do||r===Mh){if(t.has(n))return e(t.get(n).texture,n.mapping);{const a=n.image;if(a&&a.height>0){const o=new hv(a.height/2);return o.fromEquirectangularTexture(s,n),t.set(n,o),n.addEventListener("dispose",i),e(o.texture,n.mapping)}return null}}}return n},dispose:function(){t=new WeakMap}}}oi.physical={uniforms:Ne([oi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new j(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new tt(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new j},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new tt(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new tt(1,1,1)},specularColorMap:{value:null}}]),vertexShader:dt.meshphysical_vert,fragmentShader:dt.meshphysical_frag};class Ra extends cp{constructor(t=-1,e=1,i=1,n=-1,r=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=n,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,n,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let r=i-t,a=i+t,o=n+e,l=n-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=h*this.view.offsetX,a=r+h*this.view.width,o-=c*this.view.offsetY,l=o-c*this.view.height}this.projectionMatrix.makeOrthographic(r,a,o,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}const Ar=4,dp=[.125,.215,.35,.446,.526,.582],Ds=20,nc=new Ra,pp=new tt;let Da=null;const Ls=(1+Math.sqrt(5))/2,Pr=1/Ls,mp=[new M(1,1,1),new M(-1,1,1),new M(1,1,-1),new M(-1,1,-1),new M(0,Ls,Pr),new M(0,Ls,-Pr),new M(Pr,0,Ls),new M(-Pr,0,Ls),new M(Ls,Pr,0),new M(-Ls,Pr,0)];class La{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,i=.1,n=100,r=null,a=null){return Da=this._renderer.getRenderTarget(),r||(r=this._allocateTargets()),a&&(this._pingPongRenderTarget=a),this._setSize(256),r.depthBuffer=!0,this._sceneToCubeUV(t,i,n,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}prepareForRenderTarget(t,e=null,i=256){this._setSize(i);const{_lodMax:n}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=fp(n));const r=3*Math.max(this._cubeSize,112),a=4*this._cubeSize;this._blurMaterial=_p(n,r,a),t.setSize(r,a),e&&e.setSize(r,a)}fromSceneToRenderTarget(t,e,i,n=0,r=.1,a=100){return Da=this._renderer.getRenderTarget(),this._pingPongRenderTarget=i,this._sceneToCubeUV(t,r,a,e),n>0&&this._blur(e,0,0,n),this._applyPMREM(e),this._renderer.setRenderTarget(Da),e.scissorTest=!1,Ia(e,0,0,e.width,e.height),e}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=xp(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=vp(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Da),t.scissorTest=!1,Ia(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===lr||t.mapping===hr?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Da=this._renderer.getRenderTarget();const i=e||this._allocateTargets();return this._textureToCubeUV(t,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,i={magFilter:Wt,minFilter:Wt,generateMipmaps:!1,type:be,format:$t,encoding:un,depthBuffer:!1},n=gp(t,e,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=gp(t,e,i);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=fp(r)),this._blurMaterial=_p(r,t,e)}return n}_compileMaterial(t){const e=new lt(this._lodPlanes[0],t);this._renderer.compile(e,nc)}_sceneToCubeUV(t,e,i,n){const r=new ye(90,1,e,i),a=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],l=this._renderer,h=l.autoClear,c=l.toneMapping;l.getClearColor(pp),l.toneMapping=cn,l.autoClear=!1;const u=new ae({name:"PMREM.Background",side:pi,depthWrite:!1,depthTest:!1}),p=new lt(new oe,u);let m=!1;const f=t.background;f?f.isColor&&(u.color.copy(f),t.background=null,m=!0):(u.color.copy(pp),m=!0);for(let g=0;g<6;g++){const _=g%3;_===0?(r.up.set(0,a[g],0),r.lookAt(o[g],0,0)):_===1?(r.up.set(0,0,a[g]),r.lookAt(0,o[g],0)):(r.up.set(0,a[g],0),r.lookAt(0,0,o[g]));const v=this._cubeSize;Ia(n,_*v,g>2?v:0,v,v),l.setRenderTarget(n),m&&l.render(p,r),l.render(t,r)}p.geometry.dispose(),p.material.dispose(),l.toneMapping=c,l.autoClear=h,t.background=f}_textureToCubeUV(t,e){const i=this._renderer,n=t.mapping===lr||t.mapping===hr;n?(this._cubemapMaterial===null&&(this._cubemapMaterial=xp()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=vp());const r=n?this._cubemapMaterial:this._equirectMaterial,a=new lt(this._lodPlanes[0],r);r.uniforms.envMap.value=t;const o=this._cubeSize;Ia(e,0,0,3*o,2*o),i.setRenderTarget(e),i.render(a,nc)}_applyPMREM(t){const e=this._renderer,i=e.autoClear;e.autoClear=!1;for(let n=1;n<this._lodPlanes.length;n++){const r=Math.sqrt(this._sigmas[n]*this._sigmas[n]-this._sigmas[n-1]*this._sigmas[n-1]),a=mp[(n-1)%mp.length];this._blur(t,n-1,n,r,a)}e.autoClear=i}_blur(t,e,i,n,r){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,i,n,"latitudinal",r),this._halfBlur(a,t,i,i,n,"longitudinal",r)}_halfBlur(t,e,i,n,r,a,o){const l=this._renderer,h=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new lt(this._lodPlanes[n],h),u=h.uniforms,p=this._sizeLods[i]-1,m=isFinite(r)?Math.PI/(2*p):2*Math.PI/(2*Ds-1),f=r/m,g=isFinite(r)?1+Math.floor(3*f):Ds;g>Ds&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Ds}`);const _=[];let v=0;for(let b=0;b<Ds;++b){const S=b/f,w=Math.exp(-S*S/2);_.push(w),b===0?v+=w:b<g&&(v+=2*w)}for(let b=0;b<_.length;b++)_[b]=_[b]/v;u.envMap.value=t.texture,u.samples.value=g,u.weights.value=_,u.latitudinal.value=a==="latitudinal",o&&(u.poleAxis.value=o);const{_lodMax:x}=this;u.dTheta.value=m,u.mipInt.value=x-i;const y=this._sizeLods[n];Ia(e,3*y*(n>x-Ar?n-x+Ar:0),4*(this._cubeSize-y),3*y,2*y),l.setRenderTarget(e),l.render(c,nc)}}function fp(s){const t=[],e=[],i=[];let n=s;const r=s-Ar+1+dp.length;for(let a=0;a<r;a++){const o=Math.pow(2,n);e.push(o);let l=1/o;a>s-Ar?l=dp[a-s+Ar-1]:a===0&&(l=0),i.push(l);const h=1/(o-2),c=-h,u=1+h,p=[c,c,u,c,u,u,c,c,u,u,c,u],m=6,f=6,g=3,_=2,v=1,x=new Float32Array(g*f*m),y=new Float32Array(_*f*m),b=new Float32Array(v*f*m);for(let w=0;w<m;w++){const C=w%3*2/3-1,L=w>2?0:-1,T=[C,L,0,C+2/3,L,0,C+2/3,L+1,0,C,L,0,C+2/3,L+1,0,C,L+1,0];x.set(T,g*f*w),y.set(p,_*f*w);const E=[w,w,w,w,w,w];b.set(E,v*f*w)}const S=new Pt;S.setAttribute("position",new se(x,g)),S.setAttribute("uv",new se(y,_)),S.setAttribute("faceIndex",new se(b,v)),t.push(S),n>Ar&&n--}return{lodPlanes:t,sizeLods:e,sigmas:i}}function gp(s,t,e){const i=new de(s,t,e);return i.texture.mapping=xs,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function Ia(s,t,e,i,n){s.viewport.set(t,e,i,n),s.scissor.set(t,e,i,n)}function _p(s,t,e){const i=new Float32Array(Ds),n=new M(0,1,0);return new Zt({name:"SphericalGaussianBlur",defines:{n:Ds,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${s}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n}},vertexShader:sc(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Bn,depthTest:!1,depthWrite:!1})}function vp(){return new Zt({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:sc(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Bn,depthTest:!1,depthWrite:!1})}function xp(){return new Zt({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:sc(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Bn,depthTest:!1,depthWrite:!1})}function sc(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		mat3 getRotationMatrix(vec3 axis, float angle) {
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;
		
			return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);
		}
		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}
			mat3 rotationMatrix = getRotationMatrix(vec3(1.0, 0.0, 0.0), 1.57);
			direction = rotationMatrix * direction;
			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function xv(s){let t=new WeakMap,e=null;function i(n){const r=n.target;r.removeEventListener("dispose",i);const a=t.get(r);a!==void 0&&(t.delete(r),a.dispose())}return{get:function(n){if(n&&n.isTexture){const r=n.mapping,a=r===Do||r===Mh,o=r===lr||r===hr;if(a||o){if(n.isRenderTargetTexture&&n.needsPMREMUpdate===!0){n.needsPMREMUpdate=!1;let l=t.get(n);return e===null&&(e=new La(s)),l=a?e.fromEquirectangular(n,l):e.fromCubemap(n,l),t.set(n,l),l.texture}if(t.has(n))return t.get(n).texture;{const l=n.image;if(a&&l&&l.height>0||o&&l&&function(h){let c=0;const u=6;for(let p=0;p<u;p++)h[p]!==void 0&&c++;return c===u}(l)){e===null&&(e=new La(s));const h=a?e.fromEquirectangular(n):e.fromCubemap(n);return t.set(n,h),n.addEventListener("dispose",i),h.texture}return null}}}return n},dispose:function(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}}}function yv(s){const t={};function e(i){if(t[i]!==void 0)return t[i];let n;switch(i){case"WEBGL_depth_texture":n=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=s.getExtension(i)}return t[i]=n,n}return{has:function(i){return e(i)!==null},init:function(i){i.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture")},get:function(i){const n=e(i);return n===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),n}}}function bv(s,t,e,i){const n={},r=new WeakMap;function a(l){const h=l.target;h.index!==null&&t.remove(h.index);for(const u in h.attributes)t.remove(h.attributes[u]);h.removeEventListener("dispose",a),delete n[h.id];const c=r.get(h);c&&(t.remove(c),r.delete(h)),i.releaseStatesOfGeometry(h),h.isInstancedBufferGeometry===!0&&delete h._maxInstanceCount,e.memory.geometries--}function o(l){const h=[],c=l.index,u=l.attributes.position;let p=0;if(c!==null){const g=c.array;p=c.version;for(let _=0,v=g.length;_<v;_+=3){const x=g[_+0],y=g[_+1],b=g[_+2];h.push(x,y,y,b,b,x)}}else{const g=u.array;p=u.version;for(let _=0,v=g.length/3-1;_<v;_+=3){const x=_+0,y=_+1,b=_+2;h.push(x,y,y,b,b,x)}}const m=new(qd(h)?Zh:lp)(h,1);m.version=p;const f=r.get(l);f&&t.remove(f),r.set(l,m)}return{get:function(l,h){return n[h.id]===!0||(h.addEventListener("dispose",a),n[h.id]=!0,e.memory.geometries++),h},update:function(l){const h=l.attributes;for(const u in h)t.update(h[u],34962);const c=l.morphAttributes;for(const u in c){const p=c[u];for(let m=0,f=p.length;m<f;m++)t.update(p[m],34962)}},getWireframeAttribute:function(l){const h=r.get(l);if(h){const c=l.index;c!==null&&h.version<c.version&&o(l)}else o(l);return r.get(l)}}}function Mv(s,t,e,i){const n=i.isWebGL2;let r,a,o;this.setMode=function(l){r=l},this.setIndex=function(l){a=l.type,o=l.bytesPerElement},this.render=function(l,h){s.drawElements(r,h,a,l*o),e.update(h,r,1)},this.renderInstances=function(l,h,c){if(c===0)return;let u,p;if(n)u=s,p="drawElementsInstanced";else if(u=t.get("ANGLE_instanced_arrays"),p="drawElementsInstancedANGLE",u===null)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[p](r,h,a,l*o,c),e.update(h,r,c)}}function wv(s){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(e,i,n){switch(t.calls++,i){case 4:t.triangles+=n*(e/3);break;case 1:t.lines+=n*(e/2);break;case 3:t.lines+=n*(e-1);break;case 2:t.lines+=n*e;break;case 0:t.points+=n*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function Sv(s,t){return s[0]-t[0]}function Tv(s,t){return Math.abs(t[1])-Math.abs(s[1])}function rc(s,t){let e=1;const i=t.isInterleavedBufferAttribute?t.data.array:t.array;i instanceof Int8Array?e=127:i instanceof Int16Array?e=32767:i instanceof Int32Array?e=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",i),s.divideScalar(e)}function Cv(s,t,e){const i={},n=new Float32Array(8),r=new WeakMap,a=new Lt,o=[];for(let l=0;l<8;l++)o[l]=[l,0];return{update:function(l,h,c,u){const p=l.morphTargetInfluences;if(t.isWebGL2===!0){const m=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,f=m!==void 0?m.length:0;let g=r.get(h);if(g===void 0||g.count!==f){let x=function(){B.dispose(),r.delete(h),h.removeEventListener("dispose",x)};g!==void 0&&g.texture.dispose();const y=h.morphAttributes.position!==void 0,b=h.morphAttributes.normal!==void 0,S=h.morphAttributes.color!==void 0,w=h.morphAttributes.position||[],C=h.morphAttributes.normal||[],L=h.morphAttributes.color||[];let T=0;y===!0&&(T=1),b===!0&&(T=2),S===!0&&(T=3);let E=h.attributes.position.count*T,I=1;E>t.maxTextureSize&&(I=Math.ceil(E/t.maxTextureSize),E=t.maxTextureSize);const z=new Float32Array(E*I*4*f),B=new Kd(z,E,I,f);B.type=Ve,B.needsUpdate=!0;const O=4*T;for(let F=0;F<f;F++){const Q=w[F],k=C[F],X=L[F],U=E*I*4*F;for(let H=0;H<Q.count;H++){const Z=H*O;y===!0&&(a.fromBufferAttribute(Q,H),Q.normalized===!0&&rc(a,Q),z[U+Z+0]=a.x,z[U+Z+1]=a.y,z[U+Z+2]=a.z,z[U+Z+3]=0),b===!0&&(a.fromBufferAttribute(k,H),k.normalized===!0&&rc(a,k),z[U+Z+4]=a.x,z[U+Z+5]=a.y,z[U+Z+6]=a.z,z[U+Z+7]=0),S===!0&&(a.fromBufferAttribute(X,H),X.normalized===!0&&rc(a,X),z[U+Z+8]=a.x,z[U+Z+9]=a.y,z[U+Z+10]=a.z,z[U+Z+11]=X.itemSize===4?a.w:1)}}g={count:f,texture:B,size:new j(E,I)},r.set(h,g),h.addEventListener("dispose",x)}let _=0;for(let x=0;x<p.length;x++)_+=p[x];const v=h.morphTargetsRelative?1:1-_;u.getUniforms().setValue(s,"morphTargetBaseInfluence",v),u.getUniforms().setValue(s,"morphTargetInfluences",p),u.getUniforms().setValue(s,"morphTargetsTexture",g.texture,e),u.getUniforms().setValue(s,"morphTargetsTextureSize",g.size)}else{const m=p===void 0?0:p.length;let f=i[h.id];if(f===void 0||f.length!==m){f=[];for(let y=0;y<m;y++)f[y]=[y,0];i[h.id]=f}for(let y=0;y<m;y++){const b=f[y];b[0]=y,b[1]=p[y]}f.sort(Tv);for(let y=0;y<8;y++)y<m&&f[y][1]?(o[y][0]=f[y][0],o[y][1]=f[y][1]):(o[y][0]=Number.MAX_SAFE_INTEGER,o[y][1]=0);o.sort(Sv);const g=h.morphAttributes.position,_=h.morphAttributes.normal;let v=0;for(let y=0;y<8;y++){const b=o[y],S=b[0],w=b[1];S!==Number.MAX_SAFE_INTEGER&&w?(g&&h.getAttribute("morphTarget"+y)!==g[S]&&h.setAttribute("morphTarget"+y,g[S]),_&&h.getAttribute("morphNormal"+y)!==_[S]&&h.setAttribute("morphNormal"+y,_[S]),n[y]=w,v+=w):(g&&h.hasAttribute("morphTarget"+y)===!0&&h.deleteAttribute("morphTarget"+y),_&&h.hasAttribute("morphNormal"+y)===!0&&h.deleteAttribute("morphNormal"+y),n[y]=0)}const x=h.morphTargetsRelative?1:1-v;u.getUniforms().setValue(s,"morphTargetBaseInfluence",x),u.getUniforms().setValue(s,"morphTargetInfluences",n)}}}}function Ev(s,t,e,i){let n=new WeakMap;function r(a){const o=a.target;o.removeEventListener("dispose",r),e.remove(o.instanceMatrix),o.instanceColor!==null&&e.remove(o.instanceColor)}return{update:function(a){const o=i.render.frame,l=a.geometry,h=t.get(a,l);return n.get(h)!==o&&(t.update(h),n.set(h,o)),a.isInstancedMesh&&(a.hasEventListener("dispose",r)===!1&&a.addEventListener("dispose",r),e.update(a.instanceMatrix,34962),a.instanceColor!==null&&e.update(a.instanceColor,34962)),h},dispose:function(){n=new WeakMap}}}const yp=new ne,bp=new Kd,Mp=new class extends ne{constructor(s=null,t=1,e=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:s,width:t,height:e,depth:i},this.magFilter=Ft,this.minFilter=Ft,this.wrapR=ue,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}},wp=new tl,Sp=[],Tp=[],Cp=new Float32Array(16),Ep=new Float32Array(9),Ap=new Float32Array(4);function Rr(s,t,e){const i=s[0];if(i<=0||i>0)return s;const n=t*e;let r=Sp[n];if(r===void 0&&(r=new Float32Array(n),Sp[n]=r),t!==0){i.toArray(r,0);for(let a=1,o=0;a!==t;++a)o+=e,s[a].toArray(r,o)}return r}function je(s,t){if(s.length!==t.length)return!1;for(let e=0,i=s.length;e<i;e++)if(s[e]!==t[e])return!1;return!0}function Ge(s,t){for(let e=0,i=t.length;e<i;e++)s[e]=t[e]}function il(s,t){let e=Tp[t];e===void 0&&(e=new Int32Array(t),Tp[t]=e);for(let i=0;i!==t;++i)e[i]=s.allocateTextureUnit();return e}function Av(s,t){const e=this.cache;e[0]!==t&&(s.uniform1f(this.addr,t),e[0]=t)}function Pv(s,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y||(s.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(je(e,t))return;s.uniform2fv(this.addr,t),Ge(e,t)}}function Rv(s,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y&&e[2]===t.z||(s.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)e[0]===t.r&&e[1]===t.g&&e[2]===t.b||(s.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(je(e,t))return;s.uniform3fv(this.addr,t),Ge(e,t)}}function Dv(s,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y&&e[2]===t.z&&e[3]===t.w||(s.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(je(e,t))return;s.uniform4fv(this.addr,t),Ge(e,t)}}function Lv(s,t){const e=this.cache,i=t.elements;if(i===void 0){if(je(e,t))return;s.uniformMatrix2fv(this.addr,!1,t),Ge(e,t)}else{if(je(e,i))return;Ap.set(i),s.uniformMatrix2fv(this.addr,!1,Ap),Ge(e,i)}}function Iv(s,t){const e=this.cache,i=t.elements;if(i===void 0){if(je(e,t))return;s.uniformMatrix3fv(this.addr,!1,t),Ge(e,t)}else{if(je(e,i))return;Ep.set(i),s.uniformMatrix3fv(this.addr,!1,Ep),Ge(e,i)}}function Ov(s,t){const e=this.cache,i=t.elements;if(i===void 0){if(je(e,t))return;s.uniformMatrix4fv(this.addr,!1,t),Ge(e,t)}else{if(je(e,i))return;Cp.set(i),s.uniformMatrix4fv(this.addr,!1,Cp),Ge(e,i)}}function zv(s,t){const e=this.cache;e[0]!==t&&(s.uniform1i(this.addr,t),e[0]=t)}function kv(s,t){const e=this.cache;je(e,t)||(s.uniform2iv(this.addr,t),Ge(e,t))}function Nv(s,t){const e=this.cache;je(e,t)||(s.uniform3iv(this.addr,t),Ge(e,t))}function Uv(s,t){const e=this.cache;je(e,t)||(s.uniform4iv(this.addr,t),Ge(e,t))}function Fv(s,t){const e=this.cache;e[0]!==t&&(s.uniform1ui(this.addr,t),e[0]=t)}function Bv(s,t){const e=this.cache;je(e,t)||(s.uniform2uiv(this.addr,t),Ge(e,t))}function Vv(s,t){const e=this.cache;je(e,t)||(s.uniform3uiv(this.addr,t),Ge(e,t))}function Hv(s,t){const e=this.cache;je(e,t)||(s.uniform4uiv(this.addr,t),Ge(e,t))}function jv(s,t,e){const i=this.cache,n=e.allocateTextureUnit();i[0]!==n&&(s.uniform1i(this.addr,n),i[0]=n),e.setTexture2D(t||yp,n)}function Gv(s,t,e){const i=this.cache,n=e.allocateTextureUnit();i[0]!==n&&(s.uniform1i(this.addr,n),i[0]=n),e.setTexture3D(t||Mp,n)}function Wv(s,t,e){const i=this.cache,n=e.allocateTextureUnit();i[0]!==n&&(s.uniform1i(this.addr,n),i[0]=n),e.setTextureCube(t||wp,n)}function Xv(s,t,e){const i=this.cache,n=e.allocateTextureUnit();i[0]!==n&&(s.uniform1i(this.addr,n),i[0]=n),e.setTexture2DArray(t||bp,n)}function qv(s,t){s.uniform1fv(this.addr,t)}function Yv(s,t){const e=Rr(t,this.size,2);s.uniform2fv(this.addr,e)}function Zv(s,t){const e=Rr(t,this.size,3);s.uniform3fv(this.addr,e)}function Jv(s,t){const e=Rr(t,this.size,4);s.uniform4fv(this.addr,e)}function Kv(s,t){const e=Rr(t,this.size,4);s.uniformMatrix2fv(this.addr,!1,e)}function Qv(s,t){const e=Rr(t,this.size,9);s.uniformMatrix3fv(this.addr,!1,e)}function $v(s,t){const e=Rr(t,this.size,16);s.uniformMatrix4fv(this.addr,!1,e)}function tx(s,t){s.uniform1iv(this.addr,t)}function ex(s,t){s.uniform2iv(this.addr,t)}function ix(s,t){s.uniform3iv(this.addr,t)}function nx(s,t){s.uniform4iv(this.addr,t)}function sx(s,t){s.uniform1uiv(this.addr,t)}function rx(s,t){s.uniform2uiv(this.addr,t)}function ax(s,t){s.uniform3uiv(this.addr,t)}function ox(s,t){s.uniform4uiv(this.addr,t)}function lx(s,t,e){const i=t.length,n=il(e,i);s.uniform1iv(this.addr,n);for(let r=0;r!==i;++r)e.setTexture2D(t[r]||yp,n[r])}function hx(s,t,e){const i=t.length,n=il(e,i);s.uniform1iv(this.addr,n);for(let r=0;r!==i;++r)e.setTexture3D(t[r]||Mp,n[r])}function cx(s,t,e){const i=t.length,n=il(e,i);s.uniform1iv(this.addr,n);for(let r=0;r!==i;++r)e.setTextureCube(t[r]||wp,n[r])}function ux(s,t,e){const i=t.length,n=il(e,i);s.uniform1iv(this.addr,n);for(let r=0;r!==i;++r)e.setTexture2DArray(t[r]||bp,n[r])}class dx{constructor(t,e,i){this.id=t,this.addr=i,this.cache=[],this.setValue=function(n){switch(n){case 5126:return Av;case 35664:return Pv;case 35665:return Rv;case 35666:return Dv;case 35674:return Lv;case 35675:return Iv;case 35676:return Ov;case 5124:case 35670:return zv;case 35667:case 35671:return kv;case 35668:case 35672:return Nv;case 35669:case 35673:return Uv;case 5125:return Fv;case 36294:return Bv;case 36295:return Vv;case 36296:return Hv;case 35678:case 36198:case 36298:case 36306:case 35682:return jv;case 35679:case 36299:case 36307:return Gv;case 35680:case 36300:case 36308:case 36293:return Wv;case 36289:case 36303:case 36311:case 36292:return Xv}}(e.type)}}class px{constructor(t,e,i){this.id=t,this.addr=i,this.cache=[],this.size=e.size,this.setValue=function(n){switch(n){case 5126:return qv;case 35664:return Yv;case 35665:return Zv;case 35666:return Jv;case 35674:return Kv;case 35675:return Qv;case 35676:return $v;case 5124:case 35670:return tx;case 35667:case 35671:return ex;case 35668:case 35672:return ix;case 35669:case 35673:return nx;case 5125:return sx;case 36294:return rx;case 36295:return ax;case 36296:return ox;case 35678:case 36198:case 36298:case 36306:case 35682:return lx;case 35679:case 36299:case 36307:return hx;case 35680:case 36300:case 36308:case 36293:return cx;case 36289:case 36303:case 36311:case 36292:return ux}}(e.type)}}class mx{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,i){const n=this.seq;for(let r=0,a=n.length;r!==a;++r){const o=n[r];o.setValue(t,e[o.id],i)}}}const ac=/(\w+)(\])?(\[|\.)?/g;function Pp(s,t){s.seq.push(t),s.map[t.id]=t}function fx(s,t,e){const i=s.name,n=i.length;for(ac.lastIndex=0;;){const r=ac.exec(i),a=ac.lastIndex;let o=r[1];const l=r[2]==="]",h=r[3];if(l&&(o|=0),h===void 0||h==="["&&a+2===n){Pp(e,h===void 0?new dx(o,s,t):new px(o,s,t));break}{let c=e.map[o];c===void 0&&(c=new mx(o),Pp(e,c)),e=c}}}class nl{constructor(t,e){this.seq=[],this.map={};const i=t.getProgramParameter(e,35718);for(let n=0;n<i;++n){const r=t.getActiveUniform(e,n);fx(r,t.getUniformLocation(e,r.name),this)}}setValue(t,e,i,n){const r=this.map[e];r!==void 0&&r.setValue(t,i,n)}setOptional(t,e,i){const n=e[i];n!==void 0&&this.setValue(t,i,n)}static upload(t,e,i,n){for(let r=0,a=e.length;r!==a;++r){const o=e[r],l=i[o.id];l.needsUpdate!==!1&&o.setValue(t,l.value,n)}}static seqWithValue(t,e){const i=[];for(let n=0,r=t.length;n!==r;++n){const a=t[n];a.id in e&&i.push(a)}return i}}function Rp(s,t,e){const i=s.createShader(t);return s.shaderSource(i,e),s.compileShader(i),i}let gx=0;function Dp(s,t,e){const i=s.getShaderParameter(t,35713),n=s.getShaderInfoLog(t).trim();if(i&&n==="")return"";const r=/ERROR: 0:(\d+)/.exec(n);if(r){const a=parseInt(r[1]);return e.toUpperCase()+`

`+n+`

`+function(o,l){const h=o.split(`
`),c=[],u=Math.max(l-6,0),p=Math.min(l+6,h.length);for(let m=u;m<p;m++){const f=m+1;c.push(`${f===l?">":" "} ${f}: ${h[m]}`)}return c.join(`
`)}(s.getShaderSource(t),a)}return n}function _x(s,t){const e=function(i){switch(i){case un:return["Linear","( value )"];case Bt:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}(t);return"vec4 "+s+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function vx(s,t){let e;switch(t){case P0:e="Linear";break;case yd:e="Reinhard";break;case R0:e="OptimizedCineon";break;case D0:e="ACESFilmic";break;case L0:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+s+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function Oa(s){return s!==""}function Lp(s,t){return s.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Ip(s,t){return s.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const xx=/^[ \t]*#include +<([\w\d./]+)>/gm;function oc(s){return s.replace(xx,yx)}function yx(s,t){const e=dt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return oc(e)}const bx=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Mx=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Op(s){return s.replace(Mx,zp).replace(bx,wx)}function wx(s,t,e,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),zp(s,t,e,i)}function zp(s,t,e,i){let n="";for(let r=parseInt(t);r<parseInt(e);r++)n+=i.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return n}function kp(s){let t="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?t+=`
#define HIGH_PRECISION`:s.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Sx(s,t,e,i){const n=s.getContext(),r=e.defines;let a=e.vertexShader,o=e.fragmentShader;const l=function(T){let E="SHADOWMAP_TYPE_BASIC";return T.shadowMapType===ud?E="SHADOWMAP_TYPE_PCF":T.shadowMapType===c0?E="SHADOWMAP_TYPE_PCF_SOFT":T.shadowMapType===va&&(E="SHADOWMAP_TYPE_VSM"),E}(e),h=function(T){let E="ENVMAP_TYPE_CUBE";if(T.envMap)switch(T.envMapMode){case lr:case hr:E="ENVMAP_TYPE_CUBE";break;case xs:E="ENVMAP_TYPE_CUBE_UV"}return E}(e),c=function(T){let E="ENVMAP_MODE_REFLECTION";return T.envMap&&T.envMapMode===hr&&(E="ENVMAP_MODE_REFRACTION"),E}(e),u=function(T){let E="ENVMAP_BLENDING_NONE";if(T.envMap)switch(T.combine){case Ro:E="ENVMAP_BLENDING_MULTIPLY";break;case E0:E="ENVMAP_BLENDING_MIX";break;case A0:E="ENVMAP_BLENDING_ADD"}return E}(e),p=function(T){const E=T.envMapCubeUVHeight;if(E===null)return null;const I=Math.log2(E)-2,z=1/E;return{texelWidth:1/(3*Math.max(Math.pow(2,I),112)),texelHeight:z,maxMip:I}}(e),m=e.isWebGL2?"":function(T){return[T.extensionDerivatives||T.envMapCubeUVHeight||T.bumpMap||T.tangentSpaceNormalMap||T.clearcoatNormalMap||T.flatShading||T.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(T.extensionFragDepth||T.logarithmicDepthBuffer)&&T.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",T.extensionDrawBuffers&&T.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(T.extensionShaderTextureLOD||T.envMap||T.transmission)&&T.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Oa).join(`
`)}(e),f=function(T){const E=[];for(const I in T){const z=T[I];z!==!1&&E.push("#define "+I+" "+z)}return E.join(`
`)}(r),g=n.createProgram();let _,v,x=e.glslVersion?"#version "+e.glslVersion+`
`:"";if(e.isRawShaderMaterial?(_=[f].filter(Oa).join(`
`),_.length>0&&(_+=`
`),v=[m,f].filter(Oa).join(`
`),v.length>0&&(v+=`
`)):(_=[kp(e),"#define SHADER_NAME "+e.shaderName,f,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors&&e.isWebGL2?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Oa).join(`
`),v=[m,kp(e),"#define SHADER_NAME "+e.shaderName,f,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.envMap?"#define "+c:"",e.envMap?"#define "+u:"",p?"#define CUBEUV_TEXEL_WIDTH "+p.texelWidth:"",p?"#define CUBEUV_TEXEL_HEIGHT "+p.texelHeight:"",p?"#define CUBEUV_MAX_MIP "+p.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==cn?"#define TONE_MAPPING":"",e.toneMapping!==cn?dt.tonemapping_pars_fragment:"",e.toneMapping!==cn?vx("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",dt.encodings_pars_fragment,_x("linearToOutputTexel",e.outputEncoding),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Oa).join(`
`)),s.onShaderBeforeResolve){const T=s.onShaderBeforeResolve(a,o,e);a=T.vertexShader,o=T.fragmentShader}a=oc(a),a=Lp(a,e),a=Ip(a,e),o=oc(o),o=Lp(o,e),o=Ip(o,e),a=Op(a),o=Op(o),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(x=`#version 300 es
`,_=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+_,v=["#define varying in",e.glslVersion===Rh?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Rh?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+v);let y=x+_+a,b=x+v+o;if(s.onShaderBeforeCompile){const T=s.onShaderBeforeCompile(y,b,e);y=T.vertexShader,b=T.fragmentShader}const S=Rp(n,35633,y),w=Rp(n,35632,b);if(n.attachShader(g,S),n.attachShader(g,w),e.index0AttributeName!==void 0?n.bindAttribLocation(g,0,e.index0AttributeName):e.morphTargets===!0&&n.bindAttribLocation(g,0,"position"),n.linkProgram(g),s.debug.checkShaderErrors){const T=n.getProgramInfoLog(g).trim(),E=n.getShaderInfoLog(S).trim(),I=n.getShaderInfoLog(w).trim();let z=!0,B=!0;if(n.getProgramParameter(g,35714)===!1){z=!1;const O=Dp(n,S,"vertex"),F=Dp(n,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+n.getError()+" - VALIDATE_STATUS "+n.getProgramParameter(g,35715)+`

Program Info Log: `+T+`
`+O+`
`+F)}else T!==""?console.warn("THREE.WebGLProgram: Program Info Log:",T):E!==""&&I!==""||(B=!1);B&&(this.diagnostics={runnable:z,programLog:T,vertexShader:{log:E,prefix:_},fragmentShader:{log:I,prefix:v}})}let C,L;return n.deleteShader(S),n.deleteShader(w),this.getUniforms=function(){return C===void 0&&(C=new nl(n,g)),C},this.getAttributes=function(){return L===void 0&&(L=function(T,E){const I={},z=T.getProgramParameter(E,35721);for(let B=0;B<z;B++){const O=T.getActiveAttrib(E,B),F=O.name;let Q=1;O.type===35674&&(Q=2),O.type===35675&&(Q=3),O.type===35676&&(Q=4),I[F]={type:O.type,location:T.getAttribLocation(E,F),locationSize:Q}}return I}(n,g)),L},this.destroy=function(){i.releaseStatesOfProgram(this),n.deleteProgram(g),this.program=void 0},this.name=e.shaderName,this.id=gx++,this.cacheKey=t,this.usedTimes=1,this.program=g,this.vertexShader=S,this.fragmentShader=w,this}let Tx=0;class Cx{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,i=t.fragmentShader,n=this._getShaderStage(e),r=this._getShaderStage(i),a=this._getShaderCacheForMaterial(t);return a.has(n)===!1&&(a.add(n),n.usedTimes++),a.has(r)===!1&&(a.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const i of e)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return e.has(t)===!1&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(e.has(t)===!1){const i=new Ex(t);e.set(t,i)}return e.get(t)}}class Ex{constructor(t){this.id=Tx++,this.code=t,this.usedTimes=0}}function Ax(s,t,e,i,n,r,a){const o=new Gh,l=new Cx,h=[],c=n.isWebGL2,u=n.logarithmicDepthBuffer,p=n.vertexTextures;let m=n.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(g,_,v,x,y){const b=x.fog,S=y.geometry,w=g.isMeshStandardMaterial?x.environment:null,C=(g.isMeshStandardMaterial?e:t).get(g.envMap||w),L=C&&C.mapping===xs?C.image.height:null,T=f[g.type];g.precision!==null&&(m=n.getMaxPrecision(g.precision),m!==g.precision&&console.warn("THREE.WebGLProgram.getParameters:",g.precision,"not supported, using",m,"instead."));const E=S.morphAttributes.position||S.morphAttributes.normal||S.morphAttributes.color,I=E!==void 0?E.length:0;let z,B,O,F,Q=0;if(S.morphAttributes.position!==void 0&&(Q=1),S.morphAttributes.normal!==void 0&&(Q=2),S.morphAttributes.color!==void 0&&(Q=3),T){const Z=oi[T];z=Z.vertexShader,B=Z.fragmentShader}else z=g.vertexShader,B=g.fragmentShader,l.update(g),O=l.getVertexShaderID(g),F=l.getFragmentShaderID(g);const k=s.getRenderTarget(),X=g.alphaTest>0,U=g.clearcoat>0,H=g.iridescence>0;return{isWebGL2:c,shaderID:T,shaderName:g.type,vertexShader:z,fragmentShader:B,defines:g.defines,customVertexShaderID:O,customFragmentShaderID:F,isRawShaderMaterial:g.isRawShaderMaterial===!0,glslVersion:g.glslVersion,precision:m,instancing:y.isInstancedMesh===!0,instancingColor:y.isInstancedMesh===!0&&y.instanceColor!==null,supportsVertexTextures:p,outputEncoding:k===null?s.outputEncoding:k.isXRRenderTarget===!0?k.texture.encoding:un,map:!!g.map,matcap:!!g.matcap,envMap:!!C,envMapMode:C&&C.mapping,envMapCubeUVHeight:L,lightMap:!!g.lightMap,aoMap:!!g.aoMap,emissiveMap:!!g.emissiveMap,bumpMap:!!g.bumpMap,normalMap:!!g.normalMap,objectSpaceNormalMap:g.normalMapType===J0,tangentSpaceNormalMap:g.normalMapType===Hn,decodeVideoTexture:!!g.map&&g.map.isVideoTexture===!0&&g.map.encoding===Bt,clearcoat:U,clearcoatMap:U&&!!g.clearcoatMap,clearcoatRoughnessMap:U&&!!g.clearcoatRoughnessMap,clearcoatNormalMap:U&&!!g.clearcoatNormalMap,iridescence:H,iridescenceMap:H&&!!g.iridescenceMap,iridescenceThicknessMap:H&&!!g.iridescenceThicknessMap,displacementMap:!!g.displacementMap,roughnessMap:!!g.roughnessMap,metalnessMap:!!g.metalnessMap,specularMap:!!g.specularMap,specularIntensityMap:!!g.specularIntensityMap,specularColorMap:!!g.specularColorMap,opaque:g.transparent===!1&&g.blending===ar,alphaMap:!!g.alphaMap,alphaTest:X,gradientMap:!!g.gradientMap,sheen:g.sheen>0,sheenColorMap:!!g.sheenColorMap,sheenRoughnessMap:!!g.sheenRoughnessMap,transmission:g.transmission>0,transmissionMap:!!g.transmissionMap,thicknessMap:!!g.thicknessMap,combine:g.combine,vertexTangents:!!g.normalMap&&!!S.attributes.tangent,vertexColors:g.vertexColors,vertexAlphas:g.vertexColors===!0&&!!S.attributes.color&&S.attributes.color.itemSize===4,vertexUvs:!!(g.map||g.bumpMap||g.normalMap||g.specularMap||g.alphaMap||g.emissiveMap||g.roughnessMap||g.metalnessMap||g.clearcoatMap||g.clearcoatRoughnessMap||g.clearcoatNormalMap||g.iridescenceMap||g.iridescenceThicknessMap||g.displacementMap||g.transmissionMap||g.thicknessMap||g.specularIntensityMap||g.specularColorMap||g.sheenColorMap||g.sheenRoughnessMap),uvsVertexOnly:!(g.map||g.bumpMap||g.normalMap||g.specularMap||g.alphaMap||g.emissiveMap||g.roughnessMap||g.metalnessMap||g.clearcoatNormalMap||g.iridescenceMap||g.iridescenceThicknessMap||g.transmission>0||g.transmissionMap||g.thicknessMap||g.specularIntensityMap||g.specularColorMap||g.sheen>0||g.sheenColorMap||g.sheenRoughnessMap||!g.displacementMap),fog:!!b,useFog:g.fog===!0,fogExp2:b&&b.isFogExp2,flatShading:!!g.flatShading,sizeAttenuation:g.sizeAttenuation,logarithmicDepthBuffer:u,skinning:y.isSkinnedMesh===!0,morphTargets:S.morphAttributes.position!==void 0,morphNormals:S.morphAttributes.normal!==void 0,morphColors:S.morphAttributes.color!==void 0,morphTargetsCount:I,morphTextureStride:Q,numDirLights:_.directional.length,numPointLights:_.point.length,numSpotLights:_.spot.length,numRectAreaLights:_.rectArea.length,numHemiLights:_.hemi.length,numDirLightShadows:_.directionalShadowMap.length,numPointLightShadows:_.pointShadowMap.length,numSpotLightShadows:_.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:g.dithering,shadowMapEnabled:s.shadowMap.enabled&&v.length>0,shadowMapType:s.shadowMap.type,toneMapping:g.toneMapped?s.toneMapping:cn,physicallyCorrectLights:s.physicallyCorrectLights,premultipliedAlpha:g.premultipliedAlpha,doubleSided:g.side===ce,flipSided:g.side===pi,useDepthPacking:!!g.depthPacking,depthPacking:g.depthPacking||0,index0AttributeName:g.index0AttributeName,extensionDerivatives:g.extensions&&g.extensions.derivatives,extensionFragDepth:g.extensions&&g.extensions.fragDepth,extensionDrawBuffers:g.extensions&&g.extensions.drawBuffers,extensionShaderTextureLOD:g.extensions&&g.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||i.has("EXT_shader_texture_lod"),customProgramCacheKey:g.customProgramCacheKey(),extraProgramCacheKey:s.extraProgramCacheKey}},getProgramCacheKey:function(g){const _=[];if(g.shaderID?_.push(g.shaderID):(_.push(g.customVertexShaderID),_.push(g.customFragmentShaderID)),g.defines!==void 0)for(const v in g.defines)_.push(v),_.push(g.defines[v]);return g.isRawShaderMaterial===!1&&(function(v,x){v.push(x.precision),v.push(x.outputEncoding),v.push(x.envMapMode),v.push(x.envMapCubeUVHeight),v.push(x.combine),v.push(x.vertexUvs),v.push(x.fogExp2),v.push(x.sizeAttenuation),v.push(x.morphTargetsCount),v.push(x.morphAttributeCount),v.push(x.numDirLights),v.push(x.numPointLights),v.push(x.numSpotLights),v.push(x.numHemiLights),v.push(x.numRectAreaLights),v.push(x.numDirLightShadows),v.push(x.numPointLightShadows),v.push(x.numSpotLightShadows),v.push(x.shadowMapType),v.push(x.toneMapping),v.push(x.numClippingPlanes),v.push(x.numClipIntersection),v.push(x.depthPacking)}(_,g),function(v,x){o.disableAll(),x.isWebGL2&&o.enable(0),x.supportsVertexTextures&&o.enable(1),x.instancing&&o.enable(2),x.instancingColor&&o.enable(3),x.map&&o.enable(4),x.matcap&&o.enable(5),x.envMap&&o.enable(6),x.lightMap&&o.enable(7),x.aoMap&&o.enable(8),x.emissiveMap&&o.enable(9),x.bumpMap&&o.enable(10),x.normalMap&&o.enable(11),x.objectSpaceNormalMap&&o.enable(12),x.tangentSpaceNormalMap&&o.enable(13),x.clearcoat&&o.enable(14),x.clearcoatMap&&o.enable(15),x.clearcoatRoughnessMap&&o.enable(16),x.clearcoatNormalMap&&o.enable(17),x.iridescence&&o.enable(18),x.iridescenceMap&&o.enable(19),x.iridescenceThicknessMap&&o.enable(20),x.displacementMap&&o.enable(21),x.specularMap&&o.enable(22),x.roughnessMap&&o.enable(23),x.metalnessMap&&o.enable(24),x.gradientMap&&o.enable(25),x.alphaMap&&o.enable(26),x.alphaTest&&o.enable(27),x.vertexColors&&o.enable(28),x.vertexAlphas&&o.enable(29),x.vertexUvs&&o.enable(30),x.vertexTangents&&o.enable(31),x.uvsVertexOnly&&o.enable(32),x.fog&&o.enable(33),v.push(o.mask),o.disableAll(),x.useFog&&o.enable(0),x.flatShading&&o.enable(1),x.logarithmicDepthBuffer&&o.enable(2),x.skinning&&o.enable(3),x.morphTargets&&o.enable(4),x.morphNormals&&o.enable(5),x.morphColors&&o.enable(6),x.premultipliedAlpha&&o.enable(7),x.shadowMapEnabled&&o.enable(8),x.physicallyCorrectLights&&o.enable(9),x.doubleSided&&o.enable(10),x.flipSided&&o.enable(11),x.useDepthPacking&&o.enable(12),x.dithering&&o.enable(13),x.specularIntensityMap&&o.enable(14),x.specularColorMap&&o.enable(15),x.transmission&&o.enable(16),x.transmissionMap&&o.enable(17),x.thicknessMap&&o.enable(18),x.sheen&&o.enable(19),x.sheenColorMap&&o.enable(20),x.sheenRoughnessMap&&o.enable(21),x.decodeVideoTexture&&o.enable(22),x.opaque&&o.enable(23),v.push(o.mask)}(_,g),_.push(s.outputEncoding)),_.push(g.customProgramCacheKey),s.extraProgramCacheKey&&_.push(s.extraProgramCacheKey),_.join()},getUniforms:function(g){const _=f[g.type];let v;if(_){const x=oi[_];v=pt.clone(x.uniforms)}else v=g.uniforms;return v},acquireProgram:function(g,_){let v;for(let x=0,y=h.length;x<y;x++){const b=h[x];if(b.cacheKey===_){v=b,++v.usedTimes;break}}return v===void 0&&(v=new Sx(s,_,g,r),h.push(v)),v},releaseProgram:function(g){if(--g.usedTimes==0){const _=h.indexOf(g);h[_]=h[h.length-1],h.pop(),g.destroy()}},releaseShaderCache:function(g){l.remove(g)},programs:h,dispose:function(){l.dispose()}}}function Px(){let s=new WeakMap;return{get:function(t){let e=s.get(t);return e===void 0&&(e={},s.set(t,e)),e},remove:function(t){s.delete(t)},update:function(t,e,i){s.get(t)[e]=i},dispose:function(){s=new WeakMap}}}function Rx(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.material.id!==t.material.id?s.material.id-t.material.id:s.z!==t.z?s.z-t.z:s.id-t.id}function Np(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.z!==t.z?t.z-s.z:s.id-t.id}function Up(){const s=[];let t=0;const e=[],i=[],n=[];function r(a,o,l,h,c,u){let p=s[t];return p===void 0?(p={id:a.id,object:a,geometry:o,material:l,groupOrder:h,renderOrder:a.renderOrder,z:c,group:u},s[t]=p):(p.id=a.id,p.object=a,p.geometry=o,p.material=l,p.groupOrder=h,p.renderOrder=a.renderOrder,p.z=c,p.group=u),t++,p}return{opaque:e,transmissive:i,transparent:n,init:function(){t=0,e.length=0,i.length=0,n.length=0},push:function(a,o,l,h,c,u){const p=r(a,o,l,h,c,u);l.transmission>0?i.push(p):l.transparent===!0?n.push(p):e.push(p)},unshift:function(a,o,l,h,c,u){const p=r(a,o,l,h,c,u);l.transmission>0?i.unshift(p):l.transparent===!0?n.unshift(p):e.unshift(p)},finish:function(){for(let a=t,o=s.length;a<o;a++){const l=s[a];if(l.id===null)break;l.id=null,l.object=null,l.geometry=null,l.material=null,l.group=null}},sort:function(a,o){e.length>1&&e.sort(a||Rx),i.length>1&&i.sort(o||Np),n.length>1&&n.sort(o||Np)}}}function Dx(){let s=new WeakMap;return{get:function(t,e){let i;return s.has(t)===!1?(i=new Up,s.set(t,[i])):e>=s.get(t).length?(i=new Up,s.get(t).push(i)):i=s.get(t)[e],i},dispose:function(){s=new WeakMap}}}function Lx(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new M,color:new tt};break;case"SpotLight":e={position:new M,direction:new M,color:new tt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new M,color:new tt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new M,skyColor:new tt,groundColor:new tt};break;case"RectAreaLight":e={color:new tt,position:new M,halfWidth:new M,halfHeight:new M}}return s[t.id]=e,e}}}let Ix=0;function Ox(s,t){return(t.castShadow?1:0)-(s.castShadow?1:0)}function zx(s,t){const e=new Lx,i=function(){const l={};return{get:function(h){if(l[h.id]!==void 0)return l[h.id];let c;switch(h.type){case"DirectionalLight":case"SpotLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new j};break;case"PointLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new j,shadowCameraNear:1,shadowCameraFar:1e3}}return l[h.id]=c,c}}}(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let l=0;l<9;l++)n.probe.push(new M);const r=new M,a=new rt,o=new rt;return{setup:function(l,h){let c=0,u=0,p=0;for(let C=0;C<9;C++)n.probe[C].set(0,0,0);let m=0,f=0,g=0,_=0,v=0,x=0,y=0,b=0;l.sort(Ox);const S=h!==!0?Math.PI:1;for(let C=0,L=l.length;C<L;C++){const T=l[C],E=T.color,I=T.intensity,z=T.distance,B=T.shadow&&T.shadow.map?T.shadow.map.texture:null;if(T.isAmbientLight)c+=E.r*I*S,u+=E.g*I*S,p+=E.b*I*S;else if(T.isLightProbe)for(let O=0;O<9;O++)n.probe[O].addScaledVector(T.sh.coefficients[O],I);else if(T.isDirectionalLight){const O=e.get(T);if(O.color.copy(T.color).multiplyScalar(T.intensity*S),T.castShadow){const F=T.shadow,Q=i.get(T);Q.shadowBias=F.bias,Q.shadowNormalBias=F.normalBias,Q.shadowRadius=F.radius,Q.shadowMapSize=F.mapSize,n.directionalShadow[m]=Q,n.directionalShadowMap[m]=B,n.directionalShadowMatrix[m]=T.shadow.matrix,x++}n.directional[m]=O,m++}else if(T.isSpotLight){const O=e.get(T);if(O.position.setFromMatrixPosition(T.matrixWorld),O.color.copy(E).multiplyScalar(I*S),O.distance=z,O.coneCos=Math.cos(T.angle),O.penumbraCos=Math.cos(T.angle*(1-T.penumbra)),O.decay=T.decay,T.castShadow){const F=T.shadow,Q=i.get(T);Q.shadowBias=F.bias,Q.shadowNormalBias=F.normalBias,Q.shadowRadius=F.radius,Q.shadowMapSize=F.mapSize,n.spotShadow[g]=Q,n.spotShadowMap[g]=B,n.spotShadowMatrix[g]=T.shadow.matrix,b++}n.spot[g]=O,g++}else if(T.isRectAreaLight){const O=e.get(T);O.color.copy(E).multiplyScalar(I),O.halfWidth.set(.5*T.width,0,0),O.halfHeight.set(0,.5*T.height,0),n.rectArea[_]=O,_++}else if(T.isPointLight){const O=e.get(T);if(O.color.copy(T.color).multiplyScalar(T.intensity*S),O.distance=T.distance,O.decay=T.decay,T.castShadow){const F=T.shadow,Q=i.get(T);Q.shadowBias=F.bias,Q.shadowNormalBias=F.normalBias,Q.shadowRadius=F.radius,Q.shadowMapSize=F.mapSize,Q.shadowCameraNear=F.camera.near,Q.shadowCameraFar=F.camera.far,n.pointShadow[f]=Q,n.pointShadowMap[f]=B,n.pointShadowMatrix[f]=T.shadow.matrix,y++}n.point[f]=O,f++}else if(T.isHemisphereLight){const O=e.get(T);O.skyColor.copy(T.color).multiplyScalar(I*S),O.groundColor.copy(T.groundColor).multiplyScalar(I*S),n.hemi[v]=O,v++}}_>0&&(t.isWebGL2||s.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=ot.LTC_FLOAT_1,n.rectAreaLTC2=ot.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(n.rectAreaLTC1=ot.LTC_HALF_1,n.rectAreaLTC2=ot.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),n.ambient[0]=c,n.ambient[1]=u,n.ambient[2]=p;const w=n.hash;w.directionalLength===m&&w.pointLength===f&&w.spotLength===g&&w.rectAreaLength===_&&w.hemiLength===v&&w.numDirectionalShadows===x&&w.numPointShadows===y&&w.numSpotShadows===b||(n.directional.length=m,n.spot.length=g,n.rectArea.length=_,n.point.length=f,n.hemi.length=v,n.directionalShadow.length=x,n.directionalShadowMap.length=x,n.pointShadow.length=y,n.pointShadowMap.length=y,n.spotShadow.length=b,n.spotShadowMap.length=b,n.directionalShadowMatrix.length=x,n.pointShadowMatrix.length=y,n.spotShadowMatrix.length=b,w.directionalLength=m,w.pointLength=f,w.spotLength=g,w.rectAreaLength=_,w.hemiLength=v,w.numDirectionalShadows=x,w.numPointShadows=y,w.numSpotShadows=b,n.version=Ix++)},setupView:function(l,h){let c=0,u=0,p=0,m=0,f=0;const g=h.matrixWorldInverse;for(let _=0,v=l.length;_<v;_++){const x=l[_];if(x.isDirectionalLight){const y=n.directional[c];y.direction.setFromMatrixPosition(x.matrixWorld),r.setFromMatrixPosition(x.target.matrixWorld),y.direction.sub(r),y.direction.transformDirection(g),c++}else if(x.isSpotLight){const y=n.spot[p];y.position.setFromMatrixPosition(x.matrixWorld),y.position.applyMatrix4(g),y.direction.setFromMatrixPosition(x.matrixWorld),r.setFromMatrixPosition(x.target.matrixWorld),y.direction.sub(r),y.direction.transformDirection(g),p++}else if(x.isRectAreaLight){const y=n.rectArea[m];y.position.setFromMatrixPosition(x.matrixWorld),y.position.applyMatrix4(g),o.identity(),a.copy(x.matrixWorld),a.premultiply(g),o.extractRotation(a),y.halfWidth.set(.5*x.width,0,0),y.halfHeight.set(0,.5*x.height,0),y.halfWidth.applyMatrix4(o),y.halfHeight.applyMatrix4(o),m++}else if(x.isPointLight){const y=n.point[u];y.position.setFromMatrixPosition(x.matrixWorld),y.position.applyMatrix4(g),u++}else if(x.isHemisphereLight){const y=n.hemi[f];y.direction.setFromMatrixPosition(x.matrixWorld),y.direction.transformDirection(g),f++}}},state:n}}function Fp(s,t){const e=new zx(s,t),i=[],n=[];return{init:function(){i.length=0,n.length=0},state:{lightsArray:i,shadowsArray:n,lights:e},setupLights:function(r){e.setup(i,r)},setupLightsView:function(r){e.setupView(i,r)},pushLight:function(r){i.push(r)},pushShadow:function(r){n.push(r)}}}function kx(s,t){let e=new WeakMap;return{get:function(i,n=0){let r;return e.has(i)===!1?(r=new Fp(s,t),e.set(i,[r])):n>=e.get(i).length?(r=new Fp(s,t),e.get(i).push(r)):r=e.get(i)[n],r},dispose:function(){e=new WeakMap}}}class Bp extends ve{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Vp extends ve{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new M,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}const Nx=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Ux=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Fx(s,t,e){let i=new Pa;const n=new j,r=new j,a=new Lt,o=new Bp({depthPacking:Z0}),l=new Vp,h={},c=e.maxTextureSize,u={0:pi,1:Fn,2:ce},p=new Zt({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new j},radius:{value:4}},vertexShader:Nx,fragmentShader:Ux}),m=p.clone();m.defines.HORIZONTAL_PASS=1;const f=new Pt;f.setAttribute("position",new se(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new lt(f,p),_=this;function v(b,S){const w=t.update(g);p.defines.VSM_SAMPLES!==b.blurSamples&&(p.defines.VSM_SAMPLES=b.blurSamples,m.defines.VSM_SAMPLES=b.blurSamples,p.needsUpdate=!0,m.needsUpdate=!0),p.uniforms.shadow_pass.value=b.map.texture,p.uniforms.resolution.value=b.mapSize,p.uniforms.radius.value=b.radius,s.setRenderTarget(b.mapPass),s.clear(),s.renderBufferDirect(S,null,w,p,g,null),m.uniforms.shadow_pass.value=b.mapPass.texture,m.uniforms.resolution.value=b.mapSize,m.uniforms.radius.value=b.radius,s.setRenderTarget(b.map),s.clear(),s.renderBufferDirect(S,null,w,m,g,null)}function x(b,S,w,C,L,T){let E=null;const I=w.isPointLight===!0?b.customDistanceMaterial:b.customDepthMaterial;if(E=I!==void 0?I:w.isPointLight===!0?l:o,s.localClippingEnabled&&S.clipShadows===!0&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0){const z=E.uuid,B=S.uuid;let O=h[z];O===void 0&&(O={},h[z]=O);let F=O[B];F===void 0&&(F=E.clone(),O[B]=F),E=F}return E.visible=S.visible,E.wireframe=S.wireframe,E.side=T===va?S.shadowSide!==null?S.shadowSide:S.side:S.shadowSide!==null?S.shadowSide:u[S.side],E.alphaMap=S.alphaMap,E.alphaTest=S.alphaTest,E.clipShadows=S.clipShadows,E.clippingPlanes=S.clippingPlanes,E.clipIntersection=S.clipIntersection,E.displacementMap=S.displacementMap,E.displacementScale=S.displacementScale,E.displacementBias=S.displacementBias,E.wireframeLinewidth=S.wireframeLinewidth,E.linewidth=S.linewidth,w.isPointLight===!0&&E.isMeshDistanceMaterial===!0&&(E.referencePosition.setFromMatrixPosition(w.matrixWorld),E.nearDistance=C,E.farDistance=L),E}function y(b,S,w,C,L){if(b.visible===!1)return;if(b.layers.test(S.layers)&&(b.isMesh||b.isLine||b.isPoints)&&(b.castShadow||b.receiveShadow&&L===va)&&(!b.frustumCulled||i.intersectsObject(b))){b.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse,b.matrixWorld);const E=t.update(b),I=b.material;if(Array.isArray(I)){const z=E.groups;for(let B=0,O=z.length;B<O;B++){const F=z[B],Q=I[F.materialIndex];if(Q&&Q.visible){const k=x(b,Q,C,w.near,w.far,L);s.renderBufferDirect(w,null,E,k,b,F)}}}else if(I.visible){const z=x(b,I,C,w.near,w.far,L);s.renderBufferDirect(w,null,E,z,b,null)}}const T=b.children;for(let E=0,I=T.length;E<I;E++)y(T[E],S,w,C,L)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ud,this.render=function(b,S,w){if(_.enabled===!1||_.autoUpdate===!1&&_.needsUpdate===!1||b.length===0)return;const C=s.getRenderTarget(),L=s.getActiveCubeFace(),T=s.getActiveMipmapLevel(),E=s.state;E.setBlending(Bn),E.buffers.color.setClear(1,1,1,1),E.buffers.depth.setTest(!0),E.setScissorTest(!1);for(let I=0,z=b.length;I<z;I++){const B=b[I],O=B.shadow;if(O===void 0){console.warn("THREE.WebGLShadowMap:",B,"has no shadow.");continue}if(O.autoUpdate===!1&&O.needsUpdate===!1)continue;n.copy(O.mapSize);const F=O.getFrameExtents();if(n.multiply(F),r.copy(O.mapSize),(n.x>c||n.y>c)&&(n.x>c&&(r.x=Math.floor(c/F.x),n.x=r.x*F.x,O.mapSize.x=r.x),n.y>c&&(r.y=Math.floor(c/F.y),n.y=r.y*F.y,O.mapSize.y=r.y)),O.map!==null||O.isPointLightShadow||this.type!==va||(O.map=new de(n.x,n.y),O.map.texture.name=B.name+".shadowMap",O.mapPass=new de(n.x,n.y),O.camera.updateProjectionMatrix()),O.map===null){const k={minFilter:Ft,magFilter:Ft,format:$t};O.map=new de(n.x,n.y,k),O.map.texture.name=B.name+".shadowMap",O.camera.updateProjectionMatrix()}s.setRenderTarget(O.map),s.clear();const Q=O.getViewportCount();for(let k=0;k<Q;k++){const X=O.getViewport(k);a.set(r.x*X.x,r.y*X.y,r.x*X.z,r.y*X.w),E.viewport(a),O.updateMatrices(B,k),i=O.getFrustum(),y(S,w,O.camera,B,this.type)}O.isPointLightShadow||this.type!==va||v(O,w),O.needsUpdate=!1}_.needsUpdate=!1,s.setRenderTarget(C,L,T)}}function Bx(s,t,e){const i=e.isWebGL2,n=new function(){let P=!1;const J=new Lt;let N=null;const ct=new Lt(0,0,0,0);return{setMask:function($){N===$||P||(s.colorMask($,$,$,$),N=$)},setLocked:function($){P=$},setClear:function($,ht,gt,yt,Ct){Ct===!0&&($*=yt,ht*=yt,gt*=yt),J.set($,ht,gt,yt),ct.equals(J)===!1&&(s.clearColor($,ht,gt,yt),ct.copy(J))},reset:function(){P=!1,N=null,ct.set(-1,0,0,0)}}},r=new function(){let P=!1,J=null,N=null,ct=null;return{setTest:function($){$?mt(2929):_t(2929)},setMask:function($){J===$||P||(s.depthMask($),J=$)},setFunc:function($){if(N!==$){if($)switch($){case y0:s.depthFunc(512);break;case b0:s.depthFunc(519);break;case M0:s.depthFunc(513);break;case bh:s.depthFunc(515);break;case w0:s.depthFunc(514);break;case S0:s.depthFunc(518);break;case T0:s.depthFunc(516);break;case C0:s.depthFunc(517);break;default:s.depthFunc(515)}else s.depthFunc(515);N=$}},setLocked:function($){P=$},setClear:function($){ct!==$&&(s.clearDepth($),ct=$)},reset:function(){P=!1,J=null,N=null,ct=null}}},a=new function(){let P=!1,J=null,N=null,ct=null,$=null,ht=null,gt=null,yt=null,Ct=null;return{setTest:function(bt){P||(bt?mt(2960):_t(2960))},setMask:function(bt){J===bt||P||(s.stencilMask(bt),J=bt)},setFunc:function(bt,kt,Rt){N===bt&&ct===kt&&$===Rt||(s.stencilFunc(bt,kt,Rt),N=bt,ct=kt,$=Rt)},setOp:function(bt,kt,Rt){ht===bt&&gt===kt&&yt===Rt||(s.stencilOp(bt,kt,Rt),ht=bt,gt=kt,yt=Rt)},setLocked:function(bt){P=bt},setClear:function(bt){Ct!==bt&&(s.clearStencil(bt),Ct=bt)},reset:function(){P=!1,J=null,N=null,ct=null,$=null,ht=null,gt=null,yt=null,Ct=null}}};let o={},l={},h=new WeakMap,c=[],u=null,p=!1,m=null,f=null,g=null,_=null,v=null,x=null,y=null,b=!1,S=null,w=null,C=null,L=null,T=null;const E=s.getParameter(35661);let I=!1,z=0;const B=s.getParameter(7938);B.indexOf("WebGL")!==-1?(z=parseFloat(/^WebGL (\d)/.exec(B)[1]),I=z>=1):B.indexOf("OpenGL ES")!==-1&&(z=parseFloat(/^OpenGL ES (\d)/.exec(B)[1]),I=z>=2);let O=null,F={};const Q=s.getParameter(3088),k=s.getParameter(2978),X=new Lt().fromArray(Q),U=new Lt().fromArray(k);function H(P,J,N){const ct=new Uint8Array(4),$=s.createTexture();s.bindTexture(P,$),s.texParameteri(P,10241,9728),s.texParameteri(P,10240,9728);for(let ht=0;ht<N;ht++)s.texImage2D(J+ht,0,6408,1,1,0,6408,5121,ct);return $}const Z={};function mt(P){o[P]!==!0&&(s.enable(P),o[P]=!0)}function _t(P){o[P]!==!1&&(s.disable(P),o[P]=!1)}Z[3553]=H(3553,3553,1),Z[34067]=H(34067,34069,6),n.setClear(0,0,0,1),r.setClear(1),a.setClear(0),mt(2929),r.setFunc(bh),A(!1),G(cd),mt(2884),R(Bn);const Mt={[or]:32774,[u0]:32778,[d0]:32779};if(i)Mt[fd]=32775,Mt[gd]=32776;else{const P=t.get("EXT_blend_minmax");P!==null&&(Mt[fd]=P.MIN_EXT,Mt[gd]=P.MAX_EXT)}const wt={[_d]:0,[Po]:1,[p0]:768,[vd]:770,[x0]:776,[_0]:774,[f0]:772,[m0]:769,[xd]:771,[v0]:775,[g0]:773};function R(P,J,N,ct,$,ht,gt,yt){if(P!==Bn){if(p===!1&&(mt(3042),p=!0),P===md)$=$||J,ht=ht||N,gt=gt||ct,J===f&&$===v||(s.blendEquationSeparate(Mt[J],Mt[$]),f=J,v=$),N===g&&ct===_&&ht===x&&gt===y||(s.blendFuncSeparate(wt[N],wt[ct],wt[ht],wt[gt]),g=N,_=ct,x=ht,y=gt),m=P,b=null;else if(P!==m||yt!==b){if(f===or&&v===or||(s.blendEquation(32774),f=or,v=or),yt)switch(P){case ar:s.blendFuncSeparate(1,771,1,771);break;case xa:s.blendFunc(1,1);break;case dd:s.blendFuncSeparate(0,769,0,1);break;case pd:s.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",P)}else switch(P){case ar:s.blendFuncSeparate(770,771,1,771);break;case xa:s.blendFunc(770,1);break;case dd:s.blendFuncSeparate(0,769,0,1);break;case pd:s.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",P)}g=null,_=null,x=null,y=null,m=P,b=yt}}else p===!0&&(_t(3042),p=!1)}function A(P){S!==P&&(P?s.frontFace(2304):s.frontFace(2305),S=P)}function G(P){P!==l0?(mt(2884),P!==w&&(P===cd?s.cullFace(1029):P===h0?s.cullFace(1028):s.cullFace(1032))):_t(2884),w=P}function it(P,J,N){P?(mt(32823),L===J&&T===N||(s.polygonOffset(J,N),L=J,T=N)):_t(32823)}function V(P){P===void 0&&(P=33984+E-1),O!==P&&(s.activeTexture(P),O=P)}return{buffers:{color:n,depth:r,stencil:a},enable:mt,disable:_t,bindFramebuffer:function(P,J){return l[P]!==J&&(s.bindFramebuffer(P,J),l[P]=J,i&&(P===36009&&(l[36160]=J),P===36160&&(l[36009]=J)),!0)},drawBuffers:function(P,J){let N=c,ct=!1;if(P)if(N=h.get(J),N===void 0&&(N=[],h.set(J,N)),P.isWebGLMultipleRenderTargets){const $=P.texture;if(N.length!==$.length||N[0]!==36064){for(let ht=0,gt=$.length;ht<gt;ht++)N[ht]=36064+ht;N.length=$.length,ct=!0}}else N[0]!==36064&&(N[0]=36064,ct=!0);else N[0]!==1029&&(N[0]=1029,ct=!0);ct&&(e.isWebGL2?s.drawBuffers(N):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(N))},useProgram:function(P){return u!==P&&(s.useProgram(P),u=P,!0)},setBlending:R,setMaterial:function(P,J){P.side===ce?_t(2884):mt(2884);let N=P.side===pi;J&&(N=!N),A(N),P.blending===ar&&P.transparent===!1?R(Bn):R(P.blending,P.blendEquation,P.blendSrc,P.blendDst,P.blendEquationAlpha,P.blendSrcAlpha,P.blendDstAlpha,P.premultipliedAlpha),r.setFunc(P.depthFunc),r.setTest(P.depthTest),r.setMask(P.depthWrite),n.setMask(P.colorWrite);const ct=P.stencilWrite;a.setTest(ct),ct&&(a.setMask(P.stencilWriteMask),a.setFunc(P.stencilFunc,P.stencilRef,P.stencilFuncMask),a.setOp(P.stencilFail,P.stencilZFail,P.stencilZPass)),it(P.polygonOffset,P.polygonOffsetFactor,P.polygonOffsetUnits),P.alphaToCoverage===!0?mt(32926):_t(32926)},setFlipSided:A,setCullFace:G,setLineWidth:function(P){P!==C&&(I&&s.lineWidth(P),C=P)},setPolygonOffset:it,setScissorTest:function(P){P?mt(3089):_t(3089)},activeTexture:V,bindTexture:function(P,J){O===null&&V();let N=F[O];N===void 0&&(N={type:void 0,texture:void 0},F[O]=N),N.type===P&&N.texture===J||(s.bindTexture(P,J||Z[P]),N.type=P,N.texture=J)},unbindTexture:function(){const P=F[O];P!==void 0&&P.type!==void 0&&(s.bindTexture(P.type,null),P.type=void 0,P.texture=void 0)},compressedTexImage2D:function(){try{s.compressedTexImage2D.apply(s,arguments)}catch(P){console.error("THREE.WebGLState:",P)}},texImage2D:function(){try{s.texImage2D.apply(s,arguments)}catch(P){console.error("THREE.WebGLState:",P)}},texImage3D:function(){try{s.texImage3D.apply(s,arguments)}catch(P){console.error("THREE.WebGLState:",P)}},texStorage2D:function(){try{s.texStorage2D.apply(s,arguments)}catch(P){console.error("THREE.WebGLState:",P)}},texStorage3D:function(){try{s.texStorage3D.apply(s,arguments)}catch(P){console.error("THREE.WebGLState:",P)}},texSubImage2D:function(){try{s.texSubImage2D.apply(s,arguments)}catch(P){console.error("THREE.WebGLState:",P)}},texSubImage3D:function(){try{s.texSubImage3D.apply(s,arguments)}catch(P){console.error("THREE.WebGLState:",P)}},compressedTexSubImage2D:function(){try{s.compressedTexSubImage2D.apply(s,arguments)}catch(P){console.error("THREE.WebGLState:",P)}},scissor:function(P){X.equals(P)===!1&&(s.scissor(P.x,P.y,P.z,P.w),X.copy(P))},viewport:function(P){U.equals(P)===!1&&(s.viewport(P.x,P.y,P.z,P.w),U.copy(P))},reset:function(){s.disable(3042),s.disable(2884),s.disable(2929),s.disable(32823),s.disable(3089),s.disable(2960),s.disable(32926),s.blendEquation(32774),s.blendFunc(1,0),s.blendFuncSeparate(1,0,1,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(513),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(519,0,4294967295),s.stencilOp(7680,7680,7680),s.clearStencil(0),s.cullFace(1029),s.frontFace(2305),s.polygonOffset(0,0),s.activeTexture(33984),s.bindFramebuffer(36160,null),i===!0&&(s.bindFramebuffer(36009,null),s.bindFramebuffer(36008,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),o={},O=null,F={},l={},h=new WeakMap,c=[],u=null,p=!1,m=null,f=null,g=null,_=null,v=null,x=null,y=null,b=!1,S=null,w=null,C=null,L=null,T=null,X.set(0,0,s.canvas.width,s.canvas.height),U.set(0,0,s.canvas.width,s.canvas.height),n.reset(),r.reset(),a.reset()}}}function Vx(s,t,e,i,n,r,a){const o=n.isWebGL2,l=n.maxTextures,h=n.maxCubemapSize,c=n.maxTextureSize,u=n.maxSamples,p=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,m=/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap;let g;const _=new WeakMap;let v=!1;try{v=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function x(R,A){return v?new OffscreenCanvas(R,A):Ta("canvas")}function y(R,A,G,it){let V=1;if((R.width>it||R.height>it)&&(V=it/Math.max(R.width,R.height)),V<1||A===!0){if(typeof HTMLImageElement<"u"&&R instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&R instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&R instanceof ImageBitmap){const P=A?Oo:Math.floor,J=P(V*R.width),N=P(V*R.height);g===void 0&&(g=x(J,N));const ct=G?x(J,N):g;return ct.width=J,ct.height=N,ct.getContext("2d").drawImage(R,0,0,J,N),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+R.width+"x"+R.height+") to ("+J+"x"+N+")."),ct}return"data"in R&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+R.width+"x"+R.height+")."),R}return R}function b(R){return Ih(R.width)&&Ih(R.height)}function S(R,A){return R.generateMipmaps&&A&&R.minFilter!==Ft&&R.minFilter!==Wt}function w(R){s.generateMipmap(R)}function C(R,A,G,it,V=!1){if(o===!1)return A;if(R!==null){if(s[R]!==void 0)return s[R];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+R+"'")}let P=A;return A===6403&&(G===5126&&(P=33326),G===5131&&(P=33325),G===5121&&(P=33321)),A===33319&&(G===5126&&(P=33328),G===5131&&(P=33327),G===5121&&(P=33323)),A===6408&&(G===5126&&(P=34836),G===5131&&(P=34842),G===5121&&(P=it===Bt&&V===!1?35907:32856),G===32819&&(P=32854),G===32820&&(P=32855)),P!==33325&&P!==33326&&P!==33327&&P!==33328&&P!==34842&&P!==34836||t.get("EXT_color_buffer_float"),P}function L(R,A,G){return S(R,G)===!0||R.isFramebufferTexture&&R.minFilter!==Ft&&R.minFilter!==Wt?Math.log2(Math.max(A.width,A.height))+1:R.mipmaps!==void 0&&R.mipmaps.length>0?R.mipmaps.length:R.isCompressedTexture&&Array.isArray(R.image)?A.mipmaps.length:1}function T(R){return R===Ft||R===wh||R===Sh?9728:9729}function E(R){const A=R.target;A.removeEventListener("dispose",E),function(G){const it=i.get(G);if(it.__webglInit===void 0)return;const V=G.source,P=_.get(V);if(P){const J=P[it.__cacheKey];J.usedTimes--,J.usedTimes===0&&z(G),Object.keys(P).length===0&&_.delete(V)}i.remove(G)}(A),A.isVideoTexture&&f.delete(A)}function I(R){const A=R.target;A.removeEventListener("dispose",I),function(G){const it=G.texture,V=i.get(G),P=i.get(it);if(P.__webglTexture!==void 0&&(s.deleteTexture(P.__webglTexture),a.memory.textures--),G.depthTexture&&G.depthTexture.dispose(),G.isWebGLCubeRenderTarget)for(let J=0;J<6;J++)s.deleteFramebuffer(V.__webglFramebuffer[J]),V.__webglDepthbuffer&&s.deleteRenderbuffer(V.__webglDepthbuffer[J]);else{if(s.deleteFramebuffer(V.__webglFramebuffer),V.__webglDepthbuffer&&s.deleteRenderbuffer(V.__webglDepthbuffer),V.__webglMultisampledFramebuffer&&s.deleteFramebuffer(V.__webglMultisampledFramebuffer),V.__webglColorRenderbuffer)for(let J=0;J<V.__webglColorRenderbuffer.length;J++)V.__webglColorRenderbuffer[J]&&s.deleteRenderbuffer(V.__webglColorRenderbuffer[J]);V.__webglDepthRenderbuffer&&s.deleteRenderbuffer(V.__webglDepthRenderbuffer)}if(G.isWebGLMultipleRenderTargets)for(let J=0,N=it.length;J<N;J++){const ct=i.get(it[J]);ct.__webglTexture&&(s.deleteTexture(ct.__webglTexture),a.memory.textures--),i.remove(it[J])}i.remove(it),i.remove(G)}(A)}function z(R){const A=i.get(R);s.deleteTexture(A.__webglTexture);const G=R.source;delete _.get(G)[A.__cacheKey],a.memory.textures--}let B=0;function O(R,A){const G=i.get(R);if(R.isVideoTexture&&function(it){const V=a.render.frame;f.get(it)!==V&&(f.set(it,V),it.update())}(R),R.isRenderTargetTexture===!1&&R.version>0&&G.__version!==R.version){const it=R.image;if(it===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(it.complete!==!1)return void U(G,R,A);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}e.activeTexture(33984+A),e.bindTexture(3553,G.__webglTexture)}const F={[ze]:10497,[ue]:33071,[Lo]:33648},Q={[Ft]:9728,[wh]:9984,[Sh]:9986,[Wt]:9729,[bd]:9985,[ys]:9987};function k(R,A,G){if(G?(s.texParameteri(R,10242,F[A.wrapS]),s.texParameteri(R,10243,F[A.wrapT]),R!==32879&&R!==35866||s.texParameteri(R,32882,F[A.wrapR]),s.texParameteri(R,10240,Q[A.magFilter]),s.texParameteri(R,10241,Q[A.minFilter])):(s.texParameteri(R,10242,33071),s.texParameteri(R,10243,33071),R!==32879&&R!==35866||s.texParameteri(R,32882,33071),A.wrapS===ue&&A.wrapT===ue||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(R,10240,T(A.magFilter)),s.texParameteri(R,10241,T(A.minFilter)),A.minFilter!==Ft&&A.minFilter!==Wt&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const it=t.get("EXT_texture_filter_anisotropic");if(A.type===Ve&&t.has("OES_texture_float_linear")===!1||o===!1&&A.type===be&&t.has("OES_texture_half_float_linear")===!1)return;(A.anisotropy>1||i.get(A).__currentAnisotropy)&&(s.texParameterf(R,it.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(A.anisotropy,n.getMaxAnisotropy())),i.get(A).__currentAnisotropy=A.anisotropy)}}function X(R,A){let G=!1;R.__webglInit===void 0&&(R.__webglInit=!0,A.addEventListener("dispose",E));const it=A.source;let V=_.get(it);V===void 0&&(V={},_.set(it,V));const P=function(J){const N=[];return N.push(J.wrapS),N.push(J.wrapT),N.push(J.magFilter),N.push(J.minFilter),N.push(J.anisotropy),N.push(J.internalFormat),N.push(J.format),N.push(J.type),N.push(J.generateMipmaps),N.push(J.premultiplyAlpha),N.push(J.flipY),N.push(J.unpackAlignment),N.push(J.encoding),N.join()}(A);if(P!==R.__cacheKey){V[P]===void 0&&(V[P]={texture:s.createTexture(),usedTimes:0},a.memory.textures++,G=!0),V[P].usedTimes++;const J=V[R.__cacheKey];J!==void 0&&(V[R.__cacheKey].usedTimes--,J.usedTimes===0&&z(A)),R.__cacheKey=P,R.__webglTexture=V[P].texture}return G}function U(R,A,G){let it=3553;A.isDataArrayTexture&&(it=35866),A.isData3DTexture&&(it=32879);const V=X(R,A),P=A.source;if(e.activeTexture(33984+G),e.bindTexture(it,R.__webglTexture),P.version!==P.__currentVersion||V===!0){s.pixelStorei(37440,A.flipY),s.pixelStorei(37441,A.premultiplyAlpha),s.pixelStorei(3317,A.unpackAlignment),s.pixelStorei(37443,0);const J=function(It){return!o&&(It.wrapS!==ue||It.wrapT!==ue||It.minFilter!==Ft&&It.minFilter!==Wt)}(A)&&b(A.image)===!1;let N=y(A.image,J,!1,c);N=wt(A,N);const ct=b(N)||o,$=r.convert(A.format,A.encoding);let ht,gt=r.convert(A.type),yt=C(A.internalFormat,$,gt,A.encoding,A.isVideoTexture);k(it,A,ct);const Ct=A.mipmaps,bt=o&&A.isVideoTexture!==!0,kt=P.__currentVersion===void 0||V===!0,Rt=L(A,N,ct);if(A.isDepthTexture)yt=6402,o?yt=A.type===Ve?36012:A.type===bs?33190:A.type===Ms?35056:33189:A.type===Ve&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),A.format===ws&&yt===6402&&A.type!==Md&&A.type!==bs&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),A.type=bs,gt=r.convert(A.type)),A.format===Ss&&yt===6402&&(yt=34041,A.type!==Ms&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),A.type=Ms,gt=r.convert(A.type))),kt&&(bt?e.texStorage2D(3553,1,yt,N.width,N.height):e.texImage2D(3553,0,yt,N.width,N.height,0,$,gt,null));else if(A.isDataTexture)if(Ct.length>0&&ct){bt&&kt&&e.texStorage2D(3553,Rt,yt,Ct[0].width,Ct[0].height);for(let It=0,_e=Ct.length;It<_e;It++)ht=Ct[It],bt?e.texSubImage2D(3553,It,0,0,ht.width,ht.height,$,gt,ht.data):e.texImage2D(3553,It,yt,ht.width,ht.height,0,$,gt,ht.data);A.generateMipmaps=!1}else bt?(kt&&e.texStorage2D(3553,Rt,yt,N.width,N.height),e.texSubImage2D(3553,0,0,0,N.width,N.height,$,gt,N.data)):e.texImage2D(3553,0,yt,N.width,N.height,0,$,gt,N.data);else if(A.isCompressedTexture){bt&&kt&&e.texStorage2D(3553,Rt,yt,Ct[0].width,Ct[0].height);for(let It=0,_e=Ct.length;It<_e;It++)ht=Ct[It],A.format!==$t?$!==null?bt?e.compressedTexSubImage2D(3553,It,0,0,ht.width,ht.height,$,ht.data):e.compressedTexImage2D(3553,It,yt,ht.width,ht.height,0,ht.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):bt?e.texSubImage2D(3553,It,0,0,ht.width,ht.height,$,gt,ht.data):e.texImage2D(3553,It,yt,ht.width,ht.height,0,$,gt,ht.data)}else if(A.isDataArrayTexture)bt?(kt&&e.texStorage3D(35866,Rt,yt,N.width,N.height,N.depth),e.texSubImage3D(35866,0,0,0,0,N.width,N.height,N.depth,$,gt,N.data)):e.texImage3D(35866,0,yt,N.width,N.height,N.depth,0,$,gt,N.data);else if(A.isData3DTexture)bt?(kt&&e.texStorage3D(32879,Rt,yt,N.width,N.height,N.depth),e.texSubImage3D(32879,0,0,0,0,N.width,N.height,N.depth,$,gt,N.data)):e.texImage3D(32879,0,yt,N.width,N.height,N.depth,0,$,gt,N.data);else if(A.isFramebufferTexture){if(kt)if(bt)e.texStorage2D(3553,Rt,yt,N.width,N.height);else{let It=N.width,_e=N.height;for(let on=0;on<Rt;on++)e.texImage2D(3553,on,yt,It,_e,0,$,gt,null),It>>=1,_e>>=1}}else if(Ct.length>0&&ct){bt&&kt&&e.texStorage2D(3553,Rt,yt,Ct[0].width,Ct[0].height);for(let It=0,_e=Ct.length;It<_e;It++)ht=Ct[It],bt?e.texSubImage2D(3553,It,0,0,$,gt,ht):e.texImage2D(3553,It,yt,$,gt,ht);A.generateMipmaps=!1}else bt?(kt&&e.texStorage2D(3553,Rt,yt,N.width,N.height),e.texSubImage2D(3553,0,0,0,$,gt,N)):e.texImage2D(3553,0,yt,$,gt,N);S(A,ct)&&w(it),P.__currentVersion=P.version,A.onUpdate&&A.onUpdate(A)}R.__version=A.version}function H(R,A,G,it,V){const P=r.convert(G.format,G.encoding),J=r.convert(G.type),N=C(G.internalFormat,P,J,G.encoding);i.get(A).__hasExternalTextures||(V===32879||V===35866?e.texImage3D(V,0,N,A.width,A.height,A.depth,0,P,J,null):e.texImage2D(V,0,N,A.width,A.height,0,P,J,null)),e.bindFramebuffer(36160,R),Mt(A)?p.framebufferTexture2DMultisampleEXT(36160,it,V,i.get(G).__webglTexture,0,_t(A)):s.framebufferTexture2D(36160,it,V,i.get(G).__webglTexture,0),e.bindFramebuffer(36160,null)}function Z(R,A,G){if(s.bindRenderbuffer(36161,R),A.depthBuffer&&!A.stencilBuffer){let it=33189;if(G||Mt(A)){const V=A.depthTexture;V&&V.isDepthTexture&&(V.type===Ve?it=36012:V.type===bs&&(it=33190));const P=_t(A);Mt(A)?p.renderbufferStorageMultisampleEXT(36161,P,it,A.width,A.height):s.renderbufferStorageMultisample(36161,P,it,A.width,A.height)}else s.renderbufferStorage(36161,it,A.width,A.height);s.framebufferRenderbuffer(36160,36096,36161,R)}else if(A.depthBuffer&&A.stencilBuffer){const it=_t(A);G&&Mt(A)===!1?s.renderbufferStorageMultisample(36161,it,35056,A.width,A.height):Mt(A)?p.renderbufferStorageMultisampleEXT(36161,it,35056,A.width,A.height):s.renderbufferStorage(36161,34041,A.width,A.height),s.framebufferRenderbuffer(36160,33306,36161,R)}else{const it=A.isWebGLMultipleRenderTargets===!0?A.texture:[A.texture];for(let V=0;V<it.length;V++){const P=it[V],J=r.convert(P.format,P.encoding),N=r.convert(P.type),ct=C(P.internalFormat,J,N,P.encoding),$=_t(A);G&&Mt(A)===!1?s.renderbufferStorageMultisample(36161,$,ct,A.width,A.height):Mt(A)?p.renderbufferStorageMultisampleEXT(36161,$,ct,A.width,A.height):s.renderbufferStorage(36161,ct,A.width,A.height)}}s.bindRenderbuffer(36161,null)}function mt(R){const A=i.get(R),G=R.isWebGLCubeRenderTarget===!0;if(R.depthTexture&&!A.__autoAllocateDepthBuffer){if(G)throw new Error("target.depthTexture not supported in Cube render targets");(function(it,V){if(V&&V.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,it),!V.depthTexture||!V.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(V.depthTexture).__webglTexture&&V.depthTexture.image.width===V.width&&V.depthTexture.image.height===V.height||(V.depthTexture.image.width=V.width,V.depthTexture.image.height=V.height,V.depthTexture.needsUpdate=!0),O(V.depthTexture,0);const P=i.get(V.depthTexture).__webglTexture,J=_t(V);if(V.depthTexture.format===ws)Mt(V)?p.framebufferTexture2DMultisampleEXT(36160,36096,3553,P,0,J):s.framebufferTexture2D(36160,36096,3553,P,0);else{if(V.depthTexture.format!==Ss)throw new Error("Unknown depthTexture format");Mt(V)?p.framebufferTexture2DMultisampleEXT(36160,33306,3553,P,0,J):s.framebufferTexture2D(36160,33306,3553,P,0)}})(A.__webglFramebuffer,R)}else if(G){A.__webglDepthbuffer=[];for(let it=0;it<6;it++)e.bindFramebuffer(36160,A.__webglFramebuffer[it]),A.__webglDepthbuffer[it]=s.createRenderbuffer(),Z(A.__webglDepthbuffer[it],R,!1)}else e.bindFramebuffer(36160,A.__webglFramebuffer),A.__webglDepthbuffer=s.createRenderbuffer(),Z(A.__webglDepthbuffer,R,!1);e.bindFramebuffer(36160,null)}function _t(R){return Math.min(u,R.samples)}function Mt(R){const A=i.get(R);return o&&R.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&A.__useRenderToTexture!==!1}function wt(R,A){const G=R.encoding,it=R.format,V=R.type;return R.isCompressedTexture===!0||R.isVideoTexture===!0||R.format===Dh||G!==un&&(G===Bt?o===!1?t.has("EXT_sRGB")===!0&&it===$t?(R.format=Dh,R.minFilter=Wt,R.generateMipmaps=!1):A=Zd.sRGBToLinear(A):it===$t&&V===Vn||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",G)),A}this.allocateTextureUnit=function(){const R=B;return R>=l&&console.warn("THREE.WebGLTextures: Trying to use "+R+" texture units while this GPU supports only "+l),B+=1,R},this.resetTextureUnits=function(){B=0},this.setTexture2D=O,this.setTexture2DArray=function(R,A){const G=i.get(R);R.version>0&&G.__version!==R.version?U(G,R,A):(e.activeTexture(33984+A),e.bindTexture(35866,G.__webglTexture))},this.setTexture3D=function(R,A){const G=i.get(R);R.version>0&&G.__version!==R.version?U(G,R,A):(e.activeTexture(33984+A),e.bindTexture(32879,G.__webglTexture))},this.setTextureCube=function(R,A){const G=i.get(R);R.version>0&&G.__version!==R.version?function(it,V,P){if(V.image.length!==6)return;const J=X(it,V),N=V.source;if(e.activeTexture(33984+P),e.bindTexture(34067,it.__webglTexture),N.version!==N.__currentVersion||J===!0){s.pixelStorei(37440,V.flipY),s.pixelStorei(37441,V.premultiplyAlpha),s.pixelStorei(3317,V.unpackAlignment),s.pixelStorei(37443,0);const ct=V.isCompressedTexture||V.image[0].isCompressedTexture,$=V.image[0]&&V.image[0].isDataTexture,ht=[];for(let Et=0;Et<6;Et++)ht[Et]=ct||$?$?V.image[Et].image:V.image[Et]:y(V.image[Et],!1,!0,h),ht[Et]=wt(V,ht[Et]);const gt=ht[0],yt=b(gt)||o,Ct=r.convert(V.format,V.encoding),bt=r.convert(V.type),kt=C(V.internalFormat,Ct,bt,V.encoding),Rt=o&&V.isVideoTexture!==!0,It=N.__currentVersion===void 0||J===!0;let _e,on=L(V,gt,yt);if(k(34067,V,yt),ct){Rt&&It&&e.texStorage2D(34067,on,kt,gt.width,gt.height);for(let Et=0;Et<6;Et++){_e=ht[Et].mipmaps;for(let qt=0;qt<_e.length;qt++){const Yt=_e[qt];V.format!==$t?Ct!==null?Rt?e.compressedTexSubImage2D(34069+Et,qt,0,0,Yt.width,Yt.height,Ct,Yt.data):e.compressedTexImage2D(34069+Et,qt,kt,Yt.width,Yt.height,0,Yt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Rt?e.texSubImage2D(34069+Et,qt,0,0,Yt.width,Yt.height,Ct,bt,Yt.data):e.texImage2D(34069+Et,qt,kt,Yt.width,Yt.height,0,Ct,bt,Yt.data)}}}else{_e=V.mipmaps,Rt&&It&&(_e.length>0&&on++,e.texStorage2D(34067,on,kt,ht[0].width,ht[0].height));for(let Et=0;Et<6;Et++)if($){Rt?e.texSubImage2D(34069+Et,0,0,0,ht[Et].width,ht[Et].height,Ct,bt,ht[Et].data):e.texImage2D(34069+Et,0,kt,ht[Et].width,ht[Et].height,0,Ct,bt,ht[Et].data);for(let qt=0;qt<_e.length;qt++){const Yt=_e[qt].image[Et].image;Rt?e.texSubImage2D(34069+Et,qt+1,0,0,Yt.width,Yt.height,Ct,bt,Yt.data):e.texImage2D(34069+Et,qt+1,kt,Yt.width,Yt.height,0,Ct,bt,Yt.data)}}else{Rt?e.texSubImage2D(34069+Et,0,0,0,Ct,bt,ht[Et]):e.texImage2D(34069+Et,0,kt,Ct,bt,ht[Et]);for(let qt=0;qt<_e.length;qt++){const Yt=_e[qt];Rt?e.texSubImage2D(34069+Et,qt+1,0,0,Ct,bt,Yt.image[Et]):e.texImage2D(34069+Et,qt+1,kt,Ct,bt,Yt.image[Et])}}}S(V,yt)&&w(34067),N.__currentVersion=N.version,V.onUpdate&&V.onUpdate(V)}it.__version=V.version}(G,R,A):(e.activeTexture(33984+A),e.bindTexture(34067,G.__webglTexture))},this.rebindTextures=function(R,A,G){const it=i.get(R);A!==void 0&&H(it.__webglFramebuffer,R,R.texture,36064,3553),G!==void 0&&mt(R)},this.setupRenderTarget=function(R){const A=R.texture,G=i.get(R),it=i.get(A);R.addEventListener("dispose",I),R.isWebGLMultipleRenderTargets!==!0&&(it.__webglTexture===void 0&&(it.__webglTexture=s.createTexture()),it.__version=A.version,a.memory.textures++);const V=R.isWebGLCubeRenderTarget===!0,P=R.isWebGLMultipleRenderTargets===!0,J=b(R)||o;if(V){G.__webglFramebuffer=[];for(let N=0;N<6;N++)G.__webglFramebuffer[N]=s.createFramebuffer()}else{if(G.__webglFramebuffer=s.createFramebuffer(),P)if(n.drawBuffers){const N=R.texture;for(let ct=0,$=N.length;ct<$;ct++){const ht=i.get(N[ct]);ht.__webglTexture===void 0&&(ht.__webglTexture=s.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&R.samples>0&&Mt(R)===!1){const N=P?A:[A];G.__webglMultisampledFramebuffer=s.createFramebuffer(),G.__webglColorRenderbuffer=[],e.bindFramebuffer(36160,G.__webglMultisampledFramebuffer);for(let ct=0;ct<N.length;ct++){const $=N[ct];G.__webglColorRenderbuffer[ct]=s.createRenderbuffer(),s.bindRenderbuffer(36161,G.__webglColorRenderbuffer[ct]);const ht=r.convert($.format,$.encoding),gt=r.convert($.type),yt=C($.internalFormat,ht,gt,$.encoding),Ct=_t(R);s.renderbufferStorageMultisample(36161,Ct,yt,R.width,R.height),s.framebufferRenderbuffer(36160,36064+ct,36161,G.__webglColorRenderbuffer[ct])}s.bindRenderbuffer(36161,null),R.depthBuffer&&(G.__webglDepthRenderbuffer=s.createRenderbuffer(),Z(G.__webglDepthRenderbuffer,R,!0)),e.bindFramebuffer(36160,null)}}if(V){e.bindTexture(34067,it.__webglTexture),k(34067,A,J);for(let N=0;N<6;N++)H(G.__webglFramebuffer[N],R,A,36064,34069+N);S(A,J)&&w(34067),e.unbindTexture()}else if(P){const N=R.texture;for(let ct=0,$=N.length;ct<$;ct++){const ht=N[ct],gt=i.get(ht);e.bindTexture(3553,gt.__webglTexture),k(3553,ht,J),H(G.__webglFramebuffer,R,ht,36064+ct,3553),S(ht,J)&&w(3553)}e.unbindTexture()}else{let N=3553;(R.isWebGL3DRenderTarget||R.isWebGLArrayRenderTarget)&&(o?N=R.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),e.bindTexture(N,it.__webglTexture),k(N,A,J),H(G.__webglFramebuffer,R,A,36064,N),S(A,J)&&w(N),e.unbindTexture()}R.depthBuffer&&mt(R)},this.updateRenderTargetMipmap=function(R){const A=b(R)||o,G=R.isWebGLMultipleRenderTargets===!0?R.texture:[R.texture];for(let it=0,V=G.length;it<V;it++){const P=G[it];if(S(P,A)){const J=R.isWebGLCubeRenderTarget?34067:3553,N=i.get(P).__webglTexture;e.bindTexture(J,N),w(J),e.unbindTexture()}}},this.updateMultisampleRenderTarget=function(R){if(o&&R.samples>0&&Mt(R)===!1){const A=R.isWebGLMultipleRenderTargets?R.texture:[R.texture],G=R.width,it=R.height;let V=16384;const P=[],J=R.stencilBuffer?33306:36096,N=i.get(R),ct=R.isWebGLMultipleRenderTargets===!0;if(ct)for(let $=0;$<A.length;$++)e.bindFramebuffer(36160,N.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064+$,36161,null),e.bindFramebuffer(36160,N.__webglFramebuffer),s.framebufferTexture2D(36009,36064+$,3553,null,0);e.bindFramebuffer(36008,N.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,N.__webglFramebuffer);for(let $=0;$<A.length;$++){P.push(36064+$),R.depthBuffer&&P.push(J);const ht=N.__ignoreDepthValues!==void 0&&N.__ignoreDepthValues;if(ht===!1&&(R.depthBuffer&&(V|=256),R.stencilBuffer&&(V|=1024)),ct&&s.framebufferRenderbuffer(36008,36064,36161,N.__webglColorRenderbuffer[$]),ht===!0&&(s.invalidateFramebuffer(36008,[J]),s.invalidateFramebuffer(36009,[J])),ct){const gt=i.get(A[$]).__webglTexture;s.framebufferTexture2D(36009,36064,3553,gt,0)}s.blitFramebuffer(0,0,G,it,0,0,G,it,V,9728),m&&s.invalidateFramebuffer(36008,P)}if(e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,null),ct)for(let $=0;$<A.length;$++){e.bindFramebuffer(36160,N.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064+$,36161,N.__webglColorRenderbuffer[$]);const ht=i.get(A[$]).__webglTexture;e.bindFramebuffer(36160,N.__webglFramebuffer),s.framebufferTexture2D(36009,36064+$,3553,ht,0)}e.bindFramebuffer(36009,N.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=mt,this.setupFrameBufferTexture=H,this.useMultisampledRTT=Mt}function Hx(s,t,e){const i=e.isWebGL2;return{convert:function(n,r=null){let a;if(n===Vn)return 5121;if(n===k0)return 32819;if(n===N0)return 32820;if(n===I0)return 5120;if(n===O0)return 5122;if(n===Md)return 5123;if(n===z0)return 5124;if(n===bs)return 5125;if(n===Ve)return 5126;if(n===be)return i?5131:(a=t.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(n===U0)return 6406;if(n===$t)return 6408;if(n===B0)return 6409;if(n===V0)return 6410;if(n===ws)return 6402;if(n===Ss)return 34041;if(n===H0)return 6403;if(n===F0)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(n===Dh)return a=t.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(n===j0)return 36244;if(n===G0)return 33319;if(n===W0)return 33320;if(n===X0)return 36249;if(n===Th||n===Ch||n===Eh||n===Ah)if(r===Bt){if(a=t.get("WEBGL_compressed_texture_s3tc_srgb"),a===null)return null;if(n===Th)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Ch)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===Eh)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Ah)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(a=t.get("WEBGL_compressed_texture_s3tc"),a===null)return null;if(n===Th)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Ch)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===Eh)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Ah)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===wd||n===Sd||n===Td||n===Cd){if(a=t.get("WEBGL_compressed_texture_pvrtc"),a===null)return null;if(n===wd)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===Sd)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===Td)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===Cd)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===q0)return a=t.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(n===Ed||n===Ad){if(a=t.get("WEBGL_compressed_texture_etc"),a===null)return null;if(n===Ed)return r===Bt?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(n===Ad)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}if(n===Pd||n===Rd||n===Dd||n===Ld||n===Id||n===Od||n===zd||n===kd||n===Nd||n===Ud||n===Fd||n===Bd||n===Vd||n===Hd){if(a=t.get("WEBGL_compressed_texture_astc"),a===null)return null;if(n===Pd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===Rd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===Dd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===Ld)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===Id)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===Od)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===zd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===kd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===Nd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===Ud)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Fd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===Bd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===Vd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===Hd)return r===Bt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===jd){if(a=t.get("EXT_texture_compression_bptc"),a===null)return null;if(n===jd)return r===Bt?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}return n===Ms?i?34042:(a=t.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):s[n]!==void 0?s[n]:null}}}class jx extends ye{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class De extends St{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Gx={type:"move"};class lc{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new De,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new De,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new M,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new M),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new De,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new M,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new M),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,i){let n=null,r=null,a=null;const o=this._targetRay,l=this._grip,h=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(o!==null&&(n=e.getPose(t.targetRaySpace,i),n!==null&&(o.matrix.fromArray(n.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),n.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(n.linearVelocity)):o.hasLinearVelocity=!1,n.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(n.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(Gx))),h&&t.hand){a=!0;for(const g of t.hand.values()){const _=e.getJointPose(g,i);if(h.joints[g.jointName]===void 0){const x=new De;x.matrixAutoUpdate=!1,x.visible=!1,h.joints[g.jointName]=x,h.add(x)}const v=h.joints[g.jointName];_!==null&&(v.matrix.fromArray(_.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),v.jointRadius=_.radius),v.visible=_!==null}const c=h.joints["index-finger-tip"],u=h.joints["thumb-tip"],p=c.position.distanceTo(u.position),m=.02,f=.005;h.inputState.pinching&&p>m+f?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!h.inputState.pinching&&p<=m-f&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else l!==null&&t.gripSpace&&(r=e.getPose(t.gripSpace,i),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));return o!==null&&(o.visible=n!==null),l!==null&&(l.visible=r!==null),h!==null&&(h.visible=a!==null),this}}class Hp extends ne{constructor(t,e,i,n,r,a,o,l,h,c){if((c=c!==void 0?c:ws)!==ws&&c!==Ss)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&c===ws&&(i=bs),i===void 0&&c===Ss&&(i=Ms),super(null,n,r,a,o,l,c,i,h),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=o!==void 0?o:Ft,this.minFilter=l!==void 0?l:Ft,this.flipY=!1,this.generateMipmaps=!1}}class Wx extends pn{constructor(t,e){super();const i=this;let n=null,r=1,a=null,o="local-floor",l=null,h=null,c=null,u=null,p=null,m=null;const f=e.getContextAttributes();let g=null,_=null;const v=[],x=new Map,y=new ye;y.layers.enable(1),y.viewport=new Lt;const b=new ye;b.layers.enable(2),b.viewport=new Lt;const S=[y,b],w=new jx;w.layers.enable(1),w.layers.enable(2);let C=null,L=null;function T(k){const X=x.get(k.inputSource);X!==void 0&&X.dispatchEvent({type:k.type,data:k.inputSource})}function E(){n.removeEventListener("select",T),n.removeEventListener("selectstart",T),n.removeEventListener("selectend",T),n.removeEventListener("squeeze",T),n.removeEventListener("squeezestart",T),n.removeEventListener("squeezeend",T),n.removeEventListener("end",E),n.removeEventListener("inputsourceschange",I),x.forEach(function(k,X){k!==void 0&&k.disconnect(X)}),x.clear(),C=null,L=null,t.setRenderTarget(g),p=null,u=null,c=null,n=null,_=null,Q.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}function I(k){const X=n.inputSources;for(let U=0;U<X.length;U++){const H=X[U].handedness==="right"?1:0;x.set(X[U],v[H])}for(let U=0;U<k.removed.length;U++){const H=k.removed[U],Z=x.get(H);Z&&(Z.dispatchEvent({type:"disconnected",data:H}),x.delete(H))}for(let U=0;U<k.added.length;U++){const H=k.added[U],Z=x.get(H);Z&&Z.dispatchEvent({type:"connected",data:H})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(k){let X=v[k];return X===void 0&&(X=new lc,v[k]=X),X.getTargetRaySpace()},this.getControllerGrip=function(k){let X=v[k];return X===void 0&&(X=new lc,v[k]=X),X.getGripSpace()},this.getHand=function(k){let X=v[k];return X===void 0&&(X=new lc,v[k]=X),X.getHandSpace()},this.setFramebufferScaleFactor=function(k){r=k,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(k){o=k,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||a},this.setReferenceSpace=function(k){l=k},this.getBaseLayer=function(){return u!==null?u:p},this.getBinding=function(){return c},this.getFrame=function(){return m},this.getSession=function(){return n},this.setSession=async function(k){if(n=k,n!==null){if(g=t.getRenderTarget(),n.addEventListener("select",T),n.addEventListener("selectstart",T),n.addEventListener("selectend",T),n.addEventListener("squeeze",T),n.addEventListener("squeezestart",T),n.addEventListener("squeezeend",T),n.addEventListener("end",E),n.addEventListener("inputsourceschange",I),f.xrCompatible!==!0&&await e.makeXRCompatible(),n.renderState.layers===void 0||t.capabilities.isWebGL2===!1){const X={antialias:n.renderState.layers!==void 0||f.antialias,alpha:f.alpha,depth:f.depth,stencil:f.stencil,framebufferScaleFactor:r};p=new XRWebGLLayer(n,e,X),n.updateRenderState({baseLayer:p}),_=new de(p.framebufferWidth,p.framebufferHeight,{format:$t,type:Vn,encoding:t.outputEncoding})}else{let X=null,U=null,H=null;f.depth&&(H=f.stencil?35056:33190,X=f.stencil?Ss:ws,U=f.stencil?Ms:bs);const Z={colorFormat:t.outputEncoding===Bt?35907:32856,depthFormat:H,scaleFactor:r};c=new XRWebGLBinding(n,e),u=c.createProjectionLayer(Z),n.updateRenderState({layers:[u]}),_=new de(u.textureWidth,u.textureHeight,{format:$t,type:Vn,depthTexture:new Hp(u.textureWidth,u.textureHeight,U,void 0,void 0,void 0,void 0,void 0,void 0,X),stencilBuffer:f.stencil,encoding:t.outputEncoding,samples:f.antialias?4:0}),t.properties.get(_).__ignoreDepthValues=u.ignoreDepthValues}_.isXRRenderTarget=!0,this.setFoveation(1),l=null,a=await n.requestReferenceSpace(o),Q.setContext(n),Q.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};const z=new M,B=new M;function O(k,X){X===null?k.matrixWorld.copy(k.matrix):k.matrixWorld.multiplyMatrices(X.matrixWorld,k.matrix),k.matrixWorldInverse.copy(k.matrixWorld).invert()}this.updateCamera=function(k){if(n===null)return;w.near=b.near=y.near=k.near,w.far=b.far=y.far=k.far,C===w.near&&L===w.far||(n.updateRenderState({depthNear:w.near,depthFar:w.far}),C=w.near,L=w.far);const X=k.parent,U=w.cameras;O(w,X);for(let Z=0;Z<U.length;Z++)O(U[Z],X);w.matrixWorld.decompose(w.position,w.quaternion,w.scale),k.position.copy(w.position),k.quaternion.copy(w.quaternion),k.scale.copy(w.scale),k.matrix.copy(w.matrix),k.matrixWorld.copy(w.matrixWorld);const H=k.children;for(let Z=0,mt=H.length;Z<mt;Z++)H[Z].updateMatrixWorld(!0);U.length===2?function(Z,mt,_t){z.setFromMatrixPosition(mt.matrixWorld),B.setFromMatrixPosition(_t.matrixWorld);const Mt=z.distanceTo(B),wt=mt.projectionMatrix.elements,R=_t.projectionMatrix.elements,A=wt[14]/(wt[10]-1),G=wt[14]/(wt[10]+1),it=(wt[9]+1)/wt[5],V=(wt[9]-1)/wt[5],P=(wt[8]-1)/wt[0],J=(R[8]+1)/R[0],N=A*P,ct=A*J,$=Mt/(-P+J),ht=$*-P;mt.matrixWorld.decompose(Z.position,Z.quaternion,Z.scale),Z.translateX(ht),Z.translateZ($),Z.matrixWorld.compose(Z.position,Z.quaternion,Z.scale),Z.matrixWorldInverse.copy(Z.matrixWorld).invert();const gt=A+$,yt=G+$,Ct=N-ht,bt=ct+(Mt-ht),kt=it*G/yt*gt,Rt=V*G/yt*gt;Z.projectionMatrix.makePerspective(Ct,bt,kt,Rt,gt,yt)}(w,y,b):w.projectionMatrix.copy(y.projectionMatrix)},this.getCamera=function(){return w},this.getFoveation=function(){return u!==null?u.fixedFoveation:p!==null?p.fixedFoveation:void 0},this.setFoveation=function(k){u!==null&&(u.fixedFoveation=k),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=k)};let F=null;const Q=new up;Q.setAnimationLoop(function(k,X){if(h=X.getViewerPose(l||a),m=X,h!==null){const H=h.views;p!==null&&(t.setRenderTargetFramebuffer(_,p.framebuffer),t.setRenderTarget(_));let Z=!1;H.length!==w.cameras.length&&(w.cameras.length=0,Z=!0);for(let mt=0;mt<H.length;mt++){const _t=H[mt];let Mt=null;if(p!==null)Mt=p.getViewport(_t);else{const R=c.getViewSubImage(u,_t);Mt=R.viewport,mt===0&&(t.setRenderTargetTextures(_,R.colorTexture,u.ignoreDepthValues?void 0:R.depthStencilTexture),t.setRenderTarget(_))}let wt=S[mt];wt===void 0&&(wt=new ye,wt.layers.enable(mt),wt.viewport=new Lt,S[mt]=wt),wt.matrix.fromArray(_t.transform.matrix),wt.projectionMatrix.fromArray(_t.projectionMatrix),wt.viewport.set(Mt.x,Mt.y,Mt.width,Mt.height),mt===0&&w.matrix.copy(wt.matrix),Z===!0&&w.cameras.push(wt)}}const U=n.inputSources;for(let H=0;H<v.length;H++){const Z=U[H],mt=x.get(Z);mt!==void 0&&mt.update(Z,X,l||a)}F&&F(k,X),m=null}),this.setAnimationLoop=function(k){F=k},this.dispose=function(){}}}function Xx(s,t){function e(i,n){i.opacity.value=n.opacity,n.color&&i.diffuse.value.copy(n.color),n.emissive&&i.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(i.map.value=n.map),n.alphaMap&&(i.alphaMap.value=n.alphaMap),n.bumpMap&&(i.bumpMap.value=n.bumpMap,i.bumpScale.value=n.bumpScale,n.side===pi&&(i.bumpScale.value*=-1)),n.displacementMap&&(i.displacementMap.value=n.displacementMap,i.displacementScale.value=n.displacementScale,i.displacementBias.value=n.displacementBias),n.emissiveMap&&(i.emissiveMap.value=n.emissiveMap),n.normalMap&&(i.normalMap.value=n.normalMap,i.normalScale.value.copy(n.normalScale),n.side===pi&&i.normalScale.value.negate()),n.specularMap&&(i.specularMap.value=n.specularMap),n.alphaTest>0&&(i.alphaTest.value=n.alphaTest);const r=t.get(n).envMap;if(r&&(i.envMap.value=r,i.flipEnvMap.value=r.isCubeTexture&&r.isRenderTargetTexture===!1?-1:1,i.reflectivity.value=n.reflectivity,i.ior.value=n.ior,i.refractionRatio.value=n.refractionRatio),n.lightMap){i.lightMap.value=n.lightMap;const l=s.physicallyCorrectLights!==!0?Math.PI:1;i.lightMapIntensity.value=n.lightMapIntensity*l}let a,o;n.aoMap&&(i.aoMap.value=n.aoMap,i.aoMapIntensity.value=n.aoMapIntensity),n.map?a=n.map:n.specularMap?a=n.specularMap:n.displacementMap?a=n.displacementMap:n.normalMap?a=n.normalMap:n.bumpMap?a=n.bumpMap:n.roughnessMap?a=n.roughnessMap:n.metalnessMap?a=n.metalnessMap:n.alphaMap?a=n.alphaMap:n.emissiveMap?a=n.emissiveMap:n.clearcoatMap?a=n.clearcoatMap:n.clearcoatNormalMap?a=n.clearcoatNormalMap:n.clearcoatRoughnessMap?a=n.clearcoatRoughnessMap:n.iridescenceMap?a=n.iridescenceMap:n.iridescenceThicknessMap?a=n.iridescenceThicknessMap:n.specularIntensityMap?a=n.specularIntensityMap:n.specularColorMap?a=n.specularColorMap:n.transmissionMap?a=n.transmissionMap:n.thicknessMap?a=n.thicknessMap:n.sheenColorMap?a=n.sheenColorMap:n.sheenRoughnessMap&&(a=n.sheenRoughnessMap),a!==void 0&&(a.isWebGLRenderTarget&&(a=a.texture),a.matrixAutoUpdate===!0&&a.updateMatrix(),i.uvTransform.value.copy(a.matrix)),n.aoMap?o=n.aoMap:n.lightMap&&(o=n.lightMap),o!==void 0&&(o.isWebGLRenderTarget&&(o=o.texture),o.matrixAutoUpdate===!0&&o.updateMatrix(),i.uv2Transform.value.copy(o.matrix))}return{refreshFogUniforms:function(i,n){i.fogColor.value.copy(n.color),n.isFog?(i.fogNear.value=n.near,i.fogFar.value=n.far):n.isFogExp2&&(i.fogDensity.value=n.density)},refreshMaterialUniforms:function(i,n,r,a,o){n.isMeshBasicMaterial||n.isMeshLambertMaterial?e(i,n):n.isMeshToonMaterial?(e(i,n),function(l,h){h.gradientMap&&(l.gradientMap.value=h.gradientMap)}(i,n)):n.isMeshPhongMaterial?(e(i,n),function(l,h){l.specular.value.copy(h.specular),l.shininess.value=Math.max(h.shininess,1e-4)}(i,n)):n.isMeshStandardMaterial?(e(i,n),function(l,h){l.roughness.value=h.roughness,l.metalness.value=h.metalness,h.roughnessMap&&(l.roughnessMap.value=h.roughnessMap),h.metalnessMap&&(l.metalnessMap.value=h.metalnessMap),t.get(h).envMap&&(l.envMapIntensity.value=h.envMapIntensity)}(i,n),n.isMeshPhysicalMaterial&&function(l,h,c){l.ior.value=h.ior,h.sheen>0&&(l.sheenColor.value.copy(h.sheenColor).multiplyScalar(h.sheen),l.sheenRoughness.value=h.sheenRoughness,h.sheenColorMap&&(l.sheenColorMap.value=h.sheenColorMap),h.sheenRoughnessMap&&(l.sheenRoughnessMap.value=h.sheenRoughnessMap)),h.clearcoat>0&&(l.clearcoat.value=h.clearcoat,l.clearcoatRoughness.value=h.clearcoatRoughness,h.clearcoatMap&&(l.clearcoatMap.value=h.clearcoatMap),h.clearcoatRoughnessMap&&(l.clearcoatRoughnessMap.value=h.clearcoatRoughnessMap),h.clearcoatNormalMap&&(l.clearcoatNormalScale.value.copy(h.clearcoatNormalScale),l.clearcoatNormalMap.value=h.clearcoatNormalMap,h.side===pi&&l.clearcoatNormalScale.value.negate())),h.iridescence>0&&(l.iridescence.value=h.iridescence,l.iridescenceIOR.value=h.iridescenceIOR,l.iridescenceThicknessMinimum.value=h.iridescenceThicknessRange[0],l.iridescenceThicknessMaximum.value=h.iridescenceThicknessRange[1],h.iridescenceMap&&(l.iridescenceMap.value=h.iridescenceMap),h.iridescenceThicknessMap&&(l.iridescenceThicknessMap.value=h.iridescenceThicknessMap)),h.transmission>0&&(l.transmission.value=h.transmission,l.transmissionSamplerMap.value=c.texture,l.transmissionSamplerSize.value.set(c.width,c.height),h.transmissionMap&&(l.transmissionMap.value=h.transmissionMap),l.thickness.value=h.thickness,h.thicknessMap&&(l.thicknessMap.value=h.thicknessMap),l.attenuationDistance.value=h.attenuationDistance,l.attenuationColor.value.copy(h.attenuationColor)),l.specularIntensity.value=h.specularIntensity,l.specularColor.value.copy(h.specularColor),h.specularIntensityMap&&(l.specularIntensityMap.value=h.specularIntensityMap),h.specularColorMap&&(l.specularColorMap.value=h.specularColorMap)}(i,n,o)):n.isMeshMatcapMaterial?(e(i,n),function(l,h){h.matcap&&(l.matcap.value=h.matcap)}(i,n)):n.isMeshDepthMaterial?e(i,n):n.isMeshDistanceMaterial?(e(i,n),function(l,h){l.referencePosition.value.copy(h.referencePosition),l.nearDistance.value=h.nearDistance,l.farDistance.value=h.farDistance}(i,n)):n.isMeshNormalMaterial?e(i,n):n.isLineBasicMaterial?(function(l,h){l.diffuse.value.copy(h.color),l.opacity.value=h.opacity}(i,n),n.isLineDashedMaterial&&function(l,h){l.dashSize.value=h.dashSize,l.totalSize.value=h.dashSize+h.gapSize,l.scale.value=h.scale}(i,n)):n.isPointsMaterial?function(l,h,c,u){l.diffuse.value.copy(h.color),l.opacity.value=h.opacity,l.size.value=h.size*c,l.scale.value=.5*u,h.map&&(l.map.value=h.map),h.alphaMap&&(l.alphaMap.value=h.alphaMap),h.alphaTest>0&&(l.alphaTest.value=h.alphaTest);let p;h.map?p=h.map:h.alphaMap&&(p=h.alphaMap),p!==void 0&&(p.matrixAutoUpdate===!0&&p.updateMatrix(),l.uvTransform.value.copy(p.matrix))}(i,n,r,a):n.isSpriteMaterial?function(l,h){l.diffuse.value.copy(h.color),l.opacity.value=h.opacity,l.rotation.value=h.rotation,h.map&&(l.map.value=h.map),h.alphaMap&&(l.alphaMap.value=h.alphaMap),h.alphaTest>0&&(l.alphaTest.value=h.alphaTest);let c;h.map?c=h.map:h.alphaMap&&(c=h.alphaMap),c!==void 0&&(c.matrixAutoUpdate===!0&&c.updateMatrix(),l.uvTransform.value.copy(c.matrix))}(i,n):n.isShadowMaterial?(i.color.value.copy(n.color),i.opacity.value=n.opacity):n.isShaderMaterial&&(n.uniformsNeedUpdate=!1)}}}function jp(s={}){this.isWebGLRenderer=!0;const t=s.canvas!==void 0?s.canvas:function(){const D=Ta("canvas");return D.style.display="block",D}(),e=s.context!==void 0?s.context:null,i=s.depth===void 0||s.depth,n=s.stencil===void 0||s.stencil,r=s.antialias!==void 0&&s.antialias,a=s.premultipliedAlpha===void 0||s.premultipliedAlpha,o=s.preserveDrawingBuffer!==void 0&&s.preserveDrawingBuffer,l=s.powerPreference!==void 0?s.powerPreference:"default",h=s.failIfMajorPerformanceCaveat!==void 0&&s.failIfMajorPerformanceCaveat;let c;c=e!==null?e.getContextAttributes().alpha:s.alpha!==void 0&&s.alpha;let u=null,p=null;const m=[],f=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=un,this.physicallyCorrectLights=!1,this.toneMapping=cn,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const g=this;let _=!1,v=0,x=0,y=null,b=-1,S=null;const w=new Lt,C=new Lt;let L=null,T=t.width,E=t.height,I=1,z=null,B=null;const O=new Lt(0,0,T,E),F=new Lt(0,0,T,E);let Q=!1;const k=new Pa;let X=!1,U=!1,H=null;const Z=new rt,mt=new j,_t=new M,Mt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function wt(){return y===null?I:1}let R,A,G,it,V,P,J,N,ct,$,ht,gt,yt,Ct,bt,kt,Rt,It,_e,on,Et,qt,Yt,ut=e;function Y_(D,q){for(let K=0;K<D.length;K++){const nt=D[K],at=t.getContext(nt,q);if(at!==null)return at}return null}try{const D={alpha:!0,depth:i,stencil:n,antialias:r,premultipliedAlpha:a,preserveDrawingBuffer:o,powerPreference:l,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${yh}`),t.addEventListener("webglcontextlost",J_,!1),t.addEventListener("webglcontextrestored",K_,!1),t.addEventListener("webglcontextcreationerror",Q_,!1),ut===null){const q=["webgl2","webgl","experimental-webgl"];if(g.isWebGL1Renderer===!0&&q.shift(),ut=Y_(q,D),ut===null)throw Y_(q)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}ut.getShaderPrecisionFormat===void 0&&(ut.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(D){throw console.error("THREE.WebGLRenderer: "+D.message),D}function Z_(){R=new yv(ut),A=new gv(ut,R,s),R.init(A),qt=new Hx(ut,R,A),G=new Bx(ut,R,A),it=new wv,V=new Px,P=new Vx(ut,R,G,V,A,qt,it),J=new vv(g),N=new xv(g),ct=new dv(ut,A),Yt=new mv(ut,R,ct,A),$=new bv(ut,ct,it,Yt),ht=new Ev(ut,$,ct,it),_e=new Cv(ut,A,P),kt=new _v(V),gt=new Ax(g,J,N,R,A,Yt,kt),yt=new Xx(g,V),Ct=new Dx,bt=new kx(R,A),It=new pv(g,J,G,ht,c,a),Rt=new Fx(g,ht,A),on=new fv(ut,R,it,A),Et=new Mv(ut,R,it,A),it.programs=gt.programs,g.capabilities=A,g.extensions=R,g.properties=V,g.renderLists=Ct,g.shadowMap=Rt,g.state=G,g.info=it}Z_();const di=new Wx(g,ut);function J_(D){D.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function K_(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1;const D=it.autoReset,q=Rt.enabled,K=Rt.autoUpdate,nt=Rt.needsUpdate,at=Rt.type;Z_(),it.autoReset=D,Rt.enabled=q,Rt.autoUpdate=K,Rt.needsUpdate=nt,Rt.type=at}function Q_(D){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",D.statusMessage)}function $_(D){const q=D.target;q.removeEventListener("dispose",$_),function(K){(function(nt){const at=V.get(nt).programs;at!==void 0&&(at.forEach(function(Tt){gt.releaseProgram(Tt)}),nt.isShaderMaterial&&gt.releaseShaderCache(nt))})(K),V.remove(K)}(q)}this.xr=di,this.getContext=function(){return ut},this.getContextAttributes=function(){return ut.getContextAttributes()},this.forceContextLoss=function(){const D=R.get("WEBGL_lose_context");D&&D.loseContext()},this.forceContextRestore=function(){const D=R.get("WEBGL_lose_context");D&&D.restoreContext()},this.getPixelRatio=function(){return I},this.setPixelRatio=function(D){D!==void 0&&(I=D,this.setSize(T,E,!1))},this.getSize=function(D){return D.set(T,E)},this.setSize=function(D,q,K){di.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(T=D,E=q,t.width=Math.floor(D*I),t.height=Math.floor(q*I),K!==!1&&(t.style.width=D+"px",t.style.height=q+"px"),this.setViewport(0,0,D,q))},this.getDrawingBufferSize=function(D){return D.set(T*I,E*I).floor()},this.setDrawingBufferSize=function(D,q,K){T=D,E=q,I=K,t.width=Math.floor(D*K),t.height=Math.floor(q*K),this.setViewport(0,0,D,q)},this.getCurrentViewport=function(D){return D.copy(w)},this.getViewport=function(D){return D.copy(O)},this.setViewport=function(D,q,K,nt){D.isVector4?O.set(D.x,D.y,D.z,D.w):O.set(D,q,K,nt),G.viewport(w.copy(O).multiplyScalar(I).floor())},this.getScissor=function(D){return D.copy(F)},this.setScissor=function(D,q,K,nt){D.isVector4?F.set(D.x,D.y,D.z,D.w):F.set(D,q,K,nt),G.scissor(C.copy(F).multiplyScalar(I).floor())},this.getScissorTest=function(){return Q},this.setScissorTest=function(D){G.setScissorTest(Q=D)},this.setOpaqueSort=function(D){z=D},this.setTransparentSort=function(D){B=D},this.getClearColor=function(D){return D.copy(It.getClearColor())},this.setClearColor=function(){It.setClearColor.apply(It,arguments)},this.getClearAlpha=function(){return It.getClearAlpha()},this.setClearAlpha=function(){It.setClearAlpha.apply(It,arguments)},this.clear=function(D=!0,q=!0,K=!0){let nt=0;D&&(nt|=16384),q&&(nt|=256),K&&(nt|=1024),ut.clear(nt)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",J_,!1),t.removeEventListener("webglcontextrestored",K_,!1),t.removeEventListener("webglcontextcreationerror",Q_,!1),Ct.dispose(),bt.dispose(),V.dispose(),J.dispose(),N.dispose(),ht.dispose(),Yt.dispose(),gt.dispose(),di.dispose(),di.removeEventListener("sessionstart",t0),di.removeEventListener("sessionend",e0),H&&(H.dispose(),H=null),rr.stop()},this.renderBufferDirect=function(D,q,K,nt,at,Tt){q===null&&(q=Mt);const Ot=at.isMesh&&at.matrixWorld.determinant()<0,At=function(Oe,Mo,ji,Dt,Pe){Mo.isScene!==!0&&(Mo=Mt),P.resetTextureUnits();const rd=Mo.fog,g2=Dt.isMeshStandardMaterial?Mo.environment:null,_2=y===null?g.outputEncoding:y.isXRRenderTarget===!0?y.texture.encoding:un,v2=(Dt.isMeshStandardMaterial?N:J).get(Dt.envMap||g2),x2=Dt.vertexColors===!0&&!!ji.attributes.color&&ji.attributes.color.itemSize===4,y2=!!Dt.normalMap&&!!ji.attributes.tangent,b2=!!ji.morphAttributes.position,M2=!!ji.morphAttributes.normal,w2=!!ji.morphAttributes.color,S2=Dt.toneMapped?g.toneMapping:cn,r0=ji.morphAttributes.position||ji.morphAttributes.normal||ji.morphAttributes.color,T2=r0!==void 0?r0.length:0,Qt=V.get(Dt),C2=p.state.lights,E2=g.extraProgramCacheKey;if(X===!0&&(U===!0||Oe!==S)){const hn=Oe===S&&Dt.id===b;kt.setState(Dt,Oe,hn)}let Un=!1;Dt.version===Qt.__version?Qt.needsLights&&Qt.lightsStateVersion!==C2.state.version||Qt.outputEncoding!==_2||Pe.isInstancedMesh&&Qt.instancing===!1?Un=!0:Pe.isInstancedMesh||Qt.instancing!==!0?Pe.isSkinnedMesh&&Qt.skinning===!1?Un=!0:Pe.isSkinnedMesh||Qt.skinning!==!0?Qt.envMap!==v2||Dt.fog===!0&&Qt.fog!==rd?Un=!0:Qt.numClippingPlanes===void 0||Qt.numClippingPlanes===kt.numPlanes&&Qt.numIntersection===kt.numIntersection?(Qt.vertexAlphas!==x2||Qt.vertexTangents!==y2||Qt.morphTargets!==b2||Qt.morphNormals!==M2||Qt.morphColors!==w2||Qt.toneMapping!==S2||A.isWebGL2===!0&&Qt.morphTargetsCount!==T2||E2!==Qt.extraProgramCacheKey)&&(Un=!0):Un=!0:Un=!0:Un=!0:(Un=!0,Qt.__version=Dt.version);let wo=Qt.currentProgram;Un===!0&&(wo=nd(Dt,Mo,Pe));let a0=!1,So=!1,ad=!1;const Je=wo.getUniforms(),To=Qt.uniforms;if(G.useProgram(wo.program)&&(a0=!0,So=!0,ad=!0),Dt.id!==b&&(b=Dt.id,So=!0),a0||S!==Oe){if(Je.setValue(ut,"projectionMatrix",Oe.projectionMatrix),A.logarithmicDepthBuffer&&Je.setValue(ut,"logDepthBufFC",2/(Math.log(Oe.far+1)/Math.LN2)),S!==Oe&&(S=Oe,So=!0,ad=!0),Dt.isShaderMaterial||Dt.isMeshPhongMaterial||Dt.isMeshToonMaterial||Dt.isMeshStandardMaterial||Dt.envMap){const hn=Je.map.cameraPosition;hn!==void 0&&hn.setValue(ut,_t.setFromMatrixPosition(Oe.matrixWorld))}(Dt.isMeshPhongMaterial||Dt.isMeshToonMaterial||Dt.isMeshLambertMaterial||Dt.isMeshBasicMaterial||Dt.isMeshStandardMaterial||Dt.isShaderMaterial)&&Je.setValue(ut,"isOrthographic",Oe.isOrthographicCamera===!0),(Dt.isMeshPhongMaterial||Dt.isMeshToonMaterial||Dt.isMeshLambertMaterial||Dt.isMeshBasicMaterial||Dt.isMeshStandardMaterial||Dt.isShaderMaterial||Dt.isShadowMaterial||Pe.isSkinnedMesh)&&Je.setValue(ut,"viewMatrix",Oe.matrixWorldInverse)}if(Pe.isSkinnedMesh){Je.setOptional(ut,Pe,"bindMatrix"),Je.setOptional(ut,Pe,"bindMatrixInverse");const hn=Pe.skeleton;hn&&(A.floatVertexTextures?(hn.boneTexture===null&&hn.computeBoneTexture(),Je.setValue(ut,"boneTexture",hn.boneTexture,P),Je.setValue(ut,"boneTextureSize",hn.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const od=ji.morphAttributes;(od.position!==void 0||od.normal!==void 0||od.color!==void 0&&A.isWebGL2===!0)&&_e.update(Pe,ji,Dt,wo),(So||Qt.receiveShadow!==Pe.receiveShadow)&&(Qt.receiveShadow=Pe.receiveShadow,Je.setValue(ut,"receiveShadow",Pe.receiveShadow)),So&&(Je.setValue(ut,"toneMappingExposure",g.toneMappingExposure),Qt.needsLights&&(Gi=ad,(ln=To).ambientLightColor.needsUpdate=Gi,ln.lightProbe.needsUpdate=Gi,ln.directionalLights.needsUpdate=Gi,ln.directionalLightShadows.needsUpdate=Gi,ln.pointLights.needsUpdate=Gi,ln.pointLightShadows.needsUpdate=Gi,ln.spotLights.needsUpdate=Gi,ln.spotLightShadows.needsUpdate=Gi,ln.rectAreaLights.needsUpdate=Gi,ln.hemisphereLights.needsUpdate=Gi),rd&&Dt.fog===!0&&yt.refreshFogUniforms(To,rd),yt.refreshMaterialUniforms(To,Dt,I,E,H),nl.upload(ut,Qt.uniformsList,To,P));var ln,Gi;return Dt.isShaderMaterial&&Dt.uniformsNeedUpdate===!0&&(nl.upload(ut,Qt.uniformsList,To,P),Dt.uniformsNeedUpdate=!1),Dt.isSpriteMaterial&&Je.setValue(ut,"center",Pe.center),Je.setValue(ut,"modelViewMatrix",Pe.modelViewMatrix),Je.setValue(ut,"normalMatrix",Pe.normalMatrix),Je.setValue(ut,"modelMatrix",Pe.matrixWorld),wo}(D,q,K,nt,at);G.setMaterial(nt,Ot);let Vt=K.index;const ge=K.attributes.position;if(Vt===null){if(ge===void 0||ge.count===0)return}else if(Vt.count===0)return;let Gt,Ut=1;nt.wireframe===!0&&(Vt=$.getWireframeAttribute(K),Ut=2),Yt.setup(at,nt,At,K,Vt);let Ae=on;Vt!==null&&(Gt=ct.get(Vt),Ae=Et,Ae.setIndex(Gt));const bo=Vt!==null?Vt.count:ge.count,Ci=K.drawRange.start*Ut,sd=K.drawRange.count*Ut,_s=Tt!==null?Tt.start*Ut:0,m2=Tt!==null?Tt.count*Ut:1/0,vh=Math.max(Ci,_s),f2=Math.min(bo,Ci+sd,_s+m2)-1,xh=Math.max(0,f2-vh+1);if(xh!==0){if(at.isMesh)nt.wireframe===!0?(G.setLineWidth(nt.wireframeLinewidth*wt()),Ae.setMode(1)):Ae.setMode(4);else if(at.isLine){let Oe=nt.linewidth;Oe===void 0&&(Oe=1),G.setLineWidth(Oe*wt()),at.isLineSegments?Ae.setMode(1):at.isLineLoop?Ae.setMode(2):Ae.setMode(3)}else at.isPoints?Ae.setMode(0):at.isSprite&&Ae.setMode(4);if(at.isInstancedMesh)Ae.renderInstances(vh,xh,at.count);else if(K.isInstancedBufferGeometry){const Oe=Math.min(K.instanceCount,K._maxInstanceCount);Ae.renderInstances(vh,xh,Oe)}else Ae.render(vh,xh)}},this.compile=function(D,q){p=bt.get(D),p.init(),f.push(p),D.traverseVisible(function(K){K.isLight&&K.layers.test(q.layers)&&(p.pushLight(K),K.castShadow&&p.pushShadow(K))}),p.setupLights(g.physicallyCorrectLights),D.traverse(function(K){const nt=K.material;if(nt)if(Array.isArray(nt))for(let at=0;at<nt.length;at++)nd(nt[at],D,K);else nd(nt,D,K)}),f.pop(),p=null};let id=null;function t0(){rr.stop()}function e0(){rr.start()}const rr=new up;function i0(D,q,K,nt){if(D.visible===!1)return;if(D.layers.test(q.layers)){if(D.isGroup)K=D.renderOrder;else if(D.isLOD)D.autoUpdate===!0&&D.update(q);else if(D.isLight)p.pushLight(D),D.castShadow&&p.pushShadow(D);else if(D.isSprite){if(!D.frustumCulled||k.intersectsSprite(D)){nt&&_t.setFromMatrixPosition(D.matrixWorld).applyMatrix4(Z);const Tt=ht.update(D),Ot=D.material;Ot.visible&&u.push(D,Tt,Ot,K,_t.z,null)}}else if((D.isMesh||D.isLine||D.isPoints)&&(D.isSkinnedMesh&&D.skeleton.frame!==it.render.frame&&(D.skeleton.update(),D.skeleton.frame=it.render.frame),!D.frustumCulled||k.intersectsObject(D))){nt&&_t.setFromMatrixPosition(D.matrixWorld).applyMatrix4(Z);const Tt=ht.update(D),Ot=D.material;if(Array.isArray(Ot)){const At=Tt.groups;for(let Vt=0,ge=At.length;Vt<ge;Vt++){const Gt=At[Vt],Ut=Ot[Gt.materialIndex];Ut&&Ut.visible&&u.push(D,Tt,Ut,K,_t.z,Gt)}}else Ot.visible&&u.push(D,Tt,Ot,K,_t.z,null)}}const at=D.children;for(let Tt=0,Ot=at.length;Tt<Ot;Tt++)i0(at[Tt],q,K,nt)}function n0(D,q,K,nt){const at=D.opaque,Tt=D.transmissive,Ot=D.transparent;p.setupLightsView(K),Tt.length>0&&function(At,Vt,ge){const Gt=A.isWebGL2;H===null&&(H=new de(1,1,{generateMipmaps:!0,type:R.has("EXT_color_buffer_half_float")?be:Vn,minFilter:ys,samples:Gt&&r===!0?4:0})),g.getDrawingBufferSize(mt),Gt?H.setSize(mt.x,mt.y):H.setSize(Oo(mt.x),Oo(mt.y));const Ut=g.getRenderTarget();g.setRenderTarget(H),g.clear();const Ae=g.toneMapping;g.toneMapping=cn,_h(At,Vt,ge),g.toneMapping=Ae,P.updateMultisampleRenderTarget(H),P.updateRenderTargetMipmap(H),g.setRenderTarget(Ut)}(at,q,K),nt&&G.viewport(w.copy(nt)),at.length>0&&_h(at,q,K),Tt.length>0&&_h(Tt,q,K),Ot.length>0&&_h(Ot,q,K),G.buffers.depth.setTest(!0),G.buffers.depth.setMask(!0),G.buffers.color.setMask(!0),G.setPolygonOffset(!1)}function _h(D,q,K){const nt=q.isScene===!0?q.overrideMaterial:null;for(let at=0,Tt=D.length;at<Tt;at++){const Ot=D[at],At=Ot.object,Vt=Ot.geometry,ge=nt===null?Ot.material:nt,Gt=Ot.group;At.layers.test(K.layers)&&p2(At,q,K,Vt,ge,Gt)}}function p2(D,q,K,nt,at,Tt){D.onBeforeRender(g,q,K,nt,at,Tt),D.modelViewMatrix.multiplyMatrices(K.matrixWorldInverse,D.matrixWorld),D.normalMatrix.getNormalMatrix(D.modelViewMatrix),at.onBeforeRender(g,q,K,nt,D,Tt),at.transparent===!0&&at.side===ce?(at.side=pi,at.needsUpdate=!0,g.renderBufferDirect(K,q,nt,at,D,Tt),at.side=Fn,at.needsUpdate=!0,g.renderBufferDirect(K,q,nt,at,D,Tt),at.side=ce):g.renderBufferDirect(K,q,nt,at,D,Tt),D.onAfterRender(g,q,K,nt,at,Tt)}function nd(D,q,K){q.isScene!==!0&&(q=Mt);const nt=V.get(D),at=p.state.lights,Tt=p.state.shadowsArray,Ot=at.state.version,At=gt.getParameters(D,at.state,Tt,q,K),Vt=gt.getProgramCacheKey(At);let ge=nt.programs;nt.environment=D.isMeshStandardMaterial?q.environment:null,nt.fog=q.fog,nt.envMap=(D.isMeshStandardMaterial?N:J).get(D.envMap||nt.environment),ge===void 0&&(D.addEventListener("dispose",$_),ge=new Map,nt.programs=ge);let Gt=ge.get(Vt);if(Gt!==void 0){if(nt.currentProgram===Gt&&nt.lightsStateVersion===Ot)return s0(D,At),Gt}else At.uniforms=gt.getUniforms(D),D.onBuild(K,At,g),D.onBeforeCompile(At,g),Gt=gt.acquireProgram(At,Vt),ge.set(Vt,Gt),nt.uniforms=At.uniforms;const Ut=nt.uniforms;(D.isShaderMaterial||D.isRawShaderMaterial)&&D.clipping!==!0||(Ut.clippingPlanes=kt.uniform),s0(D,At),nt.needsLights=function(Ci){return Ci.isMeshLambertMaterial||Ci.isMeshToonMaterial||Ci.isMeshPhongMaterial||Ci.isMeshStandardMaterial||Ci.isShadowMaterial||Ci.isShaderMaterial&&Ci.lights===!0}(D),nt.lightsStateVersion=Ot,nt.needsLights&&(Ut.ambientLightColor.value=at.state.ambient,Ut.lightProbe.value=at.state.probe,Ut.directionalLights.value=at.state.directional,Ut.directionalLightShadows.value=at.state.directionalShadow,Ut.spotLights.value=at.state.spot,Ut.spotLightShadows.value=at.state.spotShadow,Ut.rectAreaLights.value=at.state.rectArea,Ut.ltc_1.value=at.state.rectAreaLTC1,Ut.ltc_2.value=at.state.rectAreaLTC2,Ut.pointLights.value=at.state.point,Ut.pointLightShadows.value=at.state.pointShadow,Ut.hemisphereLights.value=at.state.hemi,Ut.directionalShadowMap.value=at.state.directionalShadowMap,Ut.directionalShadowMatrix.value=at.state.directionalShadowMatrix,Ut.spotShadowMap.value=at.state.spotShadowMap,Ut.spotShadowMatrix.value=at.state.spotShadowMatrix,Ut.pointShadowMap.value=at.state.pointShadowMap,Ut.pointShadowMatrix.value=at.state.pointShadowMatrix);const Ae=Gt.getUniforms(),bo=nl.seqWithValue(Ae.seq,Ut);return nt.currentProgram=Gt,nt.uniformsList=bo,Gt}function s0(D,q){const K=V.get(D);K.outputEncoding=q.outputEncoding,K.instancing=q.instancing,K.skinning=q.skinning,K.morphTargets=q.morphTargets,K.morphNormals=q.morphNormals,K.morphColors=q.morphColors,K.morphTargetsCount=q.morphTargetsCount,K.numClippingPlanes=q.numClippingPlanes,K.numIntersection=q.numClipIntersection,K.vertexAlphas=q.vertexAlphas,K.vertexTangents=q.vertexTangents,K.toneMapping=q.toneMapping,K.extraProgramCacheKey=q.extraProgramCacheKey}rr.setAnimationLoop(function(D){id&&id(D)}),typeof self<"u"&&rr.setContext(self),this.setAnimationLoop=function(D){id=D,di.setAnimationLoop(D),D===null?rr.stop():rr.start()},di.addEventListener("sessionstart",t0),di.addEventListener("sessionend",e0),this.render=function(D,q){if(q!==void 0&&q.isCamera!==!0)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(_===!0)return;D.autoUpdate===!0&&D.updateMatrixWorld(),q.parent===null&&q.updateMatrixWorld(),di.enabled===!0&&di.isPresenting===!0&&(di.cameraAutoUpdate===!0&&di.updateCamera(q),q=di.getCamera()),D.isScene===!0&&D.onBeforeRender(g,D,q,y),p=bt.get(D,f.length),p.init(),f.push(p),Z.multiplyMatrices(q.projectionMatrix,q.matrixWorldInverse),k.setFromProjectionMatrix(Z),U=this.localClippingEnabled,X=kt.init(this.clippingPlanes,U,q),u=Ct.get(D,m.length),u.init(),m.push(u),i0(D,q,0,g.sortObjects),u.finish(),g.sortObjects===!0&&u.sort(z,B),X===!0&&kt.beginShadows();const K=p.state.shadowsArray;if(Rt.render(K,D,q),X===!0&&kt.endShadows(),this.info.autoReset===!0&&this.info.reset(),It.render(u,D),p.setupLights(g.physicallyCorrectLights),q.isArrayCamera){const nt=q.cameras;for(let at=0,Tt=nt.length;at<Tt;at++){const Ot=nt[at];n0(u,D,Ot,Ot.viewport)}}else n0(u,D,q);y!==null&&(P.updateMultisampleRenderTarget(y),P.updateRenderTargetMipmap(y)),D.isScene===!0&&D.onAfterRender(g,D,q),Yt.resetDefaultState(),b=-1,S=null,f.pop(),p=f.length>0?f[f.length-1]:null,m.pop(),u=m.length>0?m[m.length-1]:null},this.getActiveCubeFace=function(){return v},this.getActiveMipmapLevel=function(){return x},this.getRenderTarget=function(){return y},this.setRenderTargetTextures=function(D,q,K){V.get(D.texture).__webglTexture=q,V.get(D.depthTexture).__webglTexture=K;const nt=V.get(D);nt.__hasExternalTextures=!0,nt.__hasExternalTextures&&(nt.__autoAllocateDepthBuffer=K===void 0,nt.__autoAllocateDepthBuffer||R.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),nt.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(D,q){const K=V.get(D);K.__webglFramebuffer=q,K.__useDefaultFramebuffer=q===void 0},this.setRenderTarget=function(D,q=0,K=0){y=D,v=q,x=K;let nt=!0;if(D){const At=V.get(D);At.__useDefaultFramebuffer!==void 0?(G.bindFramebuffer(36160,null),nt=!1):At.__webglFramebuffer===void 0?P.setupRenderTarget(D):At.__hasExternalTextures&&P.rebindTextures(D,V.get(D.texture).__webglTexture,V.get(D.depthTexture).__webglTexture)}let at=null,Tt=!1,Ot=!1;if(D){const At=D.texture;(At.isData3DTexture||At.isDataArrayTexture)&&(Ot=!0);const Vt=V.get(D).__webglFramebuffer;D.isWebGLCubeRenderTarget?(at=Vt[q],Tt=!0):at=A.isWebGL2&&D.samples>0&&P.useMultisampledRTT(D)===!1?V.get(D).__webglMultisampledFramebuffer:Vt,w.copy(D.viewport),C.copy(D.scissor),L=D.scissorTest}else w.copy(O).multiplyScalar(I).floor(),C.copy(F).multiplyScalar(I).floor(),L=Q;if(G.bindFramebuffer(36160,at)&&A.drawBuffers&&nt&&G.drawBuffers(D,at),G.viewport(w),G.scissor(C),G.setScissorTest(L),Tt){const At=V.get(D.texture);ut.framebufferTexture2D(36160,36064,34069+q,At.__webglTexture,K)}else if(Ot){const At=V.get(D.texture),Vt=q||0;ut.framebufferTextureLayer(36160,36064,At.__webglTexture,K||0,Vt)}b=-1},this.readRenderTargetPixels=function(D,q,K,nt,at,Tt,Ot){if(!D||!D.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let At=V.get(D).__webglFramebuffer;if(D.isWebGLCubeRenderTarget&&Ot!==void 0&&(At=At[Ot]),At){G.bindFramebuffer(36160,At);try{const Vt=D.texture,ge=Vt.format,Gt=Vt.type;if(ge!==$t&&qt.convert(ge)!==ut.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const Ut=Gt===be&&(R.has("EXT_color_buffer_half_float")||A.isWebGL2&&R.has("EXT_color_buffer_float"));if(!(Gt===Vn||qt.convert(Gt)===ut.getParameter(35738)||Gt===Ve&&(A.isWebGL2||R.has("OES_texture_float")||R.has("WEBGL_color_buffer_float"))||Ut))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");q>=0&&q<=D.width-nt&&K>=0&&K<=D.height-at&&ut.readPixels(q,K,nt,at,qt.convert(ge),qt.convert(Gt),Tt)}finally{const Vt=y!==null?V.get(y).__webglFramebuffer:null;G.bindFramebuffer(36160,Vt)}}},this.copyFramebufferToTexture=function(D,q,K=0){const nt=Math.pow(2,-K),at=Math.floor(q.image.width*nt),Tt=Math.floor(q.image.height*nt);P.setTexture2D(q,0),ut.copyTexSubImage2D(3553,K,0,0,D.x,D.y,at,Tt),G.unbindTexture()},this.copyTextureToTexture=function(D,q,K,nt=0){const at=q.image.width,Tt=q.image.height,Ot=qt.convert(K.format),At=qt.convert(K.type);P.setTexture2D(K,0),ut.pixelStorei(37440,K.flipY),ut.pixelStorei(37441,K.premultiplyAlpha),ut.pixelStorei(3317,K.unpackAlignment),q.isDataTexture?ut.texSubImage2D(3553,nt,D.x,D.y,at,Tt,Ot,At,q.image.data):q.isCompressedTexture?ut.compressedTexSubImage2D(3553,nt,D.x,D.y,q.mipmaps[0].width,q.mipmaps[0].height,Ot,q.mipmaps[0].data):ut.texSubImage2D(3553,nt,D.x,D.y,Ot,At,q.image),nt===0&&K.generateMipmaps&&ut.generateMipmap(3553),G.unbindTexture()},this.copyTextureToTexture3D=function(D,q,K,nt,at=0){if(g.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const Tt=D.max.x-D.min.x+1,Ot=D.max.y-D.min.y+1,At=D.max.z-D.min.z+1,Vt=qt.convert(nt.format),ge=qt.convert(nt.type);let Gt;if(nt.isData3DTexture)P.setTexture3D(nt,0),Gt=32879;else{if(!nt.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");P.setTexture2DArray(nt,0),Gt=35866}ut.pixelStorei(37440,nt.flipY),ut.pixelStorei(37441,nt.premultiplyAlpha),ut.pixelStorei(3317,nt.unpackAlignment);const Ut=ut.getParameter(3314),Ae=ut.getParameter(32878),bo=ut.getParameter(3316),Ci=ut.getParameter(3315),sd=ut.getParameter(32877),_s=K.isCompressedTexture?K.mipmaps[0]:K.image;ut.pixelStorei(3314,_s.width),ut.pixelStorei(32878,_s.height),ut.pixelStorei(3316,D.min.x),ut.pixelStorei(3315,D.min.y),ut.pixelStorei(32877,D.min.z),K.isDataTexture||K.isData3DTexture?ut.texSubImage3D(Gt,at,q.x,q.y,q.z,Tt,Ot,At,Vt,ge,_s.data):K.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ut.compressedTexSubImage3D(Gt,at,q.x,q.y,q.z,Tt,Ot,At,Vt,_s.data)):ut.texSubImage3D(Gt,at,q.x,q.y,q.z,Tt,Ot,At,Vt,ge,_s),ut.pixelStorei(3314,Ut),ut.pixelStorei(32878,Ae),ut.pixelStorei(3316,bo),ut.pixelStorei(3315,Ci),ut.pixelStorei(32877,sd),at===0&&nt.generateMipmaps&&ut.generateMipmap(Gt),G.unbindTexture()},this.initTexture=function(D){P.setTexture2D(D,0),G.unbindTexture()},this.resetState=function(){v=0,x=0,y=null,G.reset(),Yt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}(class extends jp{}).prototype.isWebGL1Renderer=!0;class hc{constructor(t,e=1,i=1e3){this.isFog=!0,this.name="",this.color=new tt(t),this.near=e,this.far=i}clone(){return new hc(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class Gp extends St{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}class Wp{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=pr,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ei()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let n=0,r=this.stride;n<r;n++)this.array[t+n]=e.array[i+n];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ei()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ei()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const We=new M;class za{constructor(t,e,i,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=n===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)We.fromBufferAttribute(this,e),We.applyMatrix4(t),this.setXYZ(e,We.x,We.y,We.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)We.fromBufferAttribute(this,e),We.applyNormalMatrix(t),this.setXYZ(e,We.x,We.y,We.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)We.fromBufferAttribute(this,e),We.transformDirection(t),this.setXYZ(e,We.x,We.y,We.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this}setXYZW(t,e,i,n,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this.data.array[t+3]=r,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const n=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[n+r])}return new se(new this.array.constructor(e),this.itemSize,this.normalized)}return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new za(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const n=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[n+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const Xp=new M,qp=new Lt,Yp=new Lt,qx=new M,Zp=new rt;class Yx extends lt{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new rt,this.bindMatrixInverse=new rt}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Lt,e=this.geometry.attributes.skinWeight;for(let i=0,n=e.count;i<n;i++){t.fromBufferAttribute(e,i);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const i=this.skeleton,n=this.geometry;qp.fromBufferAttribute(n.attributes.skinIndex,t),Yp.fromBufferAttribute(n.attributes.skinWeight,t),Xp.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const a=Yp.getComponent(r);if(a!==0){const o=qp.getComponent(r);Zp.multiplyMatrices(i.bones[o].matrixWorld,i.boneInverses[o]),e.addScaledVector(qx.copy(Xp).applyMatrix4(Zp),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}class Jp extends St{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Dr extends ne{constructor(t=null,e=1,i=1,n,r,a,o,l,h=Ft,c=Ft,u,p){super(null,a,o,l,h,c,n,r,u,p),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Kp=new rt,Zx=new rt;class cc{constructor(t=[],e=[]){this.uuid=Ei(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),e.length===0)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,n=this.bones.length;i<n;i++)this.boneInverses.push(new rt)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const i=new rt;this.bones[t]&&i.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&i.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const t=this.bones,e=this.boneInverses,i=this.boneMatrices,n=this.boneTexture;for(let r=0,a=t.length;r<a;r++){const o=t[r]?t[r].matrixWorld:Zx;Kp.multiplyMatrices(o,e[r]),Kp.toArray(i,16*r)}n!==null&&(n.needsUpdate=!0)}clone(){return new cc(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=Xd(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const i=new Dr(e,t,t,$t,Ve);return i.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=i,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,i=this.bones.length;e<i;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let i=0,n=t.bones.length;i<n;i++){const r=t.bones[i];let a=e[r];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new Jp),this.bones.push(a),this.boneInverses.push(new rt().fromArray(t.boneInverses[i]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,i=this.boneInverses;for(let n=0,r=e.length;n<r;n++){const a=e[n];t.bones.push(a.uuid);const o=i[n];t.boneInverses.push(o.toArray())}return t}}class Xi extends se{constructor(t,e,i,n=1){typeof i=="number"&&(n=i,i=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const Qp=new rt,$p=new rt,sl=[],ka=new lt;class tm extends lt{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Xi(new Float32Array(16*i),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const i=this.matrixWorld,n=this.count;if(ka.geometry=this.geometry,ka.material=this.material,ka.material!==void 0)for(let r=0;r<n;r++){this.getMatrixAt(r,Qp),$p.multiplyMatrices(i,Qp),ka.matrixWorld=$p,ka.raycast(t,sl);for(let a=0,o=sl.length;a<o;a++){const l=sl[a];l.instanceId=r,l.object=this,e.push(l)}sl.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Xi(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class Is extends ve{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new tt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const em=new M,im=new M,nm=new rt,uc=new vr,rl=new mi;class Li extends St{constructor(t=new Pt,e=new Is){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[0];for(let n=1,r=e.count;n<r;n++)em.fromBufferAttribute(e,n-1),im.fromBufferAttribute(e,n),i[n]=i[n-1],i[n]+=em.distanceTo(im);t.setAttribute("lineDistance",new et(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,r=t.params.Line.threshold,a=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),rl.copy(i.boundingSphere),rl.applyMatrix4(n),rl.radius+=r,t.ray.intersectsSphere(rl)===!1)return;nm.copy(n).invert(),uc.copy(t.ray).applyMatrix4(nm);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,h=new M,c=new M,u=new M,p=new M,m=this.isLineSegments?2:1,f=i.index,g=i.attributes.position;if(f!==null)for(let _=Math.max(0,a.start),v=Math.min(f.count,a.start+a.count)-1;_<v;_+=m){const x=f.getX(_),y=f.getX(_+1);if(h.fromBufferAttribute(g,x),c.fromBufferAttribute(g,y),uc.distanceSqToSegment(h,c,p,u)>l)continue;p.applyMatrix4(this.matrixWorld);const b=t.ray.origin.distanceTo(p);b<t.near||b>t.far||e.push({distance:b,point:u.clone().applyMatrix4(this.matrixWorld),index:_,face:null,faceIndex:null,object:this})}else for(let _=Math.max(0,a.start),v=Math.min(g.count,a.start+a.count)-1;_<v;_+=m){if(h.fromBufferAttribute(g,_),c.fromBufferAttribute(g,_+1),uc.distanceSqToSegment(h,c,p,u)>l)continue;p.applyMatrix4(this.matrixWorld);const x=t.ray.origin.distanceTo(p);x<t.near||x>t.far||e.push({distance:x,point:u.clone().applyMatrix4(this.matrixWorld),index:_,face:null,faceIndex:null,object:this})}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=i.length;n<r;n++){const a=i[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}}const sm=new M,rm=new M;class dc extends Li{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[];for(let n=0,r=e.count;n<r;n+=2)sm.fromBufferAttribute(e,n),rm.fromBufferAttribute(e,n+1),i[n]=n===0?0:i[n-1],i[n+1]=i[n]+sm.distanceTo(rm);t.setAttribute("lineDistance",new et(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Jx extends Li{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class Na extends ve{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new tt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const am=new rt,pc=new vr,al=new mi,ol=new M;class ll extends St{constructor(t=new Pt,e=new Na){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,r=t.params.Points.threshold,a=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),al.copy(i.boundingSphere),al.applyMatrix4(n),al.radius+=r,t.ray.intersectsSphere(al)===!1)return;am.copy(n).invert(),pc.copy(t.ray).applyMatrix4(am);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,h=i.index,c=i.attributes.position;if(h!==null)for(let u=Math.max(0,a.start),p=Math.min(h.count,a.start+a.count);u<p;u++){const m=h.getX(u);ol.fromBufferAttribute(c,m),om(ol,m,l,n,t,e,this)}else for(let u=Math.max(0,a.start),p=Math.min(c.count,a.start+a.count);u<p;u++)ol.fromBufferAttribute(c,u),om(ol,u,l,n,t,e,this)}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=i.length;n<r;n++){const a=i[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}}function om(s,t,e,i,n,r,a){const o=pc.distanceSqToPoint(s);if(o<e){const l=new M;pc.closestPointToPoint(s,l),l.applyMatrix4(i);const h=n.ray.origin.distanceTo(l);if(h<n.near||h>n.far)return;r.push({distance:h,distanceToRay:Math.sqrt(o),point:l,index:t,face:null,object:a})}}class lm extends ne{constructor(t,e,i){super({width:t,height:e}),this.isFramebufferTexture=!0,this.format=i,this.magFilter=Ft,this.minFilter=Ft,this.generateMipmaps=!1,this.needsUpdate=!0}}class Le extends ne{constructor(t,e,i,n,r,a,o,l,h){super(t,e,i,n,r,a,o,l,h),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Ue extends Pt{constructor(t=1,e=1,i=1,n=8,r=1,a=!1,o=0,l=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:i,radialSegments:n,heightSegments:r,openEnded:a,thetaStart:o,thetaLength:l};const h=this;n=Math.floor(n),r=Math.floor(r);const c=[],u=[],p=[],m=[];let f=0;const g=[],_=i/2;let v=0;function x(y){const b=f,S=new j,w=new M;let C=0;const L=y===!0?t:e,T=y===!0?1:-1;for(let I=1;I<=n;I++)u.push(0,_*T,0),p.push(0,T,0),m.push(.5,.5),f++;const E=f;for(let I=0;I<=n;I++){const z=I/n*l+o,B=Math.cos(z),O=Math.sin(z);w.x=L*O,w.y=_*T,w.z=L*B,u.push(w.x,w.y,w.z),p.push(0,T,0),S.x=.5*B+.5,S.y=.5*O*T+.5,m.push(S.x,S.y),f++}for(let I=0;I<n;I++){const z=b+I,B=E+I;y===!0?c.push(B,B+1,z):c.push(B+1,B,z),C+=3}h.addGroup(v,C,y===!0?1:2),v+=C}(function(){const y=new M,b=new M;let S=0;const w=(e-t)/i;for(let C=0;C<=r;C++){const L=[],T=C/r,E=T*(e-t)+t;for(let I=0;I<=n;I++){const z=I/n,B=z*l+o,O=Math.sin(B),F=Math.cos(B);b.x=E*O,b.y=-T*i+_,b.z=E*F,u.push(b.x,b.y,b.z),y.set(O,w,F).normalize(),p.push(y.x,y.y,y.z),m.push(z,1-T),L.push(f++)}g.push(L)}for(let C=0;C<n;C++)for(let L=0;L<r;L++){const T=g[L][C],E=g[L+1][C],I=g[L+1][C+1],z=g[L][C+1];c.push(T,E,z),c.push(E,I,z),S+=6}h.addGroup(v,S,0),v+=S})(),a===!1&&(t>0&&x(!0),e>0&&x(!1)),this.setIndex(c),this.setAttribute("position",new et(u,3)),this.setAttribute("normal",new et(p,3)),this.setAttribute("uv",new et(m,2))}static fromJSON(t){return new Ue(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class mc extends Pt{constructor(t=[],e=[],i=1,n=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:i,detail:n};const r=[],a=[];function o(p,m,f,g){const _=g+1,v=[];for(let x=0;x<=_;x++){v[x]=[];const y=p.clone().lerp(f,x/_),b=m.clone().lerp(f,x/_),S=_-x;for(let w=0;w<=S;w++)v[x][w]=w===0&&x===_?y:y.clone().lerp(b,w/S)}for(let x=0;x<_;x++)for(let y=0;y<2*(_-x)-1;y++){const b=Math.floor(y/2);y%2==0?(l(v[x][b+1]),l(v[x+1][b]),l(v[x][b])):(l(v[x][b+1]),l(v[x+1][b+1]),l(v[x+1][b]))}}function l(p){r.push(p.x,p.y,p.z)}function h(p,m){const f=3*p;m.x=t[f+0],m.y=t[f+1],m.z=t[f+2]}function c(p,m,f,g){g<0&&p.x===1&&(a[m]=p.x-1),f.x===0&&f.z===0&&(a[m]=g/2/Math.PI+.5)}function u(p){return Math.atan2(p.z,-p.x)}(function(p){const m=new M,f=new M,g=new M;for(let _=0;_<e.length;_+=3)h(e[_+0],m),h(e[_+1],f),h(e[_+2],g),o(m,f,g,p)})(n),function(p){const m=new M;for(let f=0;f<r.length;f+=3)m.x=r[f+0],m.y=r[f+1],m.z=r[f+2],m.normalize().multiplyScalar(p),r[f+0]=m.x,r[f+1]=m.y,r[f+2]=m.z}(i),function(){const p=new M;for(let f=0;f<r.length;f+=3){p.x=r[f+0],p.y=r[f+1],p.z=r[f+2];const g=u(p)/2/Math.PI+.5,_=(m=p,Math.atan2(-m.y,Math.sqrt(m.x*m.x+m.z*m.z))/Math.PI+.5);a.push(g,1-_)}var m;(function(){const f=new M,g=new M,_=new M,v=new M,x=new j,y=new j,b=new j;for(let S=0,w=0;S<r.length;S+=9,w+=6){f.set(r[S+0],r[S+1],r[S+2]),g.set(r[S+3],r[S+4],r[S+5]),_.set(r[S+6],r[S+7],r[S+8]),x.set(a[w+0],a[w+1]),y.set(a[w+2],a[w+3]),b.set(a[w+4],a[w+5]),v.copy(f).add(g).add(_).divideScalar(3);const C=u(v);c(x,w+0,f,C),c(y,w+2,g,C),c(b,w+4,_,C)}})(),function(){for(let f=0;f<a.length;f+=6){const g=a[f+0],_=a[f+2],v=a[f+4],x=Math.max(g,_,v),y=Math.min(g,_,v);x>.9&&y<.1&&(g<.2&&(a[f+0]+=1),_<.2&&(a[f+2]+=1),v<.2&&(a[f+4]+=1))}}()}(),this.setAttribute("position",new et(r,3)),this.setAttribute("normal",new et(r.slice(),3)),this.setAttribute("uv",new et(a,2)),n===0?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(t){return new mc(t.vertices,t.indices,t.radius,t.details)}}class Lr extends mc{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Lr(t.radius,t.detail)}}class Os extends Pt{constructor(t=1,e=32,i=16,n=0,r=2*Math.PI,a=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:n,phiLength:r,thetaStart:a,thetaLength:o},e=Math.max(3,Math.floor(e)),i=Math.max(2,Math.floor(i));const l=Math.min(a+o,Math.PI);let h=0;const c=[],u=new M,p=new M,m=[],f=[],g=[],_=[];for(let v=0;v<=i;v++){const x=[],y=v/i;let b=0;v==0&&a==0?b=.5/e:v==i&&l==Math.PI&&(b=-.5/e);for(let S=0;S<=e;S++){const w=S/e;u.x=-t*Math.cos(n+w*r)*Math.sin(a+y*o),u.y=t*Math.cos(a+y*o),u.z=t*Math.sin(n+w*r)*Math.sin(a+y*o),f.push(u.x,u.y,u.z),p.copy(u).normalize(),g.push(p.x,p.y,p.z),_.push(w+b,1-y),x.push(h++)}c.push(x)}for(let v=0;v<i;v++)for(let x=0;x<e;x++){const y=c[v][x+1],b=c[v][x],S=c[v+1][x],w=c[v+1][x+1];(v!==0||a>0)&&m.push(y,b,w),(v!==i-1||l<Math.PI)&&m.push(b,S,w)}this.setIndex(m),this.setAttribute("position",new et(f,3)),this.setAttribute("normal",new et(g,3)),this.setAttribute("uv",new et(_,2))}static fromJSON(t){return new Os(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class zs extends Pt{constructor(t=1,e=.4,i=8,n=6,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:i,tubularSegments:n,arc:r},i=Math.floor(i),n=Math.floor(n);const a=[],o=[],l=[],h=[],c=new M,u=new M,p=new M;for(let m=0;m<=i;m++)for(let f=0;f<=n;f++){const g=f/n*r,_=m/i*Math.PI*2;u.x=(t+e*Math.cos(_))*Math.cos(g),u.y=(t+e*Math.cos(_))*Math.sin(g),u.z=e*Math.sin(_),o.push(u.x,u.y,u.z),c.x=t*Math.cos(g),c.y=t*Math.sin(g),p.subVectors(u,c).normalize(),l.push(p.x,p.y,p.z),h.push(f/n),h.push(m/i)}for(let m=1;m<=i;m++)for(let f=1;f<=n;f++){const g=(n+1)*m+f-1,_=(n+1)*(m-1)+f-1,v=(n+1)*(m-1)+f,x=(n+1)*m+f;a.push(g,_,x),a.push(_,v,x)}this.setIndex(a),this.setAttribute("position",new et(o,3)),this.setAttribute("normal",new et(l,3)),this.setAttribute("uv",new et(h,2))}static fromJSON(t){return new zs(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class hl extends Zt{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class yn extends ve{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new tt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new tt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Hn,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Jn extends yn{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new j(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ke(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new tt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new tt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new tt(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class fc extends ve{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new tt(16777215),this.specular=new tt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new tt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Hn,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ro,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}const Kx={ShadowMaterial:class extends ve{constructor(s){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new tt(0),this.transparent=!0,this.fog=!0,this.setValues(s)}copy(s){return super.copy(s),this.color.copy(s.color),this.fog=s.fog,this}},SpriteMaterial:class extends ve{constructor(s){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new tt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(s)}copy(s){return super.copy(s),this.color.copy(s.color),this.map=s.map,this.alphaMap=s.alphaMap,this.rotation=s.rotation,this.sizeAttenuation=s.sizeAttenuation,this.fog=s.fog,this}},RawShaderMaterial:hl,ShaderMaterial:Zt,PointsMaterial:Na,MeshPhysicalMaterial:Jn,MeshStandardMaterial:yn,MeshPhongMaterial:fc,MeshToonMaterial:class extends ve{constructor(s){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new tt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new tt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Hn,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(s)}copy(s){return super.copy(s),this.color.copy(s.color),this.map=s.map,this.gradientMap=s.gradientMap,this.lightMap=s.lightMap,this.lightMapIntensity=s.lightMapIntensity,this.aoMap=s.aoMap,this.aoMapIntensity=s.aoMapIntensity,this.emissive.copy(s.emissive),this.emissiveMap=s.emissiveMap,this.emissiveIntensity=s.emissiveIntensity,this.bumpMap=s.bumpMap,this.bumpScale=s.bumpScale,this.normalMap=s.normalMap,this.normalMapType=s.normalMapType,this.normalScale.copy(s.normalScale),this.displacementMap=s.displacementMap,this.displacementScale=s.displacementScale,this.displacementBias=s.displacementBias,this.alphaMap=s.alphaMap,this.wireframe=s.wireframe,this.wireframeLinewidth=s.wireframeLinewidth,this.wireframeLinecap=s.wireframeLinecap,this.wireframeLinejoin=s.wireframeLinejoin,this.fog=s.fog,this}},MeshNormalMaterial:class extends ve{constructor(s){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Hn,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(s)}copy(s){return super.copy(s),this.bumpMap=s.bumpMap,this.bumpScale=s.bumpScale,this.normalMap=s.normalMap,this.normalMapType=s.normalMapType,this.normalScale.copy(s.normalScale),this.displacementMap=s.displacementMap,this.displacementScale=s.displacementScale,this.displacementBias=s.displacementBias,this.wireframe=s.wireframe,this.wireframeLinewidth=s.wireframeLinewidth,this.flatShading=s.flatShading,this}},MeshLambertMaterial:class extends ve{constructor(s){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new tt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new tt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ro,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(s)}copy(s){return super.copy(s),this.color.copy(s.color),this.map=s.map,this.lightMap=s.lightMap,this.lightMapIntensity=s.lightMapIntensity,this.aoMap=s.aoMap,this.aoMapIntensity=s.aoMapIntensity,this.emissive.copy(s.emissive),this.emissiveMap=s.emissiveMap,this.emissiveIntensity=s.emissiveIntensity,this.specularMap=s.specularMap,this.alphaMap=s.alphaMap,this.envMap=s.envMap,this.combine=s.combine,this.reflectivity=s.reflectivity,this.refractionRatio=s.refractionRatio,this.wireframe=s.wireframe,this.wireframeLinewidth=s.wireframeLinewidth,this.wireframeLinecap=s.wireframeLinecap,this.wireframeLinejoin=s.wireframeLinejoin,this.fog=s.fog,this}},MeshDepthMaterial:Bp,MeshDistanceMaterial:Vp,MeshBasicMaterial:ae,MeshMatcapMaterial:class extends ve{constructor(s){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new tt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Hn,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(s)}copy(s){return super.copy(s),this.defines={MATCAP:""},this.color.copy(s.color),this.matcap=s.matcap,this.map=s.map,this.bumpMap=s.bumpMap,this.bumpScale=s.bumpScale,this.normalMap=s.normalMap,this.normalMapType=s.normalMapType,this.normalScale.copy(s.normalScale),this.displacementMap=s.displacementMap,this.displacementScale=s.displacementScale,this.displacementBias=s.displacementBias,this.alphaMap=s.alphaMap,this.flatShading=s.flatShading,this.fog=s.fog,this}},LineDashedMaterial:class extends Is{constructor(s){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(s)}copy(s){return super.copy(s),this.scale=s.scale,this.dashSize=s.dashSize,this.gapSize=s.gapSize,this}},LineBasicMaterial:Is,Material:ve};ve.fromType=function(s){return new Kx[s]};const le={arraySlice:function(s,t,e){return le.isTypedArray(s)?new s.constructor(s.subarray(t,e!==void 0?e:s.length)):s.slice(t,e)},convertArray:function(s,t,e){return!s||!e&&s.constructor===t?s:typeof t.BYTES_PER_ELEMENT=="number"?new t(s):Array.prototype.slice.call(s)},isTypedArray:function(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)},getKeyframeOrder:function(s){const t=s.length,e=new Array(t);for(let i=0;i!==t;++i)e[i]=i;return e.sort(function(i,n){return s[i]-s[n]}),e},sortedArray:function(s,t,e){const i=s.length,n=new s.constructor(i);for(let r=0,a=0;a!==i;++r){const o=e[r]*t;for(let l=0;l!==t;++l)n[a++]=s[o+l]}return n},flattenJSON:function(s,t,e,i){let n=1,r=s[0];for(;r!==void 0&&r[i]===void 0;)r=s[n++];if(r===void 0)return;let a=r[i];if(a!==void 0)if(Array.isArray(a))do a=r[i],a!==void 0&&(t.push(r.time),e.push.apply(e,a)),r=s[n++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[i],a!==void 0&&(t.push(r.time),a.toArray(e,e.length)),r=s[n++];while(r!==void 0);else do a=r[i],a!==void 0&&(t.push(r.time),e.push(a)),r=s[n++];while(r!==void 0)},subclip:function(s,t,e,i,n=30){const r=s.clone();r.name=t;const a=[];for(let l=0;l<r.tracks.length;++l){const h=r.tracks[l],c=h.getValueSize(),u=[],p=[];for(let m=0;m<h.times.length;++m){const f=h.times[m]*n;if(!(f<e||f>=i)){u.push(h.times[m]);for(let g=0;g<c;++g)p.push(h.values[m*c+g])}}u.length!==0&&(h.times=le.convertArray(u,h.times.constructor),h.values=le.convertArray(p,h.values.constructor),a.push(h))}r.tracks=a;let o=1/0;for(let l=0;l<r.tracks.length;++l)o>r.tracks[l].times[0]&&(o=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*o);return r.resetDuration(),r},makeClipAdditive:function(s,t=0,e=s,i=30){i<=0&&(i=30);const n=e.tracks.length,r=t/i;for(let a=0;a<n;++a){const o=e.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const h=s.tracks.find(function(v){return v.name===o.name&&v.ValueTypeName===l});if(h===void 0)continue;let c=0;const u=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);let p=0;const m=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(p=m/3);const f=o.times.length-1;let g;if(r<=o.times[0]){const v=c,x=u-c;g=le.arraySlice(o.values,v,x)}else if(r>=o.times[f]){const v=f*u+c,x=v+u-c;g=le.arraySlice(o.values,v,x)}else{const v=o.createInterpolant(),x=c,y=u-c;v.evaluate(r),g=le.arraySlice(v.resultBuffer,x,y)}l==="quaternion"&&new Ht().fromArray(g).normalize().conjugate().toArray(g);const _=h.times.length;for(let v=0;v<_;++v){const x=v*m+p;if(l==="quaternion")Ht.multiplyQuaternionsFlat(h.values,x,g,0,h.values,x);else{const y=m-2*p;for(let b=0;b<y;++b)h.values[x+b]-=g[b]}}}return s.blendMode=2501,s}};class Ir{constructor(t,e,i,n){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=n!==void 0?n:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,n=e[i],r=e[i-1];t:{e:{let a;i:{n:if(!(t<n)){for(let o=i+2;;){if(n===void 0){if(t<r)break n;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===o)break;if(r=n,n=e[++i],t<n)break e}a=e.length;break i}if(t>=r)break t;{const o=e[1];t<o&&(i=2,r=o);for(let l=i-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===l)break;if(n=r,r=e[--i-1],t>=r)break e}a=i,i=0}}for(;i<a;){const o=i+a>>>1;t<e[o]?a=o:i=o+1}if(n=e[i],r=e[i-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===void 0)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,r,n)}return this.interpolate_(i,r,t,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=t*n;for(let a=0;a!==n;++a)e[a]=i[r+a];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Qx extends Ir{constructor(t,e,i,n){super(t,e,i,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ur,endingEnd:ur}}intervalChanged_(t,e,i){const n=this.parameterPositions;let r=t-2,a=t+1,o=n[r],l=n[a];if(o===void 0)switch(this.getSettings_().endingStart){case dr:r=t,o=2*e-i;break;case Io:r=n.length-2,o=e+n[r]-n[r+1];break;default:r=t,o=i}if(l===void 0)switch(this.getSettings_().endingEnd){case dr:a=t,l=2*i-e;break;case Io:a=1,l=i+n[1]-n[0];break;default:a=t-1,l=e}const h=.5*(i-e),c=this.valueSize;this._weightPrev=h/(e-o),this._weightNext=h/(l-i),this._offsetPrev=r*c,this._offsetNext=a*c}interpolate_(t,e,i,n){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=t*o,h=l-o,c=this._offsetPrev,u=this._offsetNext,p=this._weightPrev,m=this._weightNext,f=(i-e)/(n-e),g=f*f,_=g*f,v=-p*_+2*p*g-p*f,x=(1+p)*_+(-1.5-2*p)*g+(-.5+p)*f+1,y=(-1-m)*_+(1.5+m)*g+.5*f,b=m*_-m*g;for(let S=0;S!==o;++S)r[S]=v*a[c+S]+x*a[h+S]+y*a[l+S]+b*a[u+S];return r}}class hm extends Ir{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t,e,i,n){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=t*o,h=l-o,c=(i-e)/(n-e),u=1-c;for(let p=0;p!==o;++p)r[p]=a[h+p]*u+a[l+p]*c;return r}}class $x extends Ir{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t){return this.copySampleValue_(t-1)}}class qi{constructor(t,e,i,n){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=le.convertArray(e,this.TimeBufferType),this.values=le.convertArray(i,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:le.convertArray(t.times,Array),values:le.convertArray(t.values,Array)};const n=t.getInterpolation();n!==t.DefaultInterpolation&&(i.interpolation=n)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new $x(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new hm(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Qx(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case ya:e=this.InterpolantFactoryMethodDiscrete;break;case cr:e=this.InterpolantFactoryMethodLinear;break;case Ph:e=this.InterpolantFactoryMethodSmooth}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0){if(t===this.DefaultInterpolation)throw new Error(i);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ya;case this.InterpolantFactoryMethodLinear:return cr;case this.InterpolantFactoryMethodSmooth:return Ph}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,n=e.length;i!==n;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,n=e.length;i!==n;++i)e[i]*=t}return this}trim(t,e){const i=this.times,n=i.length;let r=0,a=n-1;for(;r!==n&&i[r]<t;)++r;for(;a!==-1&&i[a]>e;)--a;if(++a,r!==0||a!==n){r>=a&&(a=Math.max(a,1),r=a-1);const o=this.getValueSize();this.times=le.arraySlice(i,r,a),this.values=le.arraySlice(this.values,r*o,a*o)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,n=this.values,r=i.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let o=0;o!==r;o++){const l=i[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),t=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),t=!1;break}a=l}if(n!==void 0&&le.isTypedArray(n))for(let o=0,l=n.length;o!==l;++o){const h=n[o];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,h),t=!1;break}}return t}optimize(){const t=le.arraySlice(this.times),e=le.arraySlice(this.values),i=this.getValueSize(),n=this.getInterpolation()===Ph,r=t.length-1;let a=1;for(let o=1;o<r;++o){let l=!1;const h=t[o];if(h!==t[o+1]&&(o!==1||h!==t[0]))if(n)l=!0;else{const c=o*i,u=c-i,p=c+i;for(let m=0;m!==i;++m){const f=e[c+m];if(f!==e[u+m]||f!==e[p+m]){l=!0;break}}}if(l){if(o!==a){t[a]=t[o];const c=o*i,u=a*i;for(let p=0;p!==i;++p)e[u+p]=e[c+p]}++a}}if(r>0){t[a]=t[r];for(let o=r*i,l=a*i,h=0;h!==i;++h)e[l+h]=e[o+h];++a}return a!==t.length?(this.times=le.arraySlice(t,0,a),this.values=le.arraySlice(e,0,a*i)):(this.times=t,this.values=e),this}clone(){const t=le.arraySlice(this.times,0),e=le.arraySlice(this.values,0),i=new this.constructor(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}qi.prototype.TimeBufferType=Float32Array,qi.prototype.ValueBufferType=Float32Array,qi.prototype.DefaultInterpolation=cr;class Or extends qi{}Or.prototype.ValueTypeName="bool",Or.prototype.ValueBufferType=Array,Or.prototype.DefaultInterpolation=ya,Or.prototype.InterpolantFactoryMethodLinear=void 0,Or.prototype.InterpolantFactoryMethodSmooth=void 0;class cm extends qi{}cm.prototype.ValueTypeName="color";class Ua extends qi{}Ua.prototype.ValueTypeName="number";class ty extends Ir{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t,e,i,n){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(i-e)/(n-e);let h=t*o;for(let c=h+o;h!==c;h+=4)Ht.slerpFlat(r,0,a,h-o,a,h,l);return r}}class ks extends qi{InterpolantFactoryMethodLinear(t){return new ty(this.times,this.values,this.getValueSize(),t)}}ks.prototype.ValueTypeName="quaternion",ks.prototype.DefaultInterpolation=cr,ks.prototype.InterpolantFactoryMethodSmooth=void 0;class zr extends qi{}zr.prototype.ValueTypeName="string",zr.prototype.ValueBufferType=Array,zr.prototype.DefaultInterpolation=ya,zr.prototype.InterpolantFactoryMethodLinear=void 0,zr.prototype.InterpolantFactoryMethodSmooth=void 0;class Fa extends qi{}Fa.prototype.ValueTypeName="vector";class gc{constructor(t,e=-1,i,n=2500){this.name=t,this.tracks=i,this.duration=e,this.blendMode=n,this.uuid=Ei(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,n=1/(t.fps||1);for(let a=0,o=i.length;a!==o;++a)e.push(ey(i[a]).scale(n));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],i=t.tracks,n={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let r=0,a=i.length;r!==a;++r)e.push(qi.toJSON(i[r]));return n}static CreateFromMorphTargetSequence(t,e,i,n){const r=e.length,a=[];for(let o=0;o<r;o++){let l=[],h=[];l.push((o+r-1)%r,o,(o+1)%r),h.push(0,1,0);const c=le.getKeyframeOrder(l);l=le.sortedArray(l,1,c),h=le.sortedArray(h,1,c),n||l[0]!==0||(l.push(r),h.push(h[0])),a.push(new Ua(".morphTargetInfluences["+e[o].name+"]",l,h).scale(1/i))}return new this(t,-1,a)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const n=t;i=n.geometry&&n.geometry.animations||n.animations}for(let n=0;n<i.length;n++)if(i[n].name===e)return i[n];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const n={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,l=t.length;o<l;o++){const h=t[o],c=h.name.match(r);if(c&&c.length>1){const u=c[1];let p=n[u];p||(n[u]=p=[]),p.push(h)}}const a=[];for(const o in n)a.push(this.CreateFromMorphTargetSequence(o,n[o],e,i));return a}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(c,u,p,m,f){if(p.length!==0){const g=[],_=[];le.flattenJSON(p,g,_,m),g.length!==0&&f.push(new c(u,g,_))}},n=[],r=t.name||"default",a=t.fps||30,o=t.blendMode;let l=t.length||-1;const h=t.hierarchy||[];for(let c=0;c<h.length;c++){const u=h[c].keys;if(u&&u.length!==0)if(u[0].morphTargets){const p={};let m;for(m=0;m<u.length;m++)if(u[m].morphTargets)for(let f=0;f<u[m].morphTargets.length;f++)p[u[m].morphTargets[f]]=-1;for(const f in p){const g=[],_=[];for(let v=0;v!==u[m].morphTargets.length;++v){const x=u[m];g.push(x.time),_.push(x.morphTarget===f?1:0)}n.push(new Ua(".morphTargetInfluence["+f+"]",g,_))}l=p.length*a}else{const p=".bones["+e[c].name+"]";i(Fa,p+".position",u,"pos",n),i(ks,p+".quaternion",u,"rot",n),i(Fa,p+".scale",u,"scl",n)}}return n.length===0?null:new this(r,l,n,o)}resetDuration(){let t=0;for(let e=0,i=this.tracks.length;e!==i;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function ey(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Ua;case"vector":case"vector2":case"vector3":case"vector4":return Fa;case"color":return cm;case"quaternion":return ks;case"bool":case"boolean":return Or;case"string":return zr}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(s.type);if(s.times===void 0){const e=[],i=[];le.flattenJSON(s.keys,e,i,"value"),s.times=e,s.values=i}return t.parse!==void 0?t.parse(s):new t(s.name,s.times,s.values,s.interpolation)}const kr={enabled:!1,files:{},add:function(s,t){this.enabled!==!1&&(this.files[s]=t)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class um{constructor(t,e,i){const n=this;let r,a=!1,o=0,l=0;const h=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(c){l++,a===!1&&n.onStart!==void 0&&n.onStart(c,o,l),a=!0},this.itemEnd=function(c){o++,n.onProgress!==void 0&&n.onProgress(c,o,l),o===l&&(a=!1,n.onLoad!==void 0&&n.onLoad())},this.itemError=function(c){n.onError!==void 0&&n.onError(c)},this.resolveURL=function(c){return r?r(c):c},this.setURLModifier=function(c){return r=c,this},this.addHandler=function(c,u){return h.push(c,u),this},this.removeHandler=function(c){const u=h.indexOf(c);return u!==-1&&h.splice(u,2),this},this.getHandler=function(c){for(let u=0,p=h.length;u<p;u+=2){const m=h[u],f=h[u+1];if(m.global&&(m.lastIndex=0),m.test(c))return f}return null}}}const Nr=new um;class Kn{constructor(t){this.manager=t!==void 0?t:Nr,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise(function(n,r){i.load(t,n,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const bn={};class cl extends Kn{constructor(t){super(t)}load(t,e,i,n){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=kr.get(t);if(r!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(bn[t]!==void 0)return void bn[t].push({onLoad:e,onProgress:i,onError:n});bn[t]=[],bn[t].push({onLoad:e,onProgress:i,onError:n});const a=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,l=this.responseType;fetch(a).then(h=>{if(h.status===200||h.status===0){if(h.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||h.body===void 0||h.body.getReader===void 0)return h;const c=bn[t],u=h.body.getReader(),p=h.headers.get("Content-Length"),m=p?parseInt(p):0,f=m!==0;let g=0;const _=new ReadableStream({start(v){(function x(){u.read().then(({done:y,value:b})=>{if(y)v.close();else{g+=b.byteLength;const S=new ProgressEvent("progress",{lengthComputable:f,loaded:g,total:m});for(let w=0,C=c.length;w<C;w++){const L=c[w];L.onProgress&&L.onProgress(S)}v.enqueue(b),x()}})})()}});return new Response(_)}throw Error(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`)}).then(h=>{switch(l){case"arraybuffer":return h.arrayBuffer();case"blob":return h.blob();case"document":return h.text().then(c=>new DOMParser().parseFromString(c,o));case"json":return h.json();default:if(o===void 0)return h.text();{const c=/charset="?([^;"\s]*)"?/i.exec(o),u=c&&c[1]?c[1].toLowerCase():void 0,p=new TextDecoder(u);return h.arrayBuffer().then(m=>p.decode(m))}}}).then(h=>{kr.add(t,h);const c=bn[t];delete bn[t];for(let u=0,p=c.length;u<p;u++){const m=c[u];m.onLoad&&m.onLoad(h)}}).catch(h=>{const c=bn[t];if(c===void 0)throw this.manager.itemError(t),h;delete bn[t];for(let u=0,p=c.length;u<p;u++){const m=c[u];m.onError&&m.onError(h)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class dm extends Kn{constructor(t){super(t)}load(t,e,i,n){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,a=kr.get(t);if(a!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(a),r.manager.itemEnd(t)},0),a;const o=Ta("img");function l(){c(),kr.add(t,this),e&&e(this),r.manager.itemEnd(t)}function h(u){c(),n&&n(u),r.manager.itemError(t),r.manager.itemEnd(t)}function c(){o.removeEventListener("load",l,!1),o.removeEventListener("error",h,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",h,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(t),o.src=t,o}}class iy extends Kn{constructor(t){super(t)}load(t,e,i,n){const r=new tl,a=new dm(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(h){a.load(t[h],function(c){r.images[h]=c,o++,o===6&&(r.needsUpdate=!0,e&&e(r))},void 0,n)}for(let h=0;h<t.length;++h)l(h);return r}}class ny extends Kn{constructor(t){super(t)}load(t,e,i,n){const r=this,a=new Dr,o=new cl(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,function(l){const h=r.parse(l);h&&(h.image!==void 0?a.image=h.image:h.data!==void 0&&(a.image.width=h.width,a.image.height=h.height,a.image.data=h.data),a.wrapS=h.wrapS!==void 0?h.wrapS:ue,a.wrapT=h.wrapT!==void 0?h.wrapT:ue,a.magFilter=h.magFilter!==void 0?h.magFilter:Wt,a.minFilter=h.minFilter!==void 0?h.minFilter:Wt,a.anisotropy=h.anisotropy!==void 0?h.anisotropy:1,h.encoding!==void 0&&(a.encoding=h.encoding),h.flipY!==void 0&&(a.flipY=h.flipY),h.format!==void 0&&(a.format=h.format),h.type!==void 0&&(a.type=h.type),h.mipmaps!==void 0&&(a.mipmaps=h.mipmaps,a.minFilter=ys),h.mipmapCount===1&&(a.minFilter=Wt),h.generateMipmaps!==void 0&&(a.generateMipmaps=h.generateMipmaps),a.needsUpdate=!0,e&&e(a,h))},i,n),a}}class Ie extends Kn{constructor(t){super(t)}load(t,e,i,n){const r=new ne,a=new dm(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,function(o){r.image=o,r.needsUpdate=!0,e!==void 0&&e(r)},i,n),r}}class ul extends St{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new tt(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}class sy extends ul{constructor(t,e,i){super(t,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(St.DefaultUp),this.updateMatrix(),this.groundColor=new tt(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const pm=new rt,mm=new M,fm=new M;class _c{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new j(512,512),this.map=null,this.mapPass=null,this.matrix=new rt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Pa,this._frameExtents=new j(1,1),this._viewportCount=1,this._viewports=[new Lt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;mm.setFromMatrixPosition(t.matrixWorld),e.position.copy(mm),fm.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(fm),e.updateMatrixWorld(),pm.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(pm),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(e.projectionMatrix),i.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),this.mapSize.x===512&&this.mapSize.y===512||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class ry extends _c{constructor(){super(new ye(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=2*wa*t.angle*this.focus,n=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;i===e.fov&&n===e.aspect&&r===e.far||(e.fov=i,e.aspect=n,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class ay extends ul{constructor(t,e,i=0,n=Math.PI/3,r=0,a=1){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(St.DefaultUp),this.updateMatrix(),this.target=new St,this.distance=i,this.angle=n,this.penumbra=r,this.decay=a,this.shadow=new ry}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const gm=new rt,Ba=new M,vc=new M;class oy extends _c{constructor(){super(new ye(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new j(4,2),this._viewportCount=6,this._viewports=[new Lt(2,1,1,1),new Lt(0,1,1,1),new Lt(3,1,1,1),new Lt(1,1,1,1),new Lt(3,0,1,1),new Lt(1,0,1,1)],this._cubeDirections=[new M(1,0,0),new M(-1,0,0),new M(0,0,1),new M(0,0,-1),new M(0,1,0),new M(0,-1,0)],this._cubeUps=[new M(0,1,0),new M(0,1,0),new M(0,1,0),new M(0,1,0),new M(0,0,1),new M(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,n=this.matrix,r=t.distance||i.far;r!==i.far&&(i.far=r,i.updateProjectionMatrix()),Ba.setFromMatrixPosition(t.matrixWorld),i.position.copy(Ba),vc.copy(i.position),vc.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(vc),i.updateMatrixWorld(),n.makeTranslation(-Ba.x,-Ba.y,-Ba.z),gm.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(gm)}}class ly extends ul{constructor(t,e,i=0,n=1){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=n,this.shadow=new oy}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class hy extends _c{constructor(){super(new Ra(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class _m extends ul{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(St.DefaultUp),this.updateMatrix(),this.target=new St,this.shadow=new hy}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class Ns{static decodeText(t){if(typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let i=0,n=t.length;i<n;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class vm extends Pt{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class cy extends Kn{constructor(t){super(t),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,n){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,a=kr.get(t);if(a!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(a),r.manager.itemEnd(t)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(t,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){kr.add(t,l),e&&e(l),r.manager.itemEnd(t)}).catch(function(l){n&&n(l),r.manager.itemError(t),r.manager.itemEnd(t)}),r.manager.itemStart(t)}}class xc{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=xm(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=xm();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function xm(){return(typeof performance>"u"?Date:performance).now()}class uy{constructor(t,e,i){let n,r,a;switch(this.binding=t,this.valueSize=i,e){case"quaternion":n=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":n=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(5*i);break;default:n=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=n,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const i=this.buffer,n=this.valueSize,r=t*n+n;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==n;++o)i[r+o]=i[o];a=e}else{a+=e;const o=e/a;this._mixBufferRegion(i,r,0,o,n)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,i=this.valueSize,n=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,n,0,t,i),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,i=this.buffer,n=t*e+e,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=e*this._origIndex;this._mixBufferRegion(i,n,l,1-r,e)}a>0&&this._mixBufferRegionAdditive(i,n,this._addIndex*e,1,e);for(let l=e,h=e+e;l!==h;++l)if(i[l]!==i[l+e]){o.setValue(i,n);break}}saveOriginalState(){const t=this.binding,e=this.buffer,i=this.valueSize,n=i*this._origIndex;t.getValue(e,n);for(let r=i,a=n;r!==a;++r)e[r]=e[n+r%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}_select(t,e,i,n,r){if(n>=.5)for(let a=0;a!==r;++a)t[e+a]=t[i+a]}_slerp(t,e,i,n){Ht.slerpFlat(t,e,t,e,t,i,n)}_slerpAdditive(t,e,i,n,r){const a=this._workIndex*r;Ht.multiplyQuaternionsFlat(t,a,t,e,t,i),Ht.slerpFlat(t,e,t,e,t,a,n)}_lerp(t,e,i,n,r){const a=1-n;for(let o=0;o!==r;++o){const l=e+o;t[l]=t[l]*a+t[i+o]*n}}_lerpAdditive(t,e,i,n,r){for(let a=0;a!==r;++a){const o=e+a;t[o]=t[o]+t[i+a]*n}}}const yc="\\[\\]\\.:\\/",dy=new RegExp("["+yc+"]","g"),bc="[^"+yc+"]",py="[^"+yc.replace("\\.","")+"]",my=/((?:WC+[\/:])*)/.source.replace("WC",bc),fy=/(WCOD+)?/.source.replace("WCOD",py),gy=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",bc),_y=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",bc),vy=new RegExp("^"+my+fy+gy+_y+"$"),xy=["material","materials","bones"];class Xt{constructor(t,e,i){this.path=e,this.parsedPath=i||Xt.parseTrackName(e),this.node=Xt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new Xt.Composite(t,e,i):new Xt(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(dy,"")}static parseTrackName(t){const e=vy.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},n=i.nodeName&&i.nodeName.lastIndexOf(".");if(n!==void 0&&n!==-1){const r=i.nodeName.substring(n+1);xy.indexOf(r)!==-1&&(i.nodeName=i.nodeName.substring(0,n),i.objectName=r)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(i!==void 0)return i}if(t.children){const i=function(r){for(let a=0;a<r.length;a++){const o=r[a];if(o.name===e||o.uuid===e)return o;const l=i(o.children);if(l)return l}return null},n=i(t.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)t[e++]=i[n]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,n=e.propertyName;let r=e.propertyIndex;if(t||(t=Xt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(i){let h=e.objectIndex;switch(i){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let c=0;c<t.length;c++)if(t[c].name===h){h=c;break}break;default:if(t[i]===void 0)return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[i]}if(h!==void 0){if(t[h]===void 0)return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[h]}}const a=t[n];if(a===void 0){const h=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+n+" but it wasn't found.",t)}let o=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(n==="morphTargetInfluences"){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);t.morphTargetDictionary[r]!==void 0&&(r=t.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=n;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Xt.Composite=class{constructor(s,t,e){const i=e||Xt.parseTrackName(t);this._targetGroup=s,this._bindings=s.subscribe_(t,i)}getValue(s,t){this.bind();const e=this._targetGroup.nCachedObjects_,i=this._bindings[e];i!==void 0&&i.getValue(s,t)}setValue(s,t){const e=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=e.length;i!==n;++i)e[i].setValue(s,t)}bind(){const s=this._bindings;for(let t=this._targetGroup.nCachedObjects_,e=s.length;t!==e;++t)s[t].bind()}unbind(){const s=this._bindings;for(let t=this._targetGroup.nCachedObjects_,e=s.length;t!==e;++t)s[t].unbind()}},Xt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Xt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Xt.prototype.GetterByBindingType=[Xt.prototype._getValue_direct,Xt.prototype._getValue_array,Xt.prototype._getValue_arrayElement,Xt.prototype._getValue_toArray],Xt.prototype.SetterByBindingTypeAndVersioning=[[Xt.prototype._setValue_direct,Xt.prototype._setValue_direct_setNeedsUpdate,Xt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Xt.prototype._setValue_array,Xt.prototype._setValue_array_setNeedsUpdate,Xt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Xt.prototype._setValue_arrayElement,Xt.prototype._setValue_arrayElement_setNeedsUpdate,Xt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Xt.prototype._setValue_fromArray,Xt.prototype._setValue_fromArray_setNeedsUpdate,Xt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class yy{constructor(t,e,i=null,n=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=n;const r=e.tracks,a=r.length,o=new Array(a),l={endingStart:ur,endingEnd:ur};for(let h=0;h!==a;++h){const c=r[h].createInterpolant(null);o[h]=c,c.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){const n=this._clip.duration,r=t._clip.duration,a=r/n,o=n/r;t.warp(1,a,e),this.warp(o,1,e)}return this}crossFadeTo(t,e,i){return t.crossFadeFrom(this,e,i)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){const n=this._mixer,r=n.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=n._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,h=o.sampleValues;return l[0]=r,l[1]=r+i,h[0]=t/a,h[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,i,n){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(r!==null){const l=(t-r)*i;if(l<0||i===0)return;this._startTime=null,e=i*l}e*=this._updateTimeScale(t);const a=this._updateTime(e),o=this._updateWeight(t);if(o>0){const l=this._interpolants,h=this._propertyBindings;if(this.blendMode===2501)for(let c=0,u=l.length;c!==u;++c)l[c].evaluate(a),h[c].accumulateAdditive(o);else for(let c=0,u=l.length;c!==u;++c)l[c].evaluate(a),h[c].accumulate(n,o)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const i=this._weightInterpolant;if(i!==null){const n=i.evaluate(t)[0];e*=n,t>i.parameterPositions[1]&&(this.stopFading(),n===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const i=this._timeScaleInterpolant;i!==null&&(e*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,i=this.loop;let n=this.time+t,r=this._loopCount;const a=i===2202;if(t===0)return r===-1?n:a&&(1&r)==1?e-n:n;if(i===2200){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(n>=e)n=e;else{if(!(n<0)){this.time=n;break t}n=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(r===-1&&(t>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),n>=e||n<0){const o=Math.floor(n/e);n-=e*o,r+=Math.abs(o);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,n=t>0?e:0,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const h=t<0;this._setEndings(h,!h,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=n,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=n;if(a&&(1&r)==1)return e-n}return n}_setEndings(t,e,i){const n=this._interpolantSettings;i?(n.endingStart=dr,n.endingEnd=dr):(n.endingStart=t?this.zeroSlopeAtStart?dr:ur:Io,n.endingEnd=e?this.zeroSlopeAtEnd?dr:ur:Io)}_scheduleFading(t,e,i){const n=this._mixer,r=n.time;let a=this._weightInterpolant;a===null&&(a=n._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=r,l[0]=e,o[1]=r+t,l[1]=i,this}}const by=new Float32Array(1);class My extends pn{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const i=t._localRoot||this._root,n=t._clip.tracks,r=n.length,a=t._propertyBindings,o=t._interpolants,l=i.uuid,h=this._bindingsByRootAndName;let c=h[l];c===void 0&&(c={},h[l]=c);for(let u=0;u!==r;++u){const p=n[u],m=p.name;let f=c[m];if(f!==void 0)++f.referenceCount,a[u]=f;else{if(f=a[u],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,l,m));continue}const g=e&&e._propertyBindings[u].binding.parsedPath;f=new uy(Xt.create(i,m,g),p.ValueTypeName,p.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,l,m),a[u]=f}o[u].resultBuffer=f.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const i=(t._localRoot||this._root).uuid,n=t._clip.uuid,r=this._actionsByClip[n];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,n,i)}const e=t._propertyBindings;for(let i=0,n=e.length;i!==n;++i){const r=e[i];r.useCount++==0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let i=0,n=e.length;i!==n;++i){const r=e[i];--r.useCount==0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,i){const n=this._actions,r=this._actionsByClip;let a=r[e];if(a===void 0)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=a;else{const o=a.knownActions;t._byClipCacheIndex=o.length,o.push(t)}t._cacheIndex=n.length,n.push(t),a.actionByRoot[i]=t}_removeInactiveAction(t){const e=this._actions,i=e[e.length-1],n=t._cacheIndex;i._cacheIndex=n,e[n]=i,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,a=this._actionsByClip,o=a[r],l=o.knownActions,h=l[l.length-1],c=t._byClipCacheIndex;h._byClipCacheIndex=c,l[c]=h,l.pop(),t._byClipCacheIndex=null,delete o.actionByRoot[(t._localRoot||this._root).uuid],l.length===0&&delete a[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let i=0,n=e.length;i!==n;++i){const r=e[i];--r.referenceCount==0&&this._removeInactiveBinding(r)}}_lendAction(t){const e=this._actions,i=t._cacheIndex,n=this._nActiveActions++,r=e[n];t._cacheIndex=n,e[n]=t,r._cacheIndex=i,e[i]=r}_takeBackAction(t){const e=this._actions,i=t._cacheIndex,n=--this._nActiveActions,r=e[n];t._cacheIndex=n,e[n]=t,r._cacheIndex=i,e[i]=r}_addInactiveBinding(t,e,i){const n=this._bindingsByRootAndName,r=this._bindings;let a=n[e];a===void 0&&(a={},n[e]=a),a[i]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,i=t.binding,n=i.rootNode.uuid,r=i.path,a=this._bindingsByRootAndName,o=a[n],l=e[e.length-1],h=t._cacheIndex;l._cacheIndex=h,e[h]=l,e.pop(),delete o[r],Object.keys(o).length===0&&delete a[n]}_lendBinding(t){const e=this._bindings,i=t._cacheIndex,n=this._nActiveBindings++,r=e[n];t._cacheIndex=n,e[n]=t,r._cacheIndex=i,e[i]=r}_takeBackBinding(t){const e=this._bindings,i=t._cacheIndex,n=--this._nActiveBindings,r=e[n];t._cacheIndex=n,e[n]=t,r._cacheIndex=i,e[i]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let i=t[e];return i===void 0&&(i=new hm(new Float32Array(2),new Float32Array(2),1,by),i.__cacheIndex=e,t[e]=i),i}_takeBackControlInterpolant(t){const e=this._controlInterpolants,i=t.__cacheIndex,n=--this._nActiveControlInterpolants,r=e[n];t.__cacheIndex=n,e[n]=t,r.__cacheIndex=i,e[i]=r}clipAction(t,e,i){const n=e||this._root,r=n.uuid;let a=typeof t=="string"?gc.findByName(n,t):t;const o=a!==null?a.uuid:t,l=this._actionsByClip[o];let h=null;if(i===void 0&&(i=a!==null?a.blendMode:Y0),l!==void 0){const u=l.actionByRoot[r];if(u!==void 0&&u.blendMode===i)return u;h=l.knownActions[0],a===null&&(a=h._clip)}if(a===null)return null;const c=new yy(this,a,e,i);return this._bindAction(c,h),this._addInactiveAction(c,o,r),c}existingAction(t,e){const i=e||this._root,n=i.uuid,r=typeof t=="string"?gc.findByName(i,t):t,a=r?r.uuid:t,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[n]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,i=this._nActiveActions,n=this.time+=t,r=Math.sign(t),a=this._accuIndex^=1;for(let h=0;h!==i;++h)e[h]._update(n,t,r,a);const o=this._bindings,l=this._nActiveBindings;for(let h=0;h!==l;++h)o[h].apply(a);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,i=t.uuid,n=this._actionsByClip,r=n[i];if(r!==void 0){const a=r.knownActions;for(let o=0,l=a.length;o!==l;++o){const h=a[o];this._deactivateAction(h);const c=h._cacheIndex,u=e[e.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,u._cacheIndex=c,e[c]=u,e.pop(),this._removeInactiveBindingsForAction(h)}delete n[i]}}uncacheRoot(t){const e=t.uuid,i=this._actionsByClip;for(const r in i){const a=i[r].actionByRoot[e];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const n=this._bindingsByRootAndName[e];if(n!==void 0)for(const r in n){const a=n[r];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(t,e){const i=this.existingAction(t,e);i!==null&&(this._deactivateAction(i),this._removeInactiveAction(i))}}class Us{constructor(t,e,i=0,n=1/0){this.ray=new vr(t,e),this.near=i,this.far=n,this.camera=null,this.layers=new Gh,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,i=[]){return Mc(t,this,i,e),i.sort(ym),i}intersectObjects(t,e=!0,i=[]){for(let n=0,r=t.length;n<r;n++)Mc(t[n],this,i,e);return i.sort(ym),i}}function ym(s,t){return s.distance-t.distance}function Mc(s,t,e,i){if(s.layers.test(t.layers)&&s.raycast(t,e),i===!0){const n=s.children;for(let r=0,a=n.length;r<a;r++)Mc(n[r],t,e,!0)}}const bm=new j;class Mm{constructor(t=new j(1/0,1/0),e=new j(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=bm.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return bm.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}class wy extends dc{constructor(t,e=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Pt;n.setIndex(new se(i,1)),n.setAttribute("position",new et([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(n,new Is({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}}class dl{static toHalfFloat(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=ke(t,-65504,65504),Sm[0]=t;const e=Tm[0],i=e>>23&511;return Ii[i]+((8388607&e)>>Oi[i])}static fromHalfFloat(t){const e=t>>10;return Tm[0]=wc[Cm[e]+(1023&t)]+Ur[e],Sm[0]}}const wm=new ArrayBuffer(4),Sm=new Float32Array(wm),Tm=new Uint32Array(wm),Ii=new Uint32Array(512),Oi=new Uint32Array(512);for(let s=0;s<256;++s){const t=s-127;t<-27?(Ii[s]=0,Ii[256|s]=32768,Oi[s]=24,Oi[256|s]=24):t<-14?(Ii[s]=1024>>-t-14,Ii[256|s]=1024>>-t-14|32768,Oi[s]=-t-1,Oi[256|s]=-t-1):t<=15?(Ii[s]=t+15<<10,Ii[256|s]=t+15<<10|32768,Oi[s]=13,Oi[256|s]=13):t<128?(Ii[s]=31744,Ii[256|s]=64512,Oi[s]=24,Oi[256|s]=24):(Ii[s]=31744,Ii[256|s]=64512,Oi[s]=13,Oi[256|s]=13)}const wc=new Uint32Array(2048),Ur=new Uint32Array(64),Cm=new Uint32Array(64);for(let s=1;s<1024;++s){let t=s<<13,e=0;for(;!(8388608&t);)t<<=1,e-=8388608;t&=-8388609,e+=947912704,wc[s]=t|e}for(let s=1024;s<2048;++s)wc[s]=939524096+(s-1024<<13);for(let s=1;s<31;++s)Ur[s]=s<<23;Ur[31]=1199570944,Ur[32]=2147483648;for(let s=33;s<63;++s)Ur[s]=2147483648+(s-32<<23);Ur[63]=3347054592;for(let s=1;s<64;++s)s!==32&&(Cm[s]=1024);typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:yh}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=yh);var Em,Am,Sc,Sy=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof Co<"u"?Co:typeof self<"u"?self:{},Pm={exports:{}};Am=Sy,Sc=function(){return function(){return function(s){var t=[];if(s.length===0)return"";if(typeof s[0]!="string")throw new TypeError("Url must be a string. Received "+s[0]);if(s[0].match(/^[^/:]+:\/*$/)&&s.length>1){var e=s.shift();s[0]=e+s[0]}s[0].match(/^file:\/\/\//)?s[0]=s[0].replace(/^([^/:]+):\/*/,"$1:///"):s[0]=s[0].replace(/^([^/:]+):\/*/,"$1://");for(var i=0;i<s.length;i++){var n=s[i];if(typeof n!="string")throw new TypeError("Url must be a string. Received "+n);n!==""&&(i>0&&(n=n.replace(/^[\/]+/,"")),n=i<s.length-1?n.replace(/[\/]+$/,""):n.replace(/[\/]+$/,"/"),t.push(n))}var r=t.join("/"),a=(r=r.replace(/\/(\?|&|#[^!])/g,"$1")).split("?");return a.shift()+(a.length>0?"?":"")+a.join("&")}(typeof arguments[0]=="object"?arguments[0]:[].slice.call(arguments))}},(Em=Pm).exports?Em.exports=Sc():Am.urljoin=Sc();const Tc=Pm.exports;let Cc=null;function pl(){if(Cc!==null)return Cc;let s="";if(s=typeof MAPV_BASE_URL=="string"?MAPV_BASE_URL:"https://mapv-three.bj.bcebos.com",!s)throw new Error("Unable to determine base URL automatically, try defining a global variable called MAPV_BASE_URL.");return Cc=s,s}function Jt(...s){return Tc(pl(),...s)}const Ty=Object.freeze(Object.defineProperty({__proto__:null,getBaseUrl:pl,getAssetUrl:Jt},Symbol.toStringTag,{value:"Module"}));class Fr extends De{constructor(){super(),d(this,"isEmptySky",!0),d(this,"_addDefaultEnvMap",!1),d(this,"_time",21600),d(this,"_startTimestamp",new Date().getTime()),d(this,"_timeAnimation",!1),d(this,"_timeAnimationSpeed",1),d(this,"_skyLightIntensity",.5),d(this,"_skyLightAttenuationRatio",.2),d(this,"_sunIntensityBias",0),d(this,"_sunIntensityScale",.8),d(this,"_weather","partlyCloudy"),d(this,"_timeChangedListeners",[]),d(this,"_sunDirection",new M),d(this,"_sunLightColorDay",new tt(16777215)),d(this,"_sunLightColorSunset",new tt(15090944)),d(this,"_sunLightColorCurrent",new tt(16777215)),d(this,"_sunRadian",null),d(this,"_skyLightColorDay",new tt(16777215)),d(this,"_skyLightColorNight",new tt(16777215)),d(this,"_groundLightColorDay",new tt(16777215)),d(this,"_groundLightColorNight",new tt(16758093)),d(this,"_lightNeedsUpdate",!1),d(this,"_sunNeedsUpdate",!1),d(this,"_affectWorld",!1),d(this,"updateSunLightShadowCamera",()=>{const i=this.engine;if(!i.renderer.shadowMap.enabled){const g=this.sunLight;return g.position.copy(this._sunDirection),g.target.position.set(0,0,0),g.updateMatrix(),g.updateMatrixWorld(),g.target.updateMatrix(),void g.target.updateMatrixWorld()}const n=this._sunDirection,r=[n.x,n.y,n.z],a=this.sunLight,[o,l]=i.map.getProjectionCenter();let h=i.map.getCameraDistance(),c=1e3;const u=c*r[0],p=c*r[1],m=c*r[2];a.position.set(o+u,l+p,m),a.target.position.set(o,l,0),a.shadow.camera.left=-h,a.shadow.camera.bottom=-h,a.shadow.camera.right=h,a.shadow.camera.top=h,a.shadow.camera.near=1,a.shadow.camera.far=h>2e4?1:2e3,a.updateMatrix(),a.updateMatrixWorld(),a.target.updateMatrix(),a.target.updateMatrixWorld(),a.shadow.camera.updateProjectionMatrix();const f=re.mapLinear(i.rendering.camera.position.z,1,500,-8e-5,-.001);a.shadow.bias=f<-.001?-.001:f});const t=this.sunLight=new _m(16777215,.6),e=this.skyLight=new sy(16755200,255,this._skyLightIntensity);e.position.set(0,0,1),t.castShadow=!0,t.shadow.mapSize=new j(1024,1024),t.shadow.bias=-1e-4,this.add(t),this.add(t.target),this.add(e),t.matrixAutoUpdate=!1,t.target.matrixAutoUpdate=!1,this.renderOrder=-100}afterAddToEngine(t){if(this.engine=t,!this.isDynamicSky&&!this.isStaticSky&&this._addDefaultEnvMap){const e=new Ie().load(Jt("assets/textures/sky/partlyCloudy_default.jpg"));e.mapping=Do,e.encoding=Bt,t.rendering.scene.environment=e}}set time(t){this._time=t;const e=this._sunRadian=(t/86400-.25)*Math.PI*2,i=Math.cos(e),n=Math.sin(e);this._sunDirection.set(i,0,n),this._lightNeedsUpdate=!0,this.onTimeChanged(this._time);for(const r of this._timeChangedListeners)r(t)}get time(){return this._time}get weather(){return this._weather}set weather(t){this._weather=t,this.onWeatherChanged(t)}get timeAnimation(){return this._timeAnimation}set timeAnimation(t){t&&(this._startTimestamp=new Date().getTime()-this.time/86400*(86400/this._timeAnimationSpeed)),this._timeAnimation=t}get timeAnimationSpeed(){return this._timeAnimationSpeed}set timeAnimationSpeed(t){this._timeAnimationSpeed=t}tickTime(){const t=new Date().getTime()-this._startTimestamp,e=86400/this._timeAnimationSpeed;this.time=t%e/e*86400}onBeforeScenePrepareRender(){this._timeAnimation&&this.tickTime(),this._lightNeedsUpdate&&this.updateLight(),this.updateSunLightShadowCamera()}updateLight(){const t=this._sunDirection.z,e=t>.5?1:t<0?0:2*t;this.sunLight.intensity=this._sunIntensityBias+this._sunIntensityScale*e;const i=this.sunsetRatio=t>.259?0:t<0?1:1-t/.259;this.skyLight.intensity=this._skyLightIntensity*re.clamp(1-i,this._skyLightAttenuationRatio,1),this._sunLightColorCurrent.lerpColors(this._sunLightColorDay,this._sunLightColorSunset,i),this.sunLight.color.copy(this._sunLightColorCurrent),this.skyLight.color.lerpColors(this._skyLightColorDay,this._skyLightColorNight,i),this.skyLight.groundColor.lerpColors(this._groundLightColorDay,this._groundLightColorNight,i)}addTimeChangedListener(t){this._timeChangedListeners.indexOf(t)===-1&&this._timeChangedListeners.push(t)}removeTimeChangedListener(t){const e=this._timeChangedListeners.indexOf(t);e!==-1&&this._timeChangedListeners.splice(e,1)}onTimeChanged(t){}onWeatherChanged(t){}dispose(){}get sunIntensityBias(){return this._sunIntensityBias}set sunIntensityBias(t){this._sunIntensityBias=t,this._lightNeedsUpdate=!0}get sunIntensityScale(){return this._sunIntensityScale}set sunIntensityScale(t){this._sunIntensityScale=t,this._lightNeedsUpdate=!0}get skyLightIntensity(){return this._skyLightIntensity}set skyLightIntensity(t){this._skyLightIntensity=t,this._lightNeedsUpdate=!0}get skyLightAttenuationRatio(){return this._skyLightAttenuationRatio}set skyLightAttenuationRatio(t){this._skyLightAttenuationRatio=t,this._lightNeedsUpdate=!0}get sunDirection(){return this._sunDirection}get affectWorld(){return this._affectWorld}}/*!
  * Proton v1.1.2
  * https://github.com/JackXie60/shader-particle-system
  * Copyright 2022-2022, JackXie60
  * Licensed under the MIT license
  * http://www.opensource.org/licenses/mit-license
  *
  */var Mn,gi,Qn,Y={types:{Boolean:"boolean",STRING:"string",NUMBER:"number",OBJECT:"object"},ensureTypedArg:function(s,t,e){return typeof s===t?s:e},ensureArrayTypedArg:function(s,t,e){if(Array.isArray(s)){for(var i=s.length-1;i>=0;--i)if(typeof s[i]!==t)return e;return s}return this.ensureTypedArg(s,t,e)},ensureInstanceOf:function(s,t,e){return s!==void 0?s:e},ensureArrayInstanceOf:function(s,t,e){if(Array.isArray(s)){for(var i=s.length-1;i>=0;--i)if(t!==void 0&&s[i]instanceof t==0)return e;return s}return this.ensureInstanceOf(s,t,e)},ensureValueOverLifetimeCompliance:function(s,t,e){t=t||3,e=e||3,Array.isArray(s._value)===!1&&(s._value=[s._value]),Array.isArray(s._spread)===!1&&(s._spread=[s._spread]);var i=this.clamp(s._value.length,t,e),n=this.clamp(s._spread.length,t,e),r=Math.max(i,n);s._value.length!==r&&(s._value=this.interpolateArray(s._value,r)),s._spread.length!==r&&(s._spread=this.interpolateArray(s._spread,r))},interpolateArray:function(s,t){for(var e=s.length,i=[typeof s[0].clone=="function"?s[0].clone():s[0]],n=(e-1)/(t-1),r=1;r<t-1;++r){var a=r*n,o=Math.floor(a),l=Math.ceil(a),h=a-o;i[r]=this.lerpTypeAgnostic(s[o],s[l],h)}return i.push(typeof s[e-1].clone=="function"?s[e-1].clone():s[e-1]),i},clamp:function(s,t,e){return Math.max(t,Math.min(s,e))},zeroToEpsilon:function(s,t){var e=1e-5,i=s;return i=t?Math.random()*e*10:e,s<0&&s>-1e-5&&(i=-i),i},lerpTypeAgnostic:function(s,t,e){var i,n=this.types;return typeof s===n.NUMBER&&typeof t===n.NUMBER?s+(t-s)*e:s instanceof j&&t instanceof j?((i=s.clone()).x=this.lerp(s.x,t.x,e),i.y=this.lerp(s.y,t.y,e),i):s instanceof M&&t instanceof M?((i=s.clone()).x=this.lerp(s.x,t.x,e),i.y=this.lerp(s.y,t.y,e),i.z=this.lerp(s.z,t.z,e),i):s instanceof Lt&&t instanceof Lt?((i=s.clone()).x=this.lerp(s.x,t.x,e),i.y=this.lerp(s.y,t.y,e),i.z=this.lerp(s.z,t.z,e),i.w=this.lerp(s.w,t.w,e),i):s instanceof tt&&t instanceof tt?((i=s.clone()).r=this.lerp(s.r,t.r,e),i.g=this.lerp(s.g,t.g,e),i.b=this.lerp(s.b,t.b,e),i):void console.warn("Invalid argument types, or argument types do not match:",s,t)},lerp:function(s,t,e){return s+(t-s)*e},roundToNearestMultiple:function(s,t){var e;return t===0||(e=Math.abs(s)%t)==0?s:s<0?-(Math.abs(s)-e):s+t-e},arrayValuesAreEqual:function(s){for(var t=0;t<s.length-1;++t)if(s[t]!==s[t+1])return!1;return!0},randomFloat:function(s,t){return s+t*(Math.random()-.5)},randomVector3:function(s,t,e,i,n){var r=e.x+(Math.random()*i.x-.5*i.x),a=e.y+(Math.random()*i.y-.5*i.y),o=e.z+(Math.random()*i.z-.5*i.z);n&&(r=.5*-n.x+this.roundToNearestMultiple(r,n.x),a=.5*-n.y+this.roundToNearestMultiple(a,n.y),o=.5*-n.z+this.roundToNearestMultiple(o,n.z)),s.typedArray.setVec3Components(t,r,a,o)},randomColor:function(s,t,e,i){var n=e.r+Math.random()*i.x,r=e.g+Math.random()*i.y,a=e.b+Math.random()*i.z;n=this.clamp(n,0,1),r=this.clamp(r,0,1),a=this.clamp(a,0,1),s.typedArray.setVec3Components(t,n,r,a)},randomColorAsHex:(gi=new tt,function(s,t,e,i){for(var n=e.length,r=[],a=0;a<n;++a){var o=i[a];gi.copy(e[a]),gi.r+=Math.random()*o.x-.5*o.x,gi.g+=Math.random()*o.y-.5*o.y,gi.b+=Math.random()*o.z-.5*o.z,gi.r=this.clamp(gi.r,0,1),gi.g=this.clamp(gi.g,0,1),gi.b=this.clamp(gi.b,0,1),r.push(gi.getHex())}s.typedArray.setVec4Components(t,r[0],r[1],r[2],r[3])}),randomVector3OnLine:function(s,t,e,i){var n=e.clone();n.lerp(i,Math.random()),s.typedArray.setVec3Components(t,n.x,n.y,n.z)},randomVector3OnSphere:function(s,t,e,i,n,r,a,o){var l=2*Math.random()-1,h=6.2832*Math.random(),c=Math.sqrt(1-l*l),u=this.randomFloat(i,n),p=0,m=0,f=0;a&&(u=Math.round(u/a)*a),p=c*Math.cos(h)*u,m=c*Math.sin(h)*u,f=l*u,p*=r.x,m*=r.y,f*=r.z,p+=e.x,m+=e.y,f+=e.z,s.typedArray.setVec3Components(t,p,m,f)},seededRandom:function(s){var t=1e4*Math.sin(s);return t-(0|t)},randomVector3OnDisc:function(s,t,e,i,n,r,a){var o=6.2832*Math.random(),l=Math.abs(this.randomFloat(i,n)),h=0,c=0,u=0;a&&(l=Math.round(l/a)*a),h=Math.cos(o)*l,c=Math.sin(o)*l,h*=r.x,c*=r.y,h+=e.x,c+=e.y,u+=e.z,s.typedArray.setVec3Components(t,h,c,u)},randomDirectionVector3OnSphere:(Mn=new M,function(s,t,e,i,n,r,a,o){Mn.copy(r),Mn.x-=e,Mn.y-=i,Mn.z-=n,Mn.normalize().multiplyScalar(-this.randomFloat(a,o)),s.typedArray.setVec3Components(t,Mn.x,Mn.y,Mn.z)}),randomDirectionVector3OnDisc:(Qn=new M,function(s,t,e,i,n,r,a,o){Qn.copy(r),Qn.x-=e,Qn.y-=i,Qn.z-=n,Qn.normalize().multiplyScalar(-this.randomFloat(a,o)),s.typedArray.setVec3Components(t,Qn.x,Qn.y,0)}),getPackedRotationAxis:function(){var s=new M,t=new M,e=new tt,i=new M(1,1,1);return function(n,r){return s.copy(n).normalize(),t.copy(r).normalize(),s.x+=.5*-r.x+Math.random()*r.x,s.y+=.5*-r.y+Math.random()*r.y,s.z+=.5*-r.z+Math.random()*r.z,s.normalize().add(i).multiplyScalar(.5),e.setRGB(s.x,s.y,s.z),e.getHex()}}()},Br={distributions:{BOX:1,SPHERE:2,DISC:3,LINE:4},valueOverLifetimeLength:4},Cy=function(){function s(e,i,n,r){this.componentSize=n||1,this.size=i||1,this.TypedArrayConstructor=e||Float32Array,this.array=new e(i*this.componentSize),this.indexOffset=r||0}var t=s.prototype;return t.setSize=function(e,i){var n=this.array.length;return i||(e*=this.componentSize),e<n?this.shrink(e):e>n?this.grow(e):void console.info("TypedArray is already of size:",e+".","Will not resize.")},t.shrink=function(e){return this.array=this.array.subarray(0,e),this.size=e,this},t.grow=function(e){var i=new this.TypedArrayConstructor(e);return i.set(this.array),this.array=i,this.size=e,this},t.splice=function(e,i){for(var n=e*this.componentSize,r=i*this.componentSize,a=[],o=this.array.length,l=0;l<o;++l)(l<n||l>r)&&a.push(this.array[l]);return this.setFromArray(0,a),this},t.setFromArray=function(e,i){var n=e+i.length;return n>this.array.length?this.grow(n):n<this.array.length&&this.shrink(n),this.array.set(i,this.indexOffset+e),this},t.setVec2=function(e,i){return this.setVec2Components(e,i.x,i.y)},t.setVec2Components=function(e,i,n){var r=this.array,a=this.indexOffset+e*this.componentSize;return r[a]=i,r[a+1]=n,this},t.setVec3=function(e,i){return this.setVec3Components(e,i.x,i.y,i.z)},t.setVec3Components=function(e,i,n,r){var a=this.array,o=this.indexOffset+e*this.componentSize;return a[o]=i,a[o+1]=n,a[o+2]=r,this},t.setVec4=function(e,i){return this.setVec4Components(e,i.x,i.y,i.z,i.w)},t.setVec4Components=function(e,i,n,r,a){var o=this.array,l=this.indexOffset+e*this.componentSize;return o[l]=i,o[l+1]=n,o[l+2]=r,o[l+3]=a,this},t.setMat3=function(e,i){return this.setFromArray(this.indexOffset+e*this.componentSize,i.elements)},t.setMat4=function(e,i){return this.setFromArray(this.indexOffset+e*this.componentSize,i.elements)},t.setColor=function(e,i){return this.setVec3Components(e,i.r,i.g,i.b)},t.setNumber=function(e,i){return this.array[this.indexOffset+e*this.componentSize]=i,this},t.getValueAtIndex=function(e){return this.array[this.indexOffset+e]},t.getComponentValueAtIndex=function(e){return this.array.subarray(this.indexOffset+e*this.componentSize)},s}(),zi=function(){function s(e,i,n){var r=s.typeSizeMap;this.type=typeof e=="string"&&r.hasOwnProperty(e)?e:"f",this.componentSize=r[this.type],this.arrayType=n||Float32Array,this.typedArray=null,this.bufferAttribute=null,this.dynamicBuffer=!!i,this.updateMin=0,this.updateMax=0}var t=s.prototype;return t.setUpdateRange=function(e,i){this.updateMin=Math.min(e*this.componentSize,this.updateMin*this.componentSize),this.updateMax=Math.max(i*this.componentSize,this.updateMax*this.componentSize)},t.flagUpdate=function(){var e=this.bufferAttribute,i=e.updateRange;i.offset=this.updateMin,i.count=Math.min(this.updateMax-this.updateMin+this.componentSize,this.typedArray.array.length),e.needsUpdate=!0},t.resetUpdateRange=function(){this.updateMin=0,this.updateMax=0},t.resetDynamic=function(){this.bufferAttribute.useage=this.dynamicBuffer?35048:pr},t.splice=function(e,i){this.typedArray.splice(e,i),this.forceUpdateAll()},t.forceUpdateAll=function(){this.bufferAttribute.array=this.typedArray.array,this.bufferAttribute.updateRange.offset=0,this.bufferAttribute.updateRange.count=-1,this.bufferAttribute.usage=pr,this.bufferAttribute.needsUpdate=!0},t._ensureTypedArray=function(e){this.typedArray!==null&&this.typedArray.size===e*this.componentSize||(this.typedArray!==null&&this.typedArray.size!==e?this.typedArray.setSize(e):this.typedArray===null&&(this.typedArray=new Cy(this.arrayType,e,this.componentSize)))},t._createBufferAttribute=function(e){if(this._ensureTypedArray(e),this.bufferAttribute!==null)return this.bufferAttribute.array=this.typedArray.array,this.bufferAttribute.count=this.bufferAttribute.array.length/this.bufferAttribute.itemSize,void(this.bufferAttribute.needsUpdate=!0);this.bufferAttribute=new se(this.typedArray.array,this.componentSize),this.bufferAttribute.usage=this.dynamicBuffer?35048:pr},t.getLength=function(){return this.typedArray===null?0:this.typedArray.array.length},s}();zi.typeSizeMap={f:1,v2:2,v3:3,v4:4,c:3,m3:9,m4:16};var Fe={defines:["#define PACKED_COLOR_SIZE 256.0","#define PACKED_COLOR_DIVISOR 255.0"].join(`
`),uniforms:["uniform float deltaTime;","uniform float runTime;","uniform sampler2D tex;","uniform vec4 textureAnimation;","uniform float scale;"].join(`
`),attributes:["attribute vec4 acceleration;","attribute vec3 velocity;","attribute vec4 rotation;","attribute vec3 rotationCenter;","attribute vec4 params;","attribute vec4 size;","attribute vec4 angle;","attribute vec4 color;","attribute vec4 opacity;"].join(`
`),varyings:["varying vec4 vColor;","#ifdef SHOULD_ROTATE_TEXTURE","    varying float vAngle;","#endif","#ifdef SHOULD_CALCULATE_SPRITE","    varying vec4 vSpriteSheet;","#endif"].join(`
`),branchAvoidanceFunctions:["float when_gt(float x, float y) {","    return max(sign(x - y), 0.0);","}","float when_lt(float x, float y) {","    return min( max(1.0 - sign(x - y), 0.0), 1.0 );","}","float when_eq( float x, float y ) {","    return 1.0 - abs( sign( x - y ) );","}","float when_ge(float x, float y) {","  return 1.0 - when_lt(x, y);","}","float when_le(float x, float y) {","  return 1.0 - when_gt(x, y);","}","float and(float a, float b) {","    return a * b;","}","float or(float a, float b) {","    return min(a + b, 1.0);","}"].join(`
`),unpackColor:["vec3 unpackColor( in float hex ) {","   vec3 c = vec3( 0.0 );","   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float b = mod( hex, PACKED_COLOR_SIZE );","   c.r = r / PACKED_COLOR_DIVISOR;","   c.g = g / PACKED_COLOR_DIVISOR;","   c.b = b / PACKED_COLOR_DIVISOR;","   return c;","}"].join(`
`),unpackRotationAxis:["vec3 unpackRotationAxis( in float hex ) {","   vec3 c = vec3( 0.0 );","   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float b = mod( hex, PACKED_COLOR_SIZE );","   c.r = r / PACKED_COLOR_DIVISOR;","   c.g = g / PACKED_COLOR_DIVISOR;","   c.b = b / PACKED_COLOR_DIVISOR;","   c *= vec3( 2.0 );","   c -= vec3( 1.0 );","   return c;","}"].join(`
`),floatOverLifetime:["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {","    highp float value = 0.0;","    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );","    float fIndex = 0.0;","    float shouldApplyValue = 0.0;","    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );","","    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {","       fIndex = float( i );","       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );","       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );","    }","","    return value;","}"].join(`
`),colorOverLifetime:["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {","    vec3 value = vec3( 0.0 );","    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );","    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );","    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );","    return value;","}"].join(`
`),paramFetchingFunctions:["float getAlive() {","   return params.x;","}","float getAge() {","   return params.y;","}","float getMaxAge() {","   return params.z;","}","float getWiggle() {","   return params.w;","}"].join(`
`),forceFetchingFunctions:["vec4 getPosition( in float age ) {","   return modelViewMatrix * vec4( position, 1.0 );","}","vec3 getVelocity( in float age ) {","   return velocity * age;","}","vec3 getAcceleration( in float age ) {","   return acceleration.xyz * age;","}"].join(`
`),rotationFunctions:["#ifdef SHOULD_ROTATE_PARTICLES","   mat4 getRotationMatrix( in vec3 axis, in float angle) {","       axis = normalize(axis);","       float s = sin(angle);","       float c = cos(angle);","       float oc = 1.0 - c;","","       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,","                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,","                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,","                   0.0,                                0.0,                                0.0,                                1.0);","   }","","   vec3 getRotation( in vec3 pos, in float positionInTime ) {","      if( rotation.y == 0.0 ) {","           return pos;","      }","","      vec3 axis = unpackRotationAxis( rotation.x );","      vec3 center = rotationCenter;","      vec3 translated;","      mat4 rotationMatrix;","      float angle = 0.0;","      angle += when_eq( rotation.z, 0.0 ) * rotation.y;","      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );","      translated = rotationCenter - pos;","      rotationMatrix = getRotationMatrix( axis, angle );","      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );","   }","#endif"].join(`
`),rotateTexture:["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );","","    #ifdef SHOULD_ROTATE_TEXTURE","       float x = gl_PointCoord.x - 0.5;","       float y = 1.0 - gl_PointCoord.y - 0.5;","       float c = cos( -vAngle );","       float s = sin( -vAngle );","       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );","    #endif","","    #ifdef SHOULD_CALCULATE_SPRITE","        float framesX = vSpriteSheet.x;","        float framesY = vSpriteSheet.y;","        float columnNorm = vSpriteSheet.z;","        float rowNorm = vSpriteSheet.w;","        vUv.x = gl_PointCoord.x * framesX + columnNorm;","        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);","    #endif","","    vec4 rotatedTexture = texture2D( tex, vUv );"].join(`
`)},Rm={vertex:[Fe.defines,Fe.uniforms,Fe.attributes,Fe.varyings,dt.common,dt.logdepthbuf_pars_vertex,dt.fog_pars_fragment,Fe.branchAvoidanceFunctions,Fe.unpackColor,Fe.unpackRotationAxis,Fe.floatOverLifetime,Fe.colorOverLifetime,Fe.paramFetchingFunctions,Fe.forceFetchingFunctions,Fe.rotationFunctions,"void main() {","    highp float age = getAge();","    highp float alive = getAlive();","    highp float maxAge = getMaxAge();","    highp float positionInTime = (age / maxAge);","    highp float isAlive = when_gt( alive, 0.0 );","    #ifdef SHOULD_WIGGLE_PARTICLES","        float wiggleAmount = positionInTime * getWiggle();","        float wiggleSin = isAlive * sin( wiggleAmount );","        float wiggleCos = isAlive * cos( wiggleAmount );","    #endif","    vec3 vel = getVelocity( age );","    vec3 accel = getAcceleration( age );","    vec3 force = vec3( 0.0 );","    vec3 pos = vec3( position );","    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;","    force += vel;","    force *= drag;","    force += accel * age;","    pos += force;","    #ifdef SHOULD_WIGGLE_PARTICLES","        pos.x += wiggleSin;","        pos.y += wiggleCos;","        pos.z += wiggleSin;","    #endif","    #ifdef SHOULD_ROTATE_PARTICLES","        pos = getRotation( pos, positionInTime );","    #endif","    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );","    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;","    #ifdef HAS_PERSPECTIVE","        float perspective = scale / length( mvPosition.xyz );","    #else","        float perspective = 1.0;","    #endif","    float pointSizePerspective = pointSize * perspective;","    #ifdef COLORIZE","       vec3 c = isAlive * getColorOverLifetime(","           positionInTime,","           unpackColor( color.x ),","           unpackColor( color.y ),","           unpackColor( color.z ),","           unpackColor( color.w )","       );","    #else","       vec3 c = vec3(1.0);","    #endif","    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );","    vColor = vec4( c, o );","    #ifdef SHOULD_ROTATE_TEXTURE","        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );","    #endif","    #ifdef SHOULD_CALCULATE_SPRITE","        float framesX = textureAnimation.x;","        float framesY = textureAnimation.y;","        float loopCount = textureAnimation.w;","        float totalFrames = textureAnimation.z;","        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );","        float column = floor(mod( frameNumber, framesX ));","        float row = floor( (frameNumber - column) / framesX );","        float columnNorm = column / framesX;","        float rowNorm = row / framesY;","        vSpriteSheet.x = 1.0 / framesX;","        vSpriteSheet.y = 1.0 / framesY;","        vSpriteSheet.z = columnNorm;","        vSpriteSheet.w = rowNorm;","    #endif","    gl_PointSize = pointSizePerspective;","    gl_Position = projectionMatrix * mvPosition;",dt.logdepthbuf_vertex,"}"].join(`
`),fragment:[Fe.uniforms,dt.common,dt.fog_pars_fragment,dt.logdepthbuf_pars_fragment,Fe.varyings,Fe.branchAvoidanceFunctions,"void main() {","    vec3 outgoingLight = vColor.xyz;","    ","    #ifdef ALPHATEST","       if ( vColor.w < float(ALPHATEST) ) discard;","    #endif",Fe.rotateTexture,dt.logdepthbuf_fragment,"    outgoingLight = vColor.xyz * rotatedTexture.xyz;","    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );",dt.fog_fragment,"}"].join(`
`)},$n=function(){function s(e){var i=Y.types,n=Br.valueOverLifetimeLength;for(var r in(e=Y.ensureTypedArg(e,i.OBJECT,{})).position=Y.ensureTypedArg(e.position,i.OBJECT,{}),e.velocity=Y.ensureTypedArg(e.velocity,i.OBJECT,{}),e.acceleration=Y.ensureTypedArg(e.acceleration,i.OBJECT,{}),e.radius=Y.ensureTypedArg(e.radius,i.OBJECT,{}),e.drag=Y.ensureTypedArg(e.drag,i.OBJECT,{}),e.rotation=Y.ensureTypedArg(e.rotation,i.OBJECT,{}),e.color=Y.ensureTypedArg(e.color,i.OBJECT,{}),e.opacity=Y.ensureTypedArg(e.opacity,i.OBJECT,{}),e.size=Y.ensureTypedArg(e.size,i.OBJECT,{}),e.angle=Y.ensureTypedArg(e.angle,i.OBJECT,{}),e.wiggle=Y.ensureTypedArg(e.wiggle,i.OBJECT,{}),e.maxAge=Y.ensureTypedArg(e.maxAge,i.OBJECT,{}),e.onParticleSpawn&&console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."),this.uuid=re.generateUUID(),this.type=Y.ensureTypedArg(e.type,i.NUMBER,Br.distributions.BOX),this.position={_value:Y.ensureInstanceOf(e.position.value,M,new M),_spread:Y.ensureInstanceOf(e.position.spread,M,new M),_spreadClamp:Y.ensureInstanceOf(e.position.spreadClamp,M,new M),_distribution:Y.ensureTypedArg(e.position.distribution,i.NUMBER,this.type),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1),_radius:Y.ensureTypedArg(e.position.radius,i.NUMBER,10),_radiusScale:Y.ensureInstanceOf(e.position.radiusScale,M,new M(1,1,1)),_distributionClamp:Y.ensureTypedArg(e.position.distributionClamp,i.NUMBER,0)},this.velocity={_value:Y.ensureInstanceOf(e.velocity.value,M,new M),_spread:Y.ensureInstanceOf(e.velocity.spread,M,new M),_distribution:Y.ensureTypedArg(e.velocity.distribution,i.NUMBER,this.type),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)},this.acceleration={_value:Y.ensureInstanceOf(e.acceleration.value,M,new M),_spread:Y.ensureInstanceOf(e.acceleration.spread,M,new M),_distribution:Y.ensureTypedArg(e.acceleration.distribution,i.NUMBER,this.type),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)},this.drag={_value:Y.ensureTypedArg(e.drag.value,i.NUMBER,0),_spread:Y.ensureTypedArg(e.drag.spread,i.NUMBER,0),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)},this.wiggle={_value:Y.ensureTypedArg(e.wiggle.value,i.NUMBER,0),_spread:Y.ensureTypedArg(e.wiggle.spread,i.NUMBER,0)},this.rotation={_axis:Y.ensureInstanceOf(e.rotation.axis,M,new M(0,1,0)),_axisSpread:Y.ensureInstanceOf(e.rotation.axisSpread,M,new M),_angle:Y.ensureTypedArg(e.rotation.angle,i.NUMBER,0),_angleSpread:Y.ensureTypedArg(e.rotation.angleSpread,i.NUMBER,0),_static:Y.ensureTypedArg(e.rotation.static,i.BOOLEAN,!1),_center:Y.ensureInstanceOf(e.rotation.center,M,this.position._value.clone()),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)},this.maxAge={_value:Y.ensureTypedArg(e.maxAge.value,i.NUMBER,2),_spread:Y.ensureTypedArg(e.maxAge.spread,i.NUMBER,0)},this.color={_value:Y.ensureArrayInstanceOf(e.color.value,tt,new tt),_spread:Y.ensureArrayInstanceOf(e.color.spread,M,new M),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)},this.opacity={_value:Y.ensureArrayTypedArg(e.opacity.value,i.NUMBER,1),_spread:Y.ensureArrayTypedArg(e.opacity.spread,i.NUMBER,0),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)},this.size={_value:Y.ensureArrayTypedArg(e.size.value,i.NUMBER,1),_spread:Y.ensureArrayTypedArg(e.size.spread,i.NUMBER,0),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)},this.angle={_value:Y.ensureArrayTypedArg(e.angle.value,i.NUMBER,0),_spread:Y.ensureArrayTypedArg(e.angle.spread,i.NUMBER,0),_randomise:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)},this.particleCount=Y.ensureTypedArg(e.particleCount,i.NUMBER,100),this.duration=Y.ensureTypedArg(e.duration,i.NUMBER,null),this.isStatic=Y.ensureTypedArg(e.isStatic,i.BOOLEAN,!1),this.activeMultiplier=Y.ensureTypedArg(e.activeMultiplier,i.NUMBER,1),this.direction=Y.ensureTypedArg(e.direction,i.NUMBER,1),this.alive=Y.ensureTypedArg(e.alive,i.BOOLEAN,!0),this.particlesPerSecond=0,this.activationIndex=0,this.attributeOffset=0,this.attributeEnd=0,this.age=0,this.activeParticleCount=0,this.group=null,this.attributes=null,this.paramsArray=null,this.resetFlags={position:Y.ensureTypedArg(e.position.randomise,i.BOOLEAN,!1)||Y.ensureTypedArg(e.radius.randomise,i.BOOLEAN,!1),velocity:Y.ensureTypedArg(e.velocity.randomise,i.BOOLEAN,!1),acceleration:Y.ensureTypedArg(e.acceleration.randomise,i.BOOLEAN,!1)||Y.ensureTypedArg(e.drag.randomise,i.BOOLEAN,!1),rotation:Y.ensureTypedArg(e.rotation.randomise,i.BOOLEAN,!1),rotationCenter:Y.ensureTypedArg(e.rotation.randomise,i.BOOLEAN,!1),size:Y.ensureTypedArg(e.size.randomise,i.BOOLEAN,!1),color:Y.ensureTypedArg(e.color.randomise,i.BOOLEAN,!1),opacity:Y.ensureTypedArg(e.opacity.randomise,i.BOOLEAN,!1),angle:Y.ensureTypedArg(e.angle.randomise,i.BOOLEAN,!1)},this.updateFlags={},this.updateCounts={},this.updateMap={maxAge:"params",position:"position",velocity:"velocity",acceleration:"acceleration",drag:"acceleration",wiggle:"params",rotation:"rotation",size:"size",color:"color",opacity:"opacity",angle:"angle"},this.updateMap)this.updateMap.hasOwnProperty(r)&&(this.updateCounts[this.updateMap[r]]=0,this.updateFlags[this.updateMap[r]]=!1,this._createGetterSetters(this[r],r));this.bufferUpdateRanges={},this.attributeKeys=null,this.attributeCount=0,Y.ensureValueOverLifetimeCompliance(this.color,n,n),Y.ensureValueOverLifetimeCompliance(this.opacity,n,n),Y.ensureValueOverLifetimeCompliance(this.size,n,n),Y.ensureValueOverLifetimeCompliance(this.angle,n,n)}var t=s.prototype;return t._createGetterSetters=function(e,i){var n=this;Object.keys(e).forEach(function(r){var a=r.replace("_","");Object.defineProperty(e,a,{get:function(){return this[r]},set:function(o){var l=n.updateMap[i],h=this[r],c=Br.valueOverLifetimeLength;r==="_rotationCenter"?(n.updateFlags.rotationCenter=!0,this.updateCounts.rotationCenter=0):prop==="_randomise"?n.resetFlags[l]=o:(n.updateFlags[l]=!0,n.updateCounts[l]=0),n.group._updateDefines(),this[r]=o,Array.isArray(h)&&Y.ensureValueOverLifetimeCompliance(n[i],c,c)}})})},t._setBufferUpdateRanges=function(e){this.attributeKeys=e,this.attributeCount=e.length;for(var i=this.attributeCount-1;i>=0;--i)this.bufferUpdateRanges[e[i]]={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY}},t._calculatePPSValue=function(e){var i=this.particleCount;this.duration?this.particlesPerSecond=i/(e<this.duration?e:this.duration):this.particlesPerSecond=i/e},t._setAttributeOffset=function(e){this.attributeOffset=e,this.activationIndex=e,this.activationEnd=e+this.particleCount},t._assignValue=function(e,i){switch(e){case"position":this._assignPositionValue(i);break;case"velocity":case"acceleration":this._assignForceValue(i,e);break;case"size":case"opacity":this._assignAbsLifetimeValue(i,e);break;case"angle":this._assignAngleValue(i);break;case"params":this._assignParamsValue(i);break;case"rotation":this._assignRotationValue(i);break;case"color":this._assignColorValue(i)}},t._assignPositionValue=function(e){var i=Br.distributions,n=this.position,r=this.attributes.position,a=n._value,o=n._spread;switch(n.distribution){case i.BOX:Y.randomVector3(r,e,a,o,n._spreadClamp);break;case i.SPHERE:Y.randomVector3OnSphere(r,e,a,n._radius,n._spread.x,n._radiusScale,n._spreadClamp.x,n._distributionClamp||this.particleCount);break;case i.DISC:Y.randomVector3OnDisc(r,e,a,n._radius,n._spread.x,n._radiusScale,n._spreadClamp.x);break;case i.LINE:Y.randomVector3OnLine(r,e,a,o)}},t._assignForceValue=function(e,i){var n,r,a,o,l,h=Br.distributions,c=this[i],u=c._value,p=c._spread;switch(c._distribution){case h.BOX:Y.randomVector3(this.attributes[i],e,u,p);break;case h.SPHERE:r=(n=this.attributes.position.typedArray.array)[l=3*e],a=n[l+1],o=n[l+2],Y.randomDirectionVector3OnSphere(this.attributes[i],e,r,a,o,this.position._value,c._value.x,c._spread.x);break;case h.DISC:r=(n=this.attributes.position.typedArray.array)[l=3*e],a=n[l+1],o=n[l+2],Y.randomDirectionVector3OnDisc(this.attributes[i],e,r,a,o,this.position._value,c._value.x,c._spread.x);break;case h.LINE:Y.randomVector3OnLine(this.attributes[i],e,u,p)}if(i==="acceleration"){var m=Y.clamp(Y.randomFloat(this.drag._value,this.drag._spread),0,1);this.attributes.acceleration.typedArray.array[4*e+3]=m}},t._assignAbsLifetimeValue=function(e,i){var n,r=this.attributes[i].typedArray,a=this[i];Y.arrayValuesAreEqual(a._value)&&Y.arrayValuesAreEqual(a._spread)?(n=Math.abs(Y.randomFloat(a._value[0],a._spread[0])),r.setVec4Components(e,n,n,n,n)):r.setVec4Components(e,Math.abs(Y.randomFloat(a._value[0],a._spread[0])),Math.abs(Y.randomFloat(a._value[1],a._spread[1])),Math.abs(Y.randomFloat(a._value[2],a._spread[2])),Math.abs(Y.randomFloat(a._value[3],a._spread[3])))},t._assignAngleValue=function(e){var i,n=this.attributes.angle.typedArray,r=this.angle;Y.arrayValuesAreEqual(r._value)&&Y.arrayValuesAreEqual(r._spread)?(i=Y.randomFloat(r._value[0],r._spread[0]),n.setVec4Components(e,i,i,i,i)):n.setVec4Components(e,Y.randomFloat(r._value[0],r._spread[0]),Y.randomFloat(r._value[1],r._spread[1]),Y.randomFloat(r._value[2],r._spread[2]),Y.randomFloat(r._value[3],r._spread[3]))},t._assignParamsValue=function(e){this.attributes.params.typedArray.setVec4Components(e,this.isStatic?1:0,0,Math.abs(Y.randomFloat(this.maxAge._value,this.maxAge._spread)),Y.randomFloat(this.wiggle._value,this.wiggle._spread))},t._assignRotationValue=function(e){this.attributes.rotation.typedArray.setVec3Components(e,Y.getPackedRotationAxis(this.rotation._axis,this.rotation._axisSpread),Y.randomFloat(this.rotation._angle,this.rotation._angleSpread),this.rotation._static?0:1),this.attributes.rotationCenter.typedArray.setVec3(e,this.rotation._center)},t._assignColorValue=function(e){Y.randomColorAsHex(this.attributes.color,e,this.color._value,this.color._spread)},t._resetParticle=function(e){for(var i,n,r=this.resetFlags,a=this.updateFlags,o=this.updateCounts,l=this.attributeKeys,h=this.attributeCount-1;h>=0;--h)n=a[i=l[h]],r[i]!==!0&&n!==!0||(this._assignValue(i,e),this._updateAttributeUpdateRange(i,e),n===!0&&o[i]===this.particleCount?(a[i]=!1,o[i]=0):n===!0&&++o[i])},t._updateAttributeUpdateRange=function(e,i){var n=this.bufferUpdateRanges[e];n.min=Math.min(i,n.min),n.max=Math.max(i,n.max)},t._resetBufferRanges=function(){for(var e,i=this.bufferUpdateRanges,n=this.bufferUpdateKeys,r=this.bufferUpdateCount-1;r>=0;--r)i[e=n[r]].min=Number.POSITIVE_INFINITY,i[e].max=Number.NEGATIVE_INFINITY},t._onRemove=function(){this.particlesPerSecond=0,this.attributeOffset=0,this.activationIndex=0,this.activeParticleCount=0,this.group=null,this.attributes=null,this.paramsArray=null,this.age=0},t._decrementParticleCount=function(){--this.activeParticleCount},t._incrementParticleCount=function(){++this.activeParticleCount},t._checkParticleAges=function(e,i,n,r){for(var a,o,l,h,c=i-1;c>=e;--c)(h=n[a=4*c])!==0&&(l=n[a+1],o=n[a+2],this.direction===1?(l+=r)>=o&&(l=0,h=0,this._decrementParticleCount()):(l-=r)<=0&&(l=o,h=0,this._decrementParticleCount()),n[a]=h,n[a+1]=l,this._updateAttributeUpdateRange("params",c))},t._activateParticles=function(e,i,n,r){for(var a,o,l=this.direction,h=e;h<i;++h)n[a=4*h]!==0&&this.particleCount!==1||(this._incrementParticleCount(),n[a]=1,this._resetParticle(h),o=r*(h-e),n[a+1]=l===-1?n[a+2]-o:o,this._updateAttributeUpdateRange("params",h))},t.update=function(e){if(!this.isStatic){this.paramsArray===null&&(this.paramsArray=this.attributes.params.typedArray.array);var i=this.attributeOffset,n=i+this.particleCount,r=this.paramsArray,a=this.particlesPerSecond*this.activeMultiplier*e,o=this.activationIndex;if(this._resetBufferRanges(),this._checkParticleAges(i,n,r,e),this.alive!==!1){if(this.duration!==null&&this.age>this.duration)return this.alive=!1,void(this.age=0);var l=this.particleCount===1?o:0|o,h=Math.min(l+a,this.activationEnd),c=h-this.activationIndex|0,u=c>0?e/c:0;this._activateParticles(l,h,r,u),this.activationIndex+=a,this.activationIndex>n&&(this.activationIndex=i),this.age+=e}else this.age=0}},t.reset=function(e){if(this.age=0,this.alive=!1,e===!0){for(var i,n=this.attributeOffset,r=n+this.particleCount,a=this.paramsArray,o=this.attributes.params.bufferAttribute,l=r-1;l>=n;--l)a[i=4*l]=0,a[i+1]=0;o.updateRange.offset=0,o.updateRange.count=-1,o.needsUpdate=!0}return this},t.enable=function(){return this.alive=!0,this},t.disable=function(){return this.alive=!1,this},t.remove=function(){return this.group!==null?this.group.removeEmitter(this):console.error("Emitter does not belong to a group, cannot remove."),this},s}(),Dm=function(){function s(e){var i=Y.types;(e=Y.ensureTypedArg(e,i.OBJECT,{})).texture=Y.ensureTypedArg(e.texture,i.OBJECT,{}),this.uuid=re.generateUUID(),this.fixedTimeStep=Y.ensureTypedArg(e.fixedTimeStep,i.NUMBER,.0167),this.texture=e.texture.value||null,this.textureFrames=e.texture.frames||new j(1,1),this.textureFrameCount=Y.ensureTypedArg(e.texture.frameCount,i.NUMBER,this.textureFrames.x*this.textureFrames.y),this.textureLoop=Y.ensureTypedArg(e.texture.loop,i.NUMBER,1),this.textureFrames.max(new j(1,1)),this.hasPerspective=Y.ensureTypedArg(e.hasPerspective,i.BOOLEAN,!0),this.colorize=Y.ensureTypedArg(e.colorize,i.BOOLEAN,!0),this.maxParticleCount=Y.ensureTypedArg(e.maxParticleCount,i.NUMBER,null),this.blending=Y.ensureTypedArg(e.blending,i.NUMBER,xa),this.transparent=Y.ensureTypedArg(e.transparent,i.BOOLEAN,!0),this.alphaTest=parseFloat(Y.ensureTypedArg(e.alphaTest,i.NUMBER,0)),this.depthWrite=Y.ensureTypedArg(e.depthWrite,i.BOOLEAN,!1),this.depthTest=Y.ensureTypedArg(e.depthTest,i.BOOLEAN,!0),this.fog=Y.ensureTypedArg(e.fog,i.BOOLEAN,!0),this.scale=Y.ensureTypedArg(e.scale,i.NUMBER,300),this.emitters=[],this.emitterIDs=[],this._pool=[],this._poolCreationSettings=null,this._createNewWhenPoolEmpty=0,this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!1,this.particleCount=0,this.uniforms={tex:{type:"t",value:this.texture},textureAnimation:{type:"v4",value:new Lt(this.textureFrames.x,this.textureFrames.y,this.textureFrameCount,Math.max(Math.abs(this.textureLoop),1))},fogColor:{type:"c",value:this.fog?new tt:null},fogNear:{type:"f",value:10},fogFar:{type:"f",value:200},fogDensity:{type:"f",value:.5},deltaTime:{type:"f",value:0},runTime:{type:"f",value:0},scale:{type:"f",value:this.scale}},this.defines={HAS_PERSPECTIVE:this.hasPerspective,COLORIZE:this.colorize,VALUE_OVER_LIFETIME_LENGTH:Br.valueOverLifetimeLength,SHOULD_ROTATE_TEXTURE:!1,SHOULD_ROTATE_PARTICLES:!1,SHOULD_WIGGLE_PARTICLES:!1,SHOULD_CALCULATE_SPRITE:this.textureFrames.x>1||this.textureFrames.y>1},this.attributes={position:new zi("v3",!0),acceleration:new zi("v4",!0),velocity:new zi("v3",!0),rotation:new zi("v4",!0),rotationCenter:new zi("v3",!0),params:new zi("v4",!0),size:new zi("v4",!0),angle:new zi("v4",!0),color:new zi("v4",!0),opacity:new zi("v4",!0)},this.attributeKeys=Object.keys(this.attributes),this.attributeCount=this.attributeKeys.length,this.material=new Zt({uniforms:this.uniforms,vertexShader:Rm.vertex,fragmentShader:Rm.fragment,blending:this.blending,transparent:this.transparent,alphaTest:this.alphaTest,depthWrite:this.depthWrite,depthTest:this.depthTest,defines:this.defines,fog:this.fog}),this.geometry=new Pt,this.mesh=new ll(this.geometry,this.material),this.maxParticleCount===null&&console.warn("Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.")}var t=s.prototype;return t._updateDefines=function(){for(var e,i=this.emitters,n=this.defines,r=i.length-1;r>=0;--r)e=i[r],n.SHOULD_CALCULATE_SPRITE||(n.SHOULD_ROTATE_TEXTURE=n.SHOULD_ROTATE_TEXTURE||!!Math.max(Math.max.apply(null,e.angle.value),Math.max.apply(null,e.angle.spread))),n.SHOULD_ROTATE_PARTICLES=n.SHOULD_ROTATE_PARTICLES||!!Math.max(e.rotation.angle,e.rotation.angleSpread),n.SHOULD_WIGGLE_PARTICLES=n.SHOULD_WIGGLE_PARTICLES||!!Math.max(e.wiggle.value,e.wiggle.spread);this.material.needsUpdate=!0},t._applyAttributesToGeometry=function(){var e,i,n=this.attributes,r=this.geometry,a=r.attributes;Object.keys(n).forEach(function(o){e=n[o],(i=a[o])?i.array=e.typedArray.array:r.setAttribute(o,e.bufferAttribute),e.bufferAttribute.needsUpdate=!0}),this.geometry.setDrawRange(0,this.particleCount)},t.addEmitter=function(e){if(e instanceof $n!=0)if(this.emitterIDs.indexOf(e.uuid)>-1)console.error("Emitter already exists in this group. Will not add again.");else{if(e.group===null){var i=this.attributes,n=this.particleCount,r=n+e.particleCount;for(var a in this.particleCount=r,this.maxParticleCount!==null&&this.particleCount>this.maxParticleCount&&console.warn("Group: maxParticleCount exceeded. Requesting",this.particleCount,"particles, can support only",this.maxParticleCount),e._calculatePPSValue(e.maxAge._value+e.maxAge._spread),e._setBufferUpdateRanges(this.attributeKeys),e._setAttributeOffset(n),e.group=this,e.attributes=this.attributes,i)i.hasOwnProperty(a)&&i[a]._createBufferAttribute(this.maxParticleCount!==null?this.maxParticleCount:this.particleCount);for(var o=n;o<r;++o)e._assignPositionValue(o),e._assignForceValue(o,"velocity"),e._assignForceValue(o,"acceleration"),e._assignAbsLifetimeValue(o,"opacity"),e._assignAbsLifetimeValue(o,"size"),e._assignAngleValue(o),e._assignRotationValue(o),e._assignParamsValue(o),e._assignColorValue(o);return this._applyAttributesToGeometry(),this.emitters.push(e),this.emitterIDs.push(e.uuid),this._updateDefines(e),this.material.needsUpdate=!0,this.geometry.needsUpdate=!0,this._attributesNeedRefresh=!0,this}console.error("Emitter already belongs to another group. Will not add to requested group.")}else console.error("`emitter` argument must be instance of Emitter. Was provided with:",e)},t.removeEmitter=function(e){var i=this.emitterIDs.indexOf(e,this.uuid);if(e instanceof $n!=0)if(i!==-1){for(var n=e.attributeOffset,r=n+e.particleCount,a=this.attributes.params.typedArray,o=n;o<r;++o)a.array[4*o]=0,a.array[4*o+1]=0;for(var l in this.emitters.splice(i,1),this.emitterIDs.splice(i,1),this.attributes)this.attributes.hasOwnProperty(l)&&this.attributes[l].splice(n,r);this.particleCount-=e.particleCount,e._onRemove(),this._attributesNeedRefresh=!0}else console.error("Emitter does not exist in this group. Will not remove.");else console.error("`emitter` argument must be instance of Emitter. Was provided with:",e)},t.getFromPool=function(){var e=this._pool,i=this._createNewWhenPoolEmpty;if(e.length)return e.pop();if(i){var n=new $n(this._poolCreationSettings);return this.addEmitter(n),n}return null},t.releaseIntoPool=function(e){if(e instanceof $n!=0)return e.reset(),this._pool.unshift(e),this;console.error("Argument is not instanceof Emitter:",e)},t.getPool=function(){return this._pool},t.addPool=function(e,i,n){var r;this._poolCreationSettings=i,this._createNewWhenPoolEmpty=!!n;for(var a=0;a<e;++a)r=Array.isArray(i)?new $n(i[a]):new $n(i),this.addEmitter(r),this.releaseIntoPool(r);return this},t._triggerSingleEmitter=function(e){var i=this.getFromPool(),n=this;if(i!==null)return e instanceof M&&(i.position.value.copy(e),i.position.value=i.position.value),i.enable(),setTimeout(function(){i.disable(),n.releaseIntoPool(i)},1e3*Math.max(i.duration,i.maxAge.value+i.maxAge.spread)),this;console.log("Group pool ran out.")},t.triggerPoolEmitter=function(e,i){if(typeof e=="number"&&e>1)for(var n=0;n<e;++n)this._triggerSingleEmitter(i);else this._triggerSingleEmitter(i);return this},t._updateUniforms=function(e){this.uniforms.runTime.value+=e,this.uniforms.deltaTime.value=e},t._resetBufferRanges=function(){for(var e=this.attributeKeys,i=this.attributes,n=this.attributeCount-1;n>=0;--n)i[e[n]].resetUpdateRange()},t._updateBuffers=function(e){for(var i,n,r,a=this.attributeKeys,o=this.attributes,l=e.bufferUpdateRanges,h=this.attributeCount-1;h>=0;--h)n=l[i=a[h]],(r=o[i]).setUpdateRange(n.min,n.max),r.flagUpdate()},t.update=function(e){var i,n=this.emitters,r=n.length,a=e||this.fixedTimeStep,o=this.attributeKeys,l=this.attributes;if(this._updateUniforms(a),this._resetBufferRanges(),r!==0||this._attributesNeedRefresh!==!1||this._attributesNeedDynamicReset!==!1){for(var h,c=0;c<r;++c)(h=n[c]).update(a),this._updateBuffers(h);if(this._attributesNeedDynamicReset===!0){for(i=this.attributeCount-1;i>=0;--i)l[o[i]].resetDynamic();this._attributesNeedDynamicReset=!1}if(this._attributesNeedRefresh===!0){for(i=this.attributeCount-1;i>=0;--i)l[o[i]].forceUpdateAll();this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!0}}},t.dispose=function(){return this.geometry.dispose(),this.material.dispose(),this},s}();class Ey extends St{constructor(t,e){super(),d(this,"update",()=>{this._system.update(this._clock.getDelta())}),d(this,"createSnow",()=>new Ie().load(Jt("assets/textures/sky/others/snow.png"))),d(this,"createEmitter",()=>new $n({maxAge:{value:10},position:{value:new M(0,100,150),spread:new M(1e3,1e3,500)},acceleration:{value:new M(0,0,-10),spread:new M(3,3,0)},velocity:{value:new M(0,0,-10),spread:new M(5,5,0)},size:{value:10},particleCount:1e4})),this._renderer=t,this._camera=e,this._clock=new xc;const i=this._system=new Dm({texture:{value:this.createSnow()}}),n=this._emitter=this.createEmitter(e,t);i.addEmitter(n),this.add(i.mesh)}dispose(){}}class Ay extends St{constructor(t,e){super(),d(this,"update",()=>{this._system.update(this._clock.getDelta())}),d(this,"createRain",()=>new Ie().load(Jt("assets/textures/sky/others/trace_01.png"))),d(this,"createEmitter",()=>new $n({maxAge:{value:10},position:{value:new M(0,100,250),spread:new M(1e3,1e3,500)},acceleration:{value:new M(0,0,-20),spread:new M(3,3,0)},velocity:{value:new M(0,10,-20),spread:new M(3,3,0)},size:{value:50},particleCount:2e4})),this._clock=new xc;const i=this._system=new Dm({texture:{value:this.createRain()}}),n=this._emitter=this.createEmitter(e,t);i.addEmitter(n),this.add(i.mesh)}dispose(){}}class Ec extends St{constructor(t){super(),d(this,"_engine"),d(this,"_sky"),d(this,"_snow"),d(this,"_rain"),d(this,"_weather",""),d(this,"_currentConverageTextureType",null),d(this,"_tCoverageIntensity",null),d(this,"_skyGroundColorBlue",new tt(1657983)),d(this,"_skyGroundColorGray",new tt(11184810)),d(this,"_weatherChangedListeners",[]),d(this,"_sunLightScale",.5),d(this,"_skyLightScale",1),d(this,"transitionDuration",1e3),d(this,"_transitionStartTime",0),d(this,"_transitionStartState",null),d(this,"_transitionEndState",null),d(this,"_inTransition",!1),d(this,"handleBeforeRender",e=>{if(this._snow){this._engine.map.getProjectionCenter();const i=this._engine.camera.position;this._snow.position.copy(i),this._snow.update()}if(this._rain){const i=this._engine.camera.position;this._rain.position.copy(i),this._rain.update()}if(this._inTransition){const i=(Date.now()-this._transitionStartTime)/this.transitionDuration;i>1&&(this._inTransition=!1),this._updateWeatherTransitionState(i),e.requestRender()}}),d(this,"_updateWeatherTransitionState",e=>{e<0&&(e=0),e>1&&(e=1);const i=this._transitionStartState,n=this._transitionEndState;this.sunIntensityScale=re.lerp(i.sunIntensityScale,n.sunIntensityScale,e)*this._sunLightScale,this.skyLightIntensity=re.lerp(i.skyLightIntensity,n.skyLightIntensity,e)*this._skyLightScale,this.cloudIntensity=re.lerp(i.cloudIntensity,n.cloudIntensity,e),this.fogDensity=re.lerp(i.fogDensity,n.fogDensity,e),this.mixGrayFactor=re.lerp(i.mixGrayFactor,n.mixGrayFactor,e),this.coverageIntensity=re.lerp(i.coverageIntensity,n.coverageIntensity,e)}),d(this,"beforeRemoveFromEngine",e=>{e.removePrepareRenderListener(this.handleBeforeRender)}),this._sky=t}get weather(){return this._weather}set weather(t){if(t&&t!==this._weather){this._weather=t,this.updateWeather(t);for(const e of this._weatherChangedListeners)e(t)}}afterAddToEngine(t){this._engine=t,t.addPrepareRenderListener(this.handleBeforeRender),this.updateWeather(this._weather)}getCoverageTexture(t){if(this._tCoverageIntensity===null||t!==this._currentConverageTextureType){this._tCoverageIntensity&&this._tCoverageIntensity.dispose();let e="assets/textures/realistic/TexturesCom_Snow_Plain_3x3_512_noise.jpg";t==="rain"&&(e="assets/textures/realistic/TexturesCom_Ground_MudWet_512_roughness.jpg"),this._tCoverageIntensity=new Ie().load(Jt(e),()=>{this._engine.requestRender()})}return this._tCoverageIntensity}updateWeather(t){const e=this._engine;let i=1,n=.2,r=.5,a=0,o=null,l=0,h=0,c=!1,u=!1;if(this._transitionStartState={sunIntensityScale:this.sunIntensityScale/this._sunLightScale,cloudIntensity:this.cloudIntensity,skyLightIntensity:this.skyLightIntensity/this._skyLightScale,coverageIntensity:this.coverageIntensity,fogDensity:this.fogDensity,mixGrayFactor:this.mixGrayFactor},t==="clear")i=1.5,n=0,r=.8,l=0,h=.1;else if(t==="partlyCloudy")i=1.3,n=.7,r=.9,l=.05,h=.2;else if(t==="cloudy")i=0,n=1.2,r=1,l=.5,h=.3;else if(t==="overcast")i=0,n=1.8,r=.4,l=.75,h=.4;else if(t==="foggy")i=0,n=0,r=.4,l=1,h=1;else if(t==="rainy")i=0,n=0,r=.4,u=!0,l=1,h=.5;else{if(t!=="snowy")return;i=0,n=0,r=.4,a=1,o=this.getCoverageTexture("snow"),c=!0,l=1,h=.5}if(this._transitionEndState={sunIntensityScale:i,cloudIntensity:n,skyLightIntensity:r,coverageIntensity:a,fogDensity:h,mixGrayFactor:l},this.tCoverageIntensity=o,this._sky.isStaticSky&&(["overcast","foggy","rainy","snowy"].includes(t)?this._sky.weather="overcast":this._sky.weather=t),c){if(!this._snow){const p=this._snow=new Ey(e.renderer,e.camera);this.add(p)}}else this._snow&&(this.remove(this._snow),this._snow.dispose(),this._snow=null);if(u){if(!this._rain){const p=this._rain=new Ay(e.renderer,e.camera);this.add(p)}}else this._rain&&(this.remove(this._rain),this._rain.dispose(),this._rain=null);this.transitionDuration<=0?this._updateWeatherTransitionState(1):(this._transitionStartTime=Date.now(),this._inTransition=!0,e.requestRender())}addWeatherChangedListener(t){this._weatherChangedListeners.indexOf(t)===-1&&this._weatherChangedListeners.push(t)}removeWeatherChangedListener(t){const e=this._weatherChangedListeners.indexOf(t);e!==-1&&this._weatherChangedListeners.splice(e,1)}get sunIntensityScale(){return this._sky.sunIntensityScale}set sunIntensityScale(t){this._sky.sunIntensityScale=t}get cloudIntensity(){return this._sky.cloudIntensity}set cloudIntensity(t){this._sky.cloudIntensity=t}get skyLightIntensity(){return this._sky.skyLightIntensity}set skyLightIntensity(t){this._sky.skyLightIntensity=t}get groundColor(){return this._sky.groundColor}set groundColor(t){this._sky.groundColor=t}get mixGrayFactor(){return this._sky.mixGrayFactor}set mixGrayFactor(t){this._sky.mixGrayFactor=t}get coverageIntensity(){return this._engine.rendering.composition.coverageIntensity}set coverageIntensity(t){this._engine.rendering.composition.coverageIntensity=t}get tCoverageIntensity(){return this._engine.rendering.composition.tCoverageIntensity}set tCoverageIntensity(t){this._engine.rendering.composition.tCoverageIntensity=t}get tRelectionEnhancement(){return this._engine.rendering.ssr.tEnhancement}set tRelectionEnhancement(t){this._engine.rendering.ssr.tEnhancement=t}set fogDensity(t){this._engine.rendering.fog.density=t}get fogDensity(){return this._engine.rendering.fog.density}get skyLightScale(){return this._skyLightScale}set skyLightScale(t){this._skyLightScale=t}get sunLightScale(){return this._sunLightScale}set sunLightScale(t){this._sunLightScale=t}}class Py{constructor(t){d(this,"_rendering"),d(this,"_useMrt",!1),d(this,"_mainMrt",null),d(this,"_renderPass",null),d(this,"_needsPrepare",!0),d(this,"_antialias",!0),d(this,"_msaaSamples",4),d(this,"cleanup",()=>{this.useMrt&&(this._mainMrt&&this._mainMrt.dispose(),this._mainMrt=null)}),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this._useMrt=t,this._needsPrepare=!0)}_init(){const t=this._rendering,e=t.resolution;if(this.cleanup(),this._useMrt){const i=this._tDepth=new Hp;i.format=Ss,i.type=Ms;const n=this._mainMrt=new Q0(e.x*t.pixelRatio,e.y*t.pixelRatio,4,{samples:this._antialias?this._msaaSamples:0});n.stencilBuffer=!0,n.depthTexture=i,n.depthBuffer=!0;for(let r=0,a=n.texture.length;r<a;r++)n.texture[r].minFilter=Ft,n.texture[r].magFilter=Ft,n.texture[r].encoding=t.outputEncoding,n.texture[r].format=$t;n.texture.isTexture=!0,n.texture.encoding=t.outputEncoding,this._tDiffuse=n.texture[0],this._tEmissive=n.texture[1],this._tNormal=n.texture[2],this._tSpecular=n.texture[3]}}render(){this._needsPrepare&&(this._needsPrepare=!1,this._init());const t=this._rendering,e=t.renderer;this._useMrt?(e.setRenderTarget(this._mainMrt),e.render(t.scene,t.camera)):t.postprocessing.enabled&&t.postprocessing.composer?(e.setRenderTarget(t.postprocessing.composer.readBuffer),e.render(t.scene,t.camera)):(e.setRenderTarget(null),e.render(t.scene,t.camera))}dispose(){this.cleanup()}getTextures(){return this._useMrt?[this._tDiffuse,this._tEmissive,this._tNormal,this._tDepth,this._tSpecular]:[]}setSize(t,e){const i=this._rendering;this._mainMrt&&this._mainMrt.setSize(t*i.pixelRatio,e*i.pixelRatio)}get tDiffuse(){return this._tDiffuse}get tNormal(){return this._tNormal}get tDepth(){return this._tDepth}get tSpecular(){return this._tSpecular}get tEmissive(){return this._tEmissive}get antialias(){return this._antialias}set antialias(t){this._antialias=!!t,t?this._useMrt&&(this._mainMrt.samples=this._msaaSamples):this._useMrt&&(this._mainMrt.samples=0)}}class Ry{constructor(t){d(this,"_rendering"),this._rendering=t}get enabled(){return this._rendering.renderer.shadowMap.enabled}set enabled(t){this._rendering.renderer.shadowMap.enabled=t,t&&(this._rendering.renderer.shadowMap.toneMapping=yd,this._rendering.renderer.shadowMap.toneMappingExposure=0)}}class Dy{constructor(t){d(this,"_needsCreate",!1),d(this,"_fogStartFactor",.5),d(this,"_rendering"),d(this,"_enabled",!1),d(this,"_density",1),d(this,"_color",new tt(16777215)),d(this,"_skyColorStartFactor",.5),d(this,"_altitudeBottom",0),d(this,"_altitudeTop",1e3),d(this,"createFog",()=>{const e=this._rendering;if(e.useMrt){const i=e.composition;i.useFog=!0,i.fogDensity=this._density,i.fogSkyColorStartFactor=this._skyColorStartFactor,i.fogAltitudeTop=this._altitudeTop,i.fogAltitudeBottom=this._altitudeBottom}else e.scene.fog=new hc(this._color,1,1e3)}),d(this,"destoryFog",()=>{const e=this._rendering;e.useMrt?e.composition.useFog=!1:e.scene.fog=null}),this._rendering=t}get enabled(){return this._enabled}set enabled(t){t!==this._enabled&&(this._enabled=t,t?this._needsCreate=!0:this.destoryFog())}set color(t){this._color=t;const e=this._rendering,i=e.useMrt;this._enabled&&(i?e.composition.fogColor=t:e.scene.fog&&(e.scene.fog.color=t))}get color(){return this._color}get density(){return this._density}set density(t){this._density=t;const e=this._rendering,i=e.useMrt;this._enabled&&(i?e.composition.fogDensity=this._density:e.scene.fog&&(e.scene.fog.density=t))}get skyColorStartFactor(){return this._skyColorStartFactor}set skyColorStartFactor(t){this._skyColorStartFactor=t;const e=this._rendering,i=e.useMrt;this._enabled&&i&&(e.composition.fogSkyColorStartFactor=this._skyColorStartFactor)}get altitudeTop(){return this._altitudeTop}set altitudeTop(t){this._altitudeTop=t;const e=this._rendering,i=e.useMrt;this._enabled&&i&&(e.composition.fogAltitudeTop=this._altitudeTop)}get altitudeBottom(){return this._altitudeBottom}set altitudeBottom(t){this._altitudeBottom=t;const e=this._rendering,i=e.useMrt;this._enabled&&i&&(e.composition.fogAltitudeBottom=this._altitudeBottom)}render(){if(this._enabled)if(this._needsCreate&&(this._needsCreate=!1,this.createFog(),this._rendering.requestRender()),this._rendering.useMrt)this._rendering.scene.fog&&(this._rendering.scene.fog=null,this._rendering.requestRender());else{let t=this._rendering.scene.fog;t||(this.createFog(),t=this._rendering.scene.fog,this._rendering.requestRender());const e=this._rendering.camera.far;t.near=this._fogStartFactor*e,t.far=e}}}const ml={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`};class Fs{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const Ly=new Ra(-1,1,1,-1,0,1),Ac=new Pt;Ac.setAttribute("position",new et([-1,3,0,-1,-1,0,3,-1,0],3)),Ac.setAttribute("uv",new et([0,2,0,0,2,0],2));class Vr{constructor(t){this._mesh=new lt(Ac,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,Ly)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}class Hr extends Fs{constructor(t,e){super(),this.textureID=e!==void 0?e:"tDiffuse",t instanceof Zt?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=pt.clone(t.uniforms),this.material=new Zt({defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this.fsQuad=new Vr(this.material)}render(t,e,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this.fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}}class Lm extends Fs{constructor(t,e){super(),this.scene=t,this.camera=e,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,e,i){const n=t.getContext(),r=t.state;let a,o;r.buffers.color.setMask(!1),r.buffers.depth.setMask(!1),r.buffers.color.setLocked(!0),r.buffers.depth.setLocked(!0),this.inverse?(a=0,o=1):(a=1,o=0),r.buffers.stencil.setTest(!0),r.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),r.buffers.stencil.setFunc(n.ALWAYS,a,4294967295),r.buffers.stencil.setClear(o),r.buffers.stencil.setLocked(!0),t.setRenderTarget(i),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),r.buffers.color.setLocked(!1),r.buffers.depth.setLocked(!1),r.buffers.stencil.setLocked(!1),r.buffers.stencil.setFunc(n.EQUAL,1,4294967295),r.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),r.buffers.stencil.setLocked(!0)}}class Iy extends Fs{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}class fl{constructor(t,e){if(this.renderer=t,e===void 0){const i=t.getSize(new j);this._pixelRatio=t.getPixelRatio(),this._width=i.width,this._height=i.height,(e=new de(this._width*this._pixelRatio,this._height*this._pixelRatio)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=e.width,this._height=e.height;this.renderTarget1=e,this.renderTarget2=e.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],ml===void 0&&console.error("THREE.EffectComposer relies on CopyShader"),Hr===void 0&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new Hr(ml),this.clock=new xc}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(t,e){this.passes.splice(e,0,t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(t){const e=this.passes.indexOf(t);e!==-1&&this.passes.splice(e,1)}isLastEnabledPass(t){for(let e=t+1;e<this.passes.length;e++)if(this.passes[e].enabled)return!1;return!0}render(t){t===void 0&&(t=this.clock.getDelta());const e=this.renderer.getRenderTarget();let i=!1;for(let n=0,r=this.passes.length;n<r;n++){const a=this.passes[n];if(a.enabled!==!1){if(a.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(n),a.render(this.renderer,this.writeBuffer,this.readBuffer,t,i),a.needsSwap){if(i){const o=this.renderer.getContext(),l=this.renderer.state.buffers.stencil;l.setFunc(o.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),l.setFunc(o.EQUAL,1,4294967295)}this.swapBuffers()}Lm!==void 0&&(a instanceof Lm?i=!0:a instanceof Iy&&(i=!1))}}this.renderer.setRenderTarget(e)}reset(t){if(t===void 0){const e=this.renderer.getSize(new j);this._pixelRatio=this.renderer.getPixelRatio(),this._width=e.width,this._height=e.height,(t=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,e){this._width=t,this._height=e;const i=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(i,n),this.renderTarget2.setSize(i,n);for(let r=0;r<this.passes.length;r++)this.passes[r].setSize(i,n)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}}new Ra(-1,1,1,-1,0,1);const Im=new Pt;Im.setAttribute("position",new et([-1,3,0,-1,-1,0,3,-1,0],3)),Im.setAttribute("uv",new et([0,2,0,0,2,0],2));class Oy extends Fs{constructor(t,e,i,n,r){super(),this.scene=t,this.camera=e,this.overrideMaterial=i,this.clearColor=n,this.clearAlpha=r!==void 0?r:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new tt}render(t,e,i){const n=t.autoClear;let r,a;t.autoClear=!1,this.overrideMaterial!==void 0&&(a=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(t.getClearColor(this._oldClearColor),r=t.getClearAlpha(),t.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:i),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),this.clearColor&&t.setClearColor(this._oldClearColor,r),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=a),t.autoClear=n}}const Om={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new tt(0)},defaultOpacity:{value:0}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`};class wn extends Fs{constructor(t,e,i,n){super(),this.strength=e!==void 0?e:1,this.radius=i,this.threshold=n,this.resolution=t!==void 0?new j(t.x,t.y):new j(256,256),this.clearColor=new tt(0,0,0);const r={minFilter:Wt,magFilter:Wt,format:$t,type:be};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let a=Math.round(this.resolution.x/2),o=Math.round(this.resolution.y/2);this.renderTargetBright=new de(a,o,r),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let u=0;u<this.nMips;u++){const p=new de(a,o,r);p.texture.name="UnrealBloomPass.h"+u,p.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(p);const m=new de(a,o,r);m.texture.name="UnrealBloomPass.v"+u,m.texture.generateMipmaps=!1,this.renderTargetsVertical.push(m),a=Math.round(a/2),o=Math.round(o/2)}Om===void 0&&console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");const l=Om;this.highPassUniforms=pt.clone(l.uniforms),this.highPassUniforms.luminosityThreshold.value=n,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new Zt({uniforms:this.highPassUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{}}),this.separableBlurMaterials=[];const h=[3,5,7,9,11];a=Math.round(this.resolution.x/2),o=Math.round(this.resolution.y/2);for(let u=0;u<this.nMips;u++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(h[u])),this.separableBlurMaterials[u].uniforms.texSize.value=new j(a,o),a=Math.round(a/2),o=Math.round(o/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=e,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new M(1,1,1),new M(1,1,1),new M(1,1,1),new M(1,1,1),new M(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,ml===void 0&&console.error("THREE.UnrealBloomPass relies on CopyShader");const c=ml;this.copyUniforms=pt.clone(c.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new Zt({uniforms:this.copyUniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:xa,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new tt,this.oldClearAlpha=1,this.basic=new ae,this.fsQuad=new Vr(null)}dispose(){for(let t=0;t<this.renderTargetsHorizontal.length;t++)this.renderTargetsHorizontal[t].dispose();for(let t=0;t<this.renderTargetsVertical.length;t++)this.renderTargetsVertical[t].dispose();this.renderTargetBright.dispose()}setSize(t,e){let i=Math.round(t/2),n=Math.round(e/2);this.renderTargetBright.setSize(i,n);for(let r=0;r<this.nMips;r++)this.renderTargetsHorizontal[r].setSize(i,n),this.renderTargetsVertical[r].setSize(i,n),this.separableBlurMaterials[r].uniforms.texSize.value=new j(i,n),i=Math.round(i/2),n=Math.round(n/2)}render(t,e,i,n,r){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const a=t.autoClear;t.autoClear=!1,t.setClearColor(this.clearColor,0),r&&t.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=i.texture,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),this.highPassUniforms.tDiffuse.value=i.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,t.setRenderTarget(this.renderTargetBright),t.clear(),this.fsQuad.render(t);let o=this.renderTargetBright;for(let l=0;l<this.nMips;l++)this.fsQuad.material=this.separableBlurMaterials[l],this.separableBlurMaterials[l].uniforms.colorTexture.value=o.texture,this.separableBlurMaterials[l].uniforms.direction.value=wn.BlurDirectionX,t.setRenderTarget(this.renderTargetsHorizontal[l]),t.clear(),this.fsQuad.render(t),this.separableBlurMaterials[l].uniforms.colorTexture.value=this.renderTargetsHorizontal[l].texture,this.separableBlurMaterials[l].uniforms.direction.value=wn.BlurDirectionY,t.setRenderTarget(this.renderTargetsVertical[l]),t.clear(),this.fsQuad.render(t),o=this.renderTargetsVertical[l];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,t.setRenderTarget(this.renderTargetsHorizontal[0]),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,r&&t.state.buffers.stencil.setTest(!0),this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(i),this.fsQuad.render(t)),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=a}getSeperableBlurMaterial(t){return new Zt({defines:{KERNEL_RADIUS:t,SIGMA:t},uniforms:{colorTexture:{value:null},texSize:{value:new j(.5,.5)},direction:{value:new j(.5,.5)}},vertexShader:`varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,fragmentShader:`#include <common>
                varying vec2 vUv;
                uniform sampler2D colorTexture;
                uniform vec2 texSize;
                uniform vec2 direction;
                float gaussianPdf(in float x, in float sigma) {
                    return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
                }
                void main() {
                    vec2 invSize = 1.0 / texSize;                    float fSigma = float(SIGMA);                    float weightSum = gaussianPdf(0.0, fSigma);                    float alphaSum = 0.0;                    vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;                    for( int i = 1; i < KERNEL_RADIUS; i ++ ) {                        float x = float(i);                        float w = gaussianPdf(x, fSigma);                        vec2 uvOffset = direction * invSize * x;                        vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);                        vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);                        diffuseSum += (sample1.rgb + sample2.rgb) * w;                        alphaSum += (sample1.a + sample2.a) * w;                        weightSum += 2.0 * w;                    }                    gl_FragColor = vec4(diffuseSum/weightSum, alphaSum/weightSum);
                }`})}getCompositeMaterial(t){return new Zt({defines:{NUM_MIPS:t},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:`varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,fragmentShader:`varying vec2 vUv;
                uniform sampler2D blurTexture1;
                uniform sampler2D blurTexture2;
                uniform sampler2D blurTexture3;
                uniform sampler2D blurTexture4;
                uniform sampler2D blurTexture5;
                uniform sampler2D dirtTexture;
                uniform float bloomStrength;
                uniform float bloomRadius;
                uniform float bloomFactors[NUM_MIPS];
                uniform vec3 bloomTintColors[NUM_MIPS];
                float lerpBloomFactor(const in float factor) {
                    float mirrorFactor = 1.2 - factor;
                    return mix(factor, mirrorFactor, bloomRadius);
                }
                void main() {
                    gl_FragColor = bloomStrength *
                    (lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
                    lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
                    lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
                    lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
                    lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                }`})}}wn.BlurDirectionX=new j(1,0),wn.BlurDirectionY=new j(0,1);class zy extends wn{render(t,e,i,n,r){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const a=t.autoClear;t.autoClear=!1,t.setClearColor(this.clearColor,0),r&&t.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=e,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),this.highPassUniforms.tDiffuse.value=e,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,t.setRenderTarget(this.renderTargetBright),t.clear(),this.fsQuad.render(t);let o=this.renderTargetBright;for(let l=0;l<this.nMips;l++)this.fsQuad.material=this.separableBlurMaterials[l],this.separableBlurMaterials[l].uniforms.colorTexture.value=o.texture,this.separableBlurMaterials[l].uniforms.direction.value=wn.BlurDirectionX,t.setRenderTarget(this.renderTargetsHorizontal[l]),t.clear(),this.fsQuad.render(t),this.separableBlurMaterials[l].uniforms.colorTexture.value=this.renderTargetsHorizontal[l].texture,this.separableBlurMaterials[l].uniforms.direction.value=wn.BlurDirectionY,t.setRenderTarget(this.renderTargetsVertical[l]),t.clear(),this.fsQuad.render(t),o=this.renderTargetsVertical[l];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,t.setRenderTarget(this.renderTargetsHorizontal[0]),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,r&&t.state.buffers.stencil.setTest(!0),this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(i),this.fsQuad.render(t)),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=a}}const zm=new tt,ky=new tt(0);let km=0;fl.prototype.dispose=function(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()},Hr.prototype.dispose=function(){this.material.dispose(),this.fsQuad.dispose()};class Ny{constructor(t){d(this,"_rendering"),d(this,"_strength",3),d(this,"_threshold",0),d(this,"_radius",.5),d(this,"_needsSetTexture",!1),d(this,"_enabled",!1),d(this,"_renderPass",null),d(this,"_useMrt",!1),d(this,"setPresetMaterialToEmissiveWhenNotMrt",e=>{e.isEmissive===void 0&&(e.isMeshStandardMaterial||e.isMeshBasicMaterial)&&Object.defineProperty(e,"isEmissive",{get:function(){return this.userData._shader&&this.userData._shader.uniforms.isEmissive&&this.userData._shader.uniforms.isEmissive.value||!1},set:function(i){this.userData._shader&&this.userData._shader.uniforms.isEmissive&&(this.userData._shader.uniforms.isEmissive.value=i)}}),e.isEmissive===void 0&&e.isMeshBasicMaterial&&Object.defineProperty(e,"emissive",{get:function(){return this.userData._shader&&this.userData._shader.uniforms.isEmissive&&this.userData._shader.uniforms.isEmissive.value||new tt(0)},set:function(i){this.userData._shader&&this.userData._shader.uniforms.isEmissive&&(this.userData._shader.uniforms.isEmissive.value=i)}}),e.isMeshStandardMaterial?e.onBeforeCompile=i=>{i.uniforms.isEmissive={value:e.isEmissive},e.userData._shader=i}:e.isMeshBasicMaterial&&(e.onBeforeCompile=i=>{i.uniforms.isEmissive={value:e.isEmissive},i.uniforms.emissive={value:e.emissive},e.userData._shader=i})}),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this.dispose(),this._useMrt=t)}set enabled(t){(t=!!t)!==this._enabled&&(this._enabled=t,t||this.dispose())}get enabled(){return this._enabled}_init(){const t=this._rendering,e=t.resolution,i=new j(e.x,e.y),n=t.pixelRatio;if(this._bloomRenderTarget=new de(i.x*n,i.y*n,{type:be}),this.useMrt)this._renderPass=new zy(i,this._strength,this._radius,this._threshold),t.composition.tBloom=this._bloomRenderTarget.texture;else{this._renderPass=new wn(i,this._strength,this._radius,this._threshold);const r=this._bloomComposer=new fl(t.renderer,this._bloomRenderTarget);r.renderToScreen=!1;const a=new Oy(t.scene,t.camera,null),o=this._finalPass=new Hr(new Zt({uniforms:{baseTexture:{value:null},bloomTexture:{value:r.renderTarget2.texture}},vertexShader:`#define GLSLIFY 1
varying vec2 vUv;

void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`,fragmentShader:`#define GLSLIFY 1
uniform sampler2D baseTexture;
uniform sampler2D bloomTexture;

varying vec2 vUv;

void main() {

    // gl_FragColor = texture2D( bloomTexture, vUv );
    gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

}`,defines:{}}),"baseTexture");o.needsSwap=!0,o.renderOrder=-100,r.addPass(a),r.addPass(this._renderPass),t.postprocessing.addPass(this._finalPass)}}render(){if(!this._enabled)return;this._enabled&&!this._renderPass&&this._init();const t=this._rendering;if(!this._useMrt){const n=this._rendering.scene;return n.traverse(r=>{r.material&&(this.setPresetMaterialToEmissiveWhenNotMrt(r.material),r.material.isEmissive=!0)}),this._bloomComposer.render(),void n.traverse(r=>{r.material&&(r.material.isEmissive=!1)})}const e=t.main.tEmissive,i=t.renderer;i.setRenderTarget(this._bloomRenderTarget),i.getClearColor(zm),km=i.getClearAlpha(),i.setClearColor(ky),i.setClearAlpha(0),i.clear(),i.setClearColor(zm),i.setClearAlpha(km),this._renderPass.render(t.renderer,e,this._bloomRenderTarget)}dispose(){this._rendering.composition.tBloom=null,this._finalPass&&this._rendering.postprocessing&&this._rendering.postprocessing.removePass(this._finalPass),this._bloomComposer&&(this._bloomComposer.dispose(),this._bloomComposer=null),this._renderPass&&(this._renderPass.dispose(),this._renderPass=null),this._bloomRenderTarget&&(this._bloomRenderTarget.dispose(),this._bloomRenderTarget=null)}getTextures(){const t=[];return this._bloomRenderTarget&&t.push(this._bloomRenderTarget.texture),t}setSize(t,e){this._rendering,this._bloomRenderTarget&&this._bloomRenderTarget.setSize(t,e)}get tBloom(){return this._bloomRenderTarget&&this._bloomRenderTarget.texture||null}get strength(){return this._strength}set strength(t){this._strength=t,this._renderPass&&(this._renderPass.strength=t)}get radius(){return this._radius}set radius(t){this._radius=t,this._renderPass&&(this._renderPass.radius=t)}get threshold(){return this._threshold}set threshold(t){this._threshold=t,this._renderPass&&(this._renderPass.threshold=t)}}var Nm={exports:{}},Um={exports:{}},Uy=function(s){return!(!s||typeof s=="string")&&(s instanceof Array||Array.isArray(s)||s.length>=0&&(s.splice instanceof Function||Object.getOwnPropertyDescriptor(s,s.length-1)&&s.constructor.name!=="String"))},Fy=Array.prototype.concat,By=Array.prototype.slice,Fm=Um.exports=function(s){for(var t=[],e=0,i=s.length;e<i;e++){var n=s[e];Uy(n)?t=Fy.call(t,By.call(n)):t.push(n)}return t};Fm.wrap=function(s){return function(){return s(Fm(arguments))}};var Va={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},Ha=Um.exports,Bm=Object.hasOwnProperty,Vm=Object.create(null);for(var Pc in Va)Bm.call(Va,Pc)&&(Vm[Va[Pc]]=Pc);var li=Nm.exports={to:{},get:{}};function ts(s,t,e){return Math.min(Math.max(t,s),e)}function gl(s){var t=Math.round(s).toString(16).toUpperCase();return t.length<2?"0"+t:t}li.get=function(s){var t,e;switch(s.substring(0,3).toLowerCase()){case"hsl":t=li.get.hsl(s),e="hsl";break;case"hwb":t=li.get.hwb(s),e="hwb";break;default:t=li.get.rgb(s),e="rgb"}return t?{model:e,value:t}:null},li.get.rgb=function(s){if(!s)return null;var t,e,i,n=[0,0,0,1];if(t=s.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)){for(i=t[2],t=t[1],e=0;e<3;e++){var r=2*e;n[e]=parseInt(t.slice(r,r+2),16)}i&&(n[3]=parseInt(i,16)/255)}else if(t=s.match(/^#([a-f0-9]{3,4})$/i)){for(i=(t=t[1])[3],e=0;e<3;e++)n[e]=parseInt(t[e]+t[e],16);i&&(n[3]=parseInt(i+i,16)/255)}else if(t=s.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)){for(e=0;e<3;e++)n[e]=parseInt(t[e+1],0);t[4]&&(t[5]?n[3]=.01*parseFloat(t[4]):n[3]=parseFloat(t[4]))}else{if(!(t=s.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)))return(t=s.match(/^(\w+)$/))?t[1]==="transparent"?[0,0,0,0]:Bm.call(Va,t[1])?((n=Va[t[1]])[3]=1,n):null:null;for(e=0;e<3;e++)n[e]=Math.round(2.55*parseFloat(t[e+1]));t[4]&&(t[5]?n[3]=.01*parseFloat(t[4]):n[3]=parseFloat(t[4]))}for(e=0;e<3;e++)n[e]=ts(n[e],0,255);return n[3]=ts(n[3],0,1),n},li.get.hsl=function(s){if(!s)return null;var t=s.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(t){var e=parseFloat(t[4]);return[(parseFloat(t[1])%360+360)%360,ts(parseFloat(t[2]),0,100),ts(parseFloat(t[3]),0,100),ts(isNaN(e)?1:e,0,1)]}return null},li.get.hwb=function(s){if(!s)return null;var t=s.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(t){var e=parseFloat(t[4]);return[(parseFloat(t[1])%360+360)%360,ts(parseFloat(t[2]),0,100),ts(parseFloat(t[3]),0,100),ts(isNaN(e)?1:e,0,1)]}return null},li.to.hex=function(){var s=Ha(arguments);return"#"+gl(s[0])+gl(s[1])+gl(s[2])+(s[3]<1?gl(Math.round(255*s[3])):"")},li.to.rgb=function(){var s=Ha(arguments);return s.length<4||s[3]===1?"rgb("+Math.round(s[0])+", "+Math.round(s[1])+", "+Math.round(s[2])+")":"rgba("+Math.round(s[0])+", "+Math.round(s[1])+", "+Math.round(s[2])+", "+s[3]+")"},li.to.rgb.percent=function(){var s=Ha(arguments),t=Math.round(s[0]/255*100),e=Math.round(s[1]/255*100),i=Math.round(s[2]/255*100);return s.length<4||s[3]===1?"rgb("+t+"%, "+e+"%, "+i+"%)":"rgba("+t+"%, "+e+"%, "+i+"%, "+s[3]+")"},li.to.hsl=function(){var s=Ha(arguments);return s.length<4||s[3]===1?"hsl("+s[0]+", "+s[1]+"%, "+s[2]+"%)":"hsla("+s[0]+", "+s[1]+"%, "+s[2]+"%, "+s[3]+")"},li.to.hwb=function(){var s=Ha(arguments),t="";return s.length>=4&&s[3]!==1&&(t=", "+s[3]),"hwb("+s[0]+", "+s[1]+"%, "+s[2]+"%"+t+")"},li.to.keyword=function(s){return Vm[s.slice(0,3)]};const ja={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},Hm={};for(const s of Object.keys(ja))Hm[ja[s]]=s;const ft={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};var jm=ft;for(const s of Object.keys(ft)){if(!("channels"in ft[s]))throw new Error("missing channels property: "+s);if(!("labels"in ft[s]))throw new Error("missing channel labels property: "+s);if(ft[s].labels.length!==ft[s].channels)throw new Error("channel and label counts mismatch: "+s);const{channels:t,labels:e}=ft[s];delete ft[s].channels,delete ft[s].labels,Object.defineProperty(ft[s],"channels",{value:t}),Object.defineProperty(ft[s],"labels",{value:e})}ft.rgb.hsl=function(s){const t=s[0]/255,e=s[1]/255,i=s[2]/255,n=Math.min(t,e,i),r=Math.max(t,e,i),a=r-n;let o,l;r===n?o=0:t===r?o=(e-i)/a:e===r?o=2+(i-t)/a:i===r&&(o=4+(t-e)/a),o=Math.min(60*o,360),o<0&&(o+=360);const h=(n+r)/2;return l=r===n?0:h<=.5?a/(r+n):a/(2-r-n),[o,100*l,100*h]},ft.rgb.hsv=function(s){let t,e,i,n,r;const a=s[0]/255,o=s[1]/255,l=s[2]/255,h=Math.max(a,o,l),c=h-Math.min(a,o,l),u=function(p){return(h-p)/6/c+.5};return c===0?(n=0,r=0):(r=c/h,t=u(a),e=u(o),i=u(l),a===h?n=i-e:o===h?n=1/3+t-i:l===h&&(n=2/3+e-t),n<0?n+=1:n>1&&(n-=1)),[360*n,100*r,100*h]},ft.rgb.hwb=function(s){const t=s[0],e=s[1];let i=s[2];const n=ft.rgb.hsl(s)[0],r=1/255*Math.min(t,Math.min(e,i));return i=1-1/255*Math.max(t,Math.max(e,i)),[n,100*r,100*i]},ft.rgb.cmyk=function(s){const t=s[0]/255,e=s[1]/255,i=s[2]/255,n=Math.min(1-t,1-e,1-i);return[100*((1-t-n)/(1-n)||0),100*((1-e-n)/(1-n)||0),100*((1-i-n)/(1-n)||0),100*n]},ft.rgb.keyword=function(s){const t=Hm[s];if(t)return t;let e,i=1/0;for(const a of Object.keys(ja)){const o=(r=ja[a],((n=s)[0]-r[0])**2+(n[1]-r[1])**2+(n[2]-r[2])**2);o<i&&(i=o,e=a)}var n,r;return e},ft.keyword.rgb=function(s){return ja[s]},ft.rgb.xyz=function(s){let t=s[0]/255,e=s[1]/255,i=s[2]/255;return t=t>.04045?((t+.055)/1.055)**2.4:t/12.92,e=e>.04045?((e+.055)/1.055)**2.4:e/12.92,i=i>.04045?((i+.055)/1.055)**2.4:i/12.92,[100*(.4124*t+.3576*e+.1805*i),100*(.2126*t+.7152*e+.0722*i),100*(.0193*t+.1192*e+.9505*i)]},ft.rgb.lab=function(s){const t=ft.rgb.xyz(s);let e=t[0],i=t[1],n=t[2];return e/=95.047,i/=100,n/=108.883,e=e>.008856?e**(1/3):7.787*e+16/116,i=i>.008856?i**(1/3):7.787*i+16/116,n=n>.008856?n**(1/3):7.787*n+16/116,[116*i-16,500*(e-i),200*(i-n)]},ft.hsl.rgb=function(s){const t=s[0]/360,e=s[1]/100,i=s[2]/100;let n,r,a;if(e===0)return a=255*i,[a,a,a];n=i<.5?i*(1+e):i+e-i*e;const o=2*i-n,l=[0,0,0];for(let h=0;h<3;h++)r=t+1/3*-(h-1),r<0&&r++,r>1&&r--,a=6*r<1?o+6*(n-o)*r:2*r<1?n:3*r<2?o+(n-o)*(2/3-r)*6:o,l[h]=255*a;return l},ft.hsl.hsv=function(s){const t=s[0];let e=s[1]/100,i=s[2]/100,n=e;const r=Math.max(i,.01);return i*=2,e*=i<=1?i:2-i,n*=r<=1?r:2-r,[t,100*(i===0?2*n/(r+n):2*e/(i+e)),100*((i+e)/2)]},ft.hsv.rgb=function(s){const t=s[0]/60,e=s[1]/100;let i=s[2]/100;const n=Math.floor(t)%6,r=t-Math.floor(t),a=255*i*(1-e),o=255*i*(1-e*r),l=255*i*(1-e*(1-r));switch(i*=255,n){case 0:return[i,l,a];case 1:return[o,i,a];case 2:return[a,i,l];case 3:return[a,o,i];case 4:return[l,a,i];case 5:return[i,a,o]}},ft.hsv.hsl=function(s){const t=s[0],e=s[1]/100,i=s[2]/100,n=Math.max(i,.01);let r,a;a=(2-e)*i;const o=(2-e)*n;return r=e*n,r/=o<=1?o:2-o,r=r||0,a/=2,[t,100*r,100*a]},ft.hwb.rgb=function(s){const t=s[0]/360;let e=s[1]/100,i=s[2]/100;const n=e+i;let r;n>1&&(e/=n,i/=n);const a=Math.floor(6*t),o=1-i;r=6*t-a,1&a&&(r=1-r);const l=e+r*(o-e);let h,c,u;switch(a){default:case 6:case 0:h=o,c=l,u=e;break;case 1:h=l,c=o,u=e;break;case 2:h=e,c=o,u=l;break;case 3:h=e,c=l,u=o;break;case 4:h=l,c=e,u=o;break;case 5:h=o,c=e,u=l}return[255*h,255*c,255*u]},ft.cmyk.rgb=function(s){const t=s[0]/100,e=s[1]/100,i=s[2]/100,n=s[3]/100;return[255*(1-Math.min(1,t*(1-n)+n)),255*(1-Math.min(1,e*(1-n)+n)),255*(1-Math.min(1,i*(1-n)+n))]},ft.xyz.rgb=function(s){const t=s[0]/100,e=s[1]/100,i=s[2]/100;let n,r,a;return n=3.2406*t+-1.5372*e+-.4986*i,r=-.9689*t+1.8758*e+.0415*i,a=.0557*t+-.204*e+1.057*i,n=n>.0031308?1.055*n**(1/2.4)-.055:12.92*n,r=r>.0031308?1.055*r**(1/2.4)-.055:12.92*r,a=a>.0031308?1.055*a**(1/2.4)-.055:12.92*a,n=Math.min(Math.max(0,n),1),r=Math.min(Math.max(0,r),1),a=Math.min(Math.max(0,a),1),[255*n,255*r,255*a]},ft.xyz.lab=function(s){let t=s[0],e=s[1],i=s[2];return t/=95.047,e/=100,i/=108.883,t=t>.008856?t**(1/3):7.787*t+16/116,e=e>.008856?e**(1/3):7.787*e+16/116,i=i>.008856?i**(1/3):7.787*i+16/116,[116*e-16,500*(t-e),200*(e-i)]},ft.lab.xyz=function(s){let t,e,i;e=(s[0]+16)/116,t=s[1]/500+e,i=e-s[2]/200;const n=e**3,r=t**3,a=i**3;return e=n>.008856?n:(e-16/116)/7.787,t=r>.008856?r:(t-16/116)/7.787,i=a>.008856?a:(i-16/116)/7.787,t*=95.047,e*=100,i*=108.883,[t,e,i]},ft.lab.lch=function(s){const t=s[0],e=s[1],i=s[2];let n;return n=360*Math.atan2(i,e)/2/Math.PI,n<0&&(n+=360),[t,Math.sqrt(e*e+i*i),n]},ft.lch.lab=function(s){const t=s[0],e=s[1],i=s[2]/360*2*Math.PI;return[t,e*Math.cos(i),e*Math.sin(i)]},ft.rgb.ansi16=function(s,t=null){const[e,i,n]=s;let r=t===null?ft.rgb.hsv(s)[2]:t;if(r=Math.round(r/50),r===0)return 30;let a=30+(Math.round(n/255)<<2|Math.round(i/255)<<1|Math.round(e/255));return r===2&&(a+=60),a},ft.hsv.ansi16=function(s){return ft.rgb.ansi16(ft.hsv.rgb(s),s[2])},ft.rgb.ansi256=function(s){const t=s[0],e=s[1],i=s[2];return t===e&&e===i?t<8?16:t>248?231:Math.round((t-8)/247*24)+232:16+36*Math.round(t/255*5)+6*Math.round(e/255*5)+Math.round(i/255*5)},ft.ansi16.rgb=function(s){let t=s%10;if(t===0||t===7)return s>50&&(t+=3.5),t=t/10.5*255,[t,t,t];const e=.5*(1+~~(s>50));return[(1&t)*e*255,(t>>1&1)*e*255,(t>>2&1)*e*255]},ft.ansi256.rgb=function(s){if(s>=232){const e=10*(s-232)+8;return[e,e,e]}let t;return s-=16,[Math.floor(s/36)/5*255,Math.floor((t=s%36)/6)/5*255,t%6/5*255]},ft.rgb.hex=function(s){const t=(((255&Math.round(s[0]))<<16)+((255&Math.round(s[1]))<<8)+(255&Math.round(s[2]))).toString(16).toUpperCase();return"000000".substring(t.length)+t},ft.hex.rgb=function(s){const t=s.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!t)return[0,0,0];let e=t[0];t[0].length===3&&(e=e.split("").map(n=>n+n).join(""));const i=parseInt(e,16);return[i>>16&255,i>>8&255,255&i]},ft.rgb.hcg=function(s){const t=s[0]/255,e=s[1]/255,i=s[2]/255,n=Math.max(Math.max(t,e),i),r=Math.min(Math.min(t,e),i),a=n-r;let o,l;return o=a<1?r/(1-a):0,l=a<=0?0:n===t?(e-i)/a%6:n===e?2+(i-t)/a:4+(t-e)/a,l/=6,l%=1,[360*l,100*a,100*o]},ft.hsl.hcg=function(s){const t=s[1]/100,e=s[2]/100,i=e<.5?2*t*e:2*t*(1-e);let n=0;return i<1&&(n=(e-.5*i)/(1-i)),[s[0],100*i,100*n]},ft.hsv.hcg=function(s){const t=s[1]/100,e=s[2]/100,i=t*e;let n=0;return i<1&&(n=(e-i)/(1-i)),[s[0],100*i,100*n]},ft.hcg.rgb=function(s){const t=s[0]/360,e=s[1]/100,i=s[2]/100;if(e===0)return[255*i,255*i,255*i];const n=[0,0,0],r=t%1*6,a=r%1,o=1-a;let l=0;switch(Math.floor(r)){case 0:n[0]=1,n[1]=a,n[2]=0;break;case 1:n[0]=o,n[1]=1,n[2]=0;break;case 2:n[0]=0,n[1]=1,n[2]=a;break;case 3:n[0]=0,n[1]=o,n[2]=1;break;case 4:n[0]=a,n[1]=0,n[2]=1;break;default:n[0]=1,n[1]=0,n[2]=o}return l=(1-e)*i,[255*(e*n[0]+l),255*(e*n[1]+l),255*(e*n[2]+l)]},ft.hcg.hsv=function(s){const t=s[1]/100,e=t+s[2]/100*(1-t);let i=0;return e>0&&(i=t/e),[s[0],100*i,100*e]},ft.hcg.hsl=function(s){const t=s[1]/100,e=s[2]/100*(1-t)+.5*t;let i=0;return e>0&&e<.5?i=t/(2*e):e>=.5&&e<1&&(i=t/(2*(1-e))),[s[0],100*i,100*e]},ft.hcg.hwb=function(s){const t=s[1]/100,e=t+s[2]/100*(1-t);return[s[0],100*(e-t),100*(1-e)]},ft.hwb.hcg=function(s){const t=s[1]/100,e=1-s[2]/100,i=e-t;let n=0;return i<1&&(n=(e-i)/(1-i)),[s[0],100*i,100*n]},ft.apple.rgb=function(s){return[s[0]/65535*255,s[1]/65535*255,s[2]/65535*255]},ft.rgb.apple=function(s){return[s[0]/255*65535,s[1]/255*65535,s[2]/255*65535]},ft.gray.rgb=function(s){return[s[0]/100*255,s[0]/100*255,s[0]/100*255]},ft.gray.hsl=function(s){return[0,0,s[0]]},ft.gray.hsv=ft.gray.hsl,ft.gray.hwb=function(s){return[0,100,s[0]]},ft.gray.cmyk=function(s){return[0,0,0,s[0]]},ft.gray.lab=function(s){return[s[0],0,0]},ft.gray.hex=function(s){const t=255&Math.round(s[0]/100*255),e=((t<<16)+(t<<8)+t).toString(16).toUpperCase();return"000000".substring(e.length)+e},ft.rgb.gray=function(s){return[(s[0]+s[1]+s[2])/3/255*100]};const _l=jm;function Vy(s){const t=function(){const i={},n=Object.keys(_l);for(let r=n.length,a=0;a<r;a++)i[n[a]]={distance:-1,parent:null};return i}(),e=[s];for(t[s].distance=0;e.length;){const i=e.pop(),n=Object.keys(_l[i]);for(let r=n.length,a=0;a<r;a++){const o=n[a],l=t[o];l.distance===-1&&(l.distance=t[i].distance+1,l.parent=i,e.unshift(o))}}return t}function Hy(s,t){return function(e){return t(s(e))}}function jy(s,t){const e=[t[s].parent,s];let i=_l[t[s].parent][s],n=t[s].parent;for(;t[n].parent;)e.unshift(t[n].parent),i=Hy(_l[t[n].parent][n],i),n=t[n].parent;return i.conversion=e,i}const Rc=jm,Gy=function(s){const t=Vy(s),e={},i=Object.keys(t);for(let n=i.length,r=0;r<n;r++){const a=i[r];t[a].parent!==null&&(e[a]=jy(a,t))}return e},jr={};Object.keys(Rc).forEach(s=>{jr[s]={},Object.defineProperty(jr[s],"channels",{value:Rc[s].channels}),Object.defineProperty(jr[s],"labels",{value:Rc[s].labels});const t=Gy(s);Object.keys(t).forEach(e=>{const i=t[e];jr[s][e]=function(n){const r=function(...a){const o=a[0];if(o==null)return o;o.length>1&&(a=o);const l=n(a);if(typeof l=="object")for(let h=l.length,c=0;c<h;c++)l[c]=Math.round(l[c]);return l};return"conversion"in n&&(r.conversion=n.conversion),r}(i),jr[s][e].raw=function(n){const r=function(...a){const o=a[0];return o==null?o:(o.length>1&&(a=o),n(a))};return"conversion"in n&&(r.conversion=n.conversion),r}(i)})});var Wy=jr;const Gr=Nm.exports,hi=Wy,Gm=["keyword","gray","hex"],Dc={};for(const s of Object.keys(hi))Dc[[...hi[s].labels].sort().join("")]=s;const vl={};function Ce(s,t){if(!(this instanceof Ce))return new Ce(s,t);if(t&&t in Gm&&(t=null),t&&!(t in hi))throw new Error("Unknown model: "+t);let e,i;if(s==null)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(s instanceof Ce)this.model=s.model,this.color=[...s.color],this.valpha=s.valpha;else if(typeof s=="string"){const n=Gr.get(s);if(n===null)throw new Error("Unable to parse color from string: "+s);this.model=n.model,i=hi[this.model].channels,this.color=n.value.slice(0,i),this.valpha=typeof n.value[i]=="number"?n.value[i]:1}else if(s.length>0){this.model=t||"rgb",i=hi[this.model].channels;const n=Array.prototype.slice.call(s,0,i);this.color=Lc(n,i),this.valpha=typeof s[i]=="number"?s[i]:1}else if(typeof s=="number")this.model="rgb",this.color=[s>>16&255,s>>8&255,255&s],this.valpha=1;else{this.valpha=1;const n=Object.keys(s);"alpha"in s&&(n.splice(n.indexOf("alpha"),1),this.valpha=typeof s.alpha=="number"?s.alpha:0);const r=n.sort().join("");if(!(r in Dc))throw new Error("Unable to parse color from object: "+JSON.stringify(s));this.model=Dc[r];const{labels:a}=hi[this.model],o=[];for(e=0;e<a.length;e++)o.push(s[a[e]]);this.color=Lc(o)}if(vl[this.model])for(i=hi[this.model].channels,e=0;e<i;e++){const n=vl[this.model][e];n&&(this.color[e]=n(this.color[e]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}Ce.prototype={toString(){return this.string()},toJSON(){return this[this.model]()},string(s){let t=this.model in Gr.to?this:this.rgb();t=t.round(typeof s=="number"?s:1);const e=t.valpha===1?t.color:[...t.color,this.valpha];return Gr.to[t.model](e)},percentString(s){const t=this.rgb().round(typeof s=="number"?s:1),e=t.valpha===1?t.color:[...t.color,this.valpha];return Gr.to.rgb.percent(e)},array(){return this.valpha===1?[...this.color]:[...this.color,this.valpha]},object(){const s={},{channels:t}=hi[this.model],{labels:e}=hi[this.model];for(let i=0;i<t;i++)s[e[i]]=this.color[i];return this.valpha!==1&&(s.alpha=this.valpha),s},unitArray(){const s=this.rgb().color;return s[0]/=255,s[1]/=255,s[2]/=255,this.valpha!==1&&s.push(this.valpha),s},unitObject(){const s=this.rgb().object();return s.r/=255,s.g/=255,s.b/=255,this.valpha!==1&&(s.alpha=this.valpha),s},round(s){return s=Math.max(s||0,0),new Ce([...this.color.map(Xy(s)),this.valpha],this.model)},alpha(s){return s!==void 0?new Ce([...this.color,Math.max(0,Math.min(1,s))],this.model):this.valpha},red:me("rgb",0,we(255)),green:me("rgb",1,we(255)),blue:me("rgb",2,we(255)),hue:me(["hsl","hsv","hsl","hwb","hcg"],0,s=>(s%360+360)%360),saturationl:me("hsl",1,we(100)),lightness:me("hsl",2,we(100)),saturationv:me("hsv",1,we(100)),value:me("hsv",2,we(100)),chroma:me("hcg",1,we(100)),gray:me("hcg",2,we(100)),white:me("hwb",1,we(100)),wblack:me("hwb",2,we(100)),cyan:me("cmyk",0,we(100)),magenta:me("cmyk",1,we(100)),yellow:me("cmyk",2,we(100)),black:me("cmyk",3,we(100)),x:me("xyz",0,we(95.047)),y:me("xyz",1,we(100)),z:me("xyz",2,we(108.833)),l:me("lab",0,we(100)),a:me("lab",1),b:me("lab",2),keyword(s){return s!==void 0?new Ce(s):hi[this.model].keyword(this.color)},hex(s){return s!==void 0?new Ce(s):Gr.to.hex(this.rgb().round().color)},hexa(s){if(s!==void 0)return new Ce(s);const t=this.rgb().round().color;let e=Math.round(255*this.valpha).toString(16).toUpperCase();return e.length===1&&(e="0"+e),Gr.to.hex(t)+e},rgbNumber(){const s=this.rgb().color;return(255&s[0])<<16|(255&s[1])<<8|255&s[2]},luminosity(){const s=this.rgb().color,t=[];for(const[e,i]of s.entries()){const n=i/255;t[e]=n<=.04045?n/12.92:((n+.055)/1.055)**2.4}return .2126*t[0]+.7152*t[1]+.0722*t[2]},contrast(s){const t=this.luminosity(),e=s.luminosity();return t>e?(t+.05)/(e+.05):(e+.05)/(t+.05)},level(s){const t=this.contrast(s);return t>=7?"AAA":t>=4.5?"AA":""},isDark(){const s=this.rgb().color;return(2126*s[0]+7152*s[1]+722*s[2])/1e4<128},isLight(){return!this.isDark()},negate(){const s=this.rgb();for(let t=0;t<3;t++)s.color[t]=255-s.color[t];return s},lighten(s){const t=this.hsl();return t.color[2]+=t.color[2]*s,t},darken(s){const t=this.hsl();return t.color[2]-=t.color[2]*s,t},saturate(s){const t=this.hsl();return t.color[1]+=t.color[1]*s,t},desaturate(s){const t=this.hsl();return t.color[1]-=t.color[1]*s,t},whiten(s){const t=this.hwb();return t.color[1]+=t.color[1]*s,t},blacken(s){const t=this.hwb();return t.color[2]+=t.color[2]*s,t},grayscale(){const s=this.rgb().color,t=.3*s[0]+.59*s[1]+.11*s[2];return Ce.rgb(t,t,t)},fade(s){return this.alpha(this.valpha-this.valpha*s)},opaquer(s){return this.alpha(this.valpha+this.valpha*s)},rotate(s){const t=this.hsl();let e=t.color[0];return e=(e+s)%360,e=e<0?360+e:e,t.color[0]=e,t},mix(s,t){if(!s||!s.rgb)throw new Error('Argument to "mix" was not a Color instance, but rather an instance of '+typeof s);const e=s.rgb(),i=this.rgb(),n=t===void 0?.5:t,r=2*n-1,a=e.alpha()-i.alpha(),o=((r*a==-1?r:(r+a)/(1+r*a))+1)/2,l=1-o;return Ce.rgb(o*e.red()+l*i.red(),o*e.green()+l*i.green(),o*e.blue()+l*i.blue(),e.alpha()*n+i.alpha()*(1-n))}};for(const s of Object.keys(hi)){if(Gm.includes(s))continue;const{channels:t}=hi[s];Ce.prototype[s]=function(...e){return this.model===s?new Ce(this):e.length>0?new Ce(e,s):new Ce([...(i=hi[this.model][s].raw(this.color),Array.isArray(i)?i:[i]),this.valpha],s);var i},Ce[s]=function(...e){let i=e[0];return typeof i=="number"&&(i=Lc(e,t)),new Ce(i,s)}}function Xy(s){return function(t){return function(e,i){return Number(e.toFixed(i))}(t,s)}}function me(s,t,e){s=Array.isArray(s)?s:[s];for(const i of s)(vl[i]||(vl[i]=[]))[t]=e;return s=s[0],function(i){let n;return i!==void 0?(e&&(i=e(i)),n=this[s](),n.color[t]=i,n):(n=this[s]().color[t],e&&(n=e(n)),n)}}function we(s){return function(t){return Math.max(0,Math.min(s,t))}}function Lc(s,t){for(let e=0;e<t;e++)typeof s[e]!="number"&&(s[e]=0);return s}const Wm=Ce;function es(s){if(!s)return new Lt;if(s.isColor)return[s.r,s.g,s.b,1];const t=Yi(s);return new Lt(t[0],t[1],t[2],t[3])}function Xm(s){if(!s)return new M;const t=Yi(s);return new M(t[0],t[1],t[2])}function Yi(s){if(!s)return[1,1,1,1];const t=Wm(s),e=t.unitArray();return[e[0],e[1],e[2],e[3]||t.valpha]}function qm(s){if(!s)return[1,1,1];const t=Wm(s).unitArray();return[t[0],t[1],t[2]]}const qy=Object.freeze(Object.defineProperty({__proto__:null,colorToVec4:es,colorToVec3:Xm,colorToArr4:Yi,colorToArr3:qm},Symbol.toStringTag,{value:"Module"})),is={mvt_emissive:{value:null},mvt_emissiveIntensity:{value:1}},ki={selectedObjectColor:{value:[1,1,0,.5]},selectedObjectIndex:{value:-1},selectedObjectColorMode:{value:0}},Ic={keepSize:{value:!1},zoomUnits:{value:1}},jt=(s,t=[])=>{for(let e of t)Object.defineProperty(s,e,{get:function(){return this.uniforms[e].value},set:function(i){this.uniforms[e].value=i}})},Bs=(s,t=[])=>{for(let e of t)Object.defineProperty(s,e,{get:function(){return this.uniforms[e].value},set:function(i){this.uniforms[e].value=es(i)}})},_i=(s,t=[])=>{for(let[e,i,n]of t)Object.defineProperty(s,e,{get:function(){return this.uniforms[i].value},set:function(r){this.uniforms[i].value=n?n(r):r}})},Qe=(s,t=[])=>{for(let[e,i]of t)Object.defineProperty(s,e,{get:function(){return!!this.defines[i]},set:function(n){this[e]!==n&&(n?this.defines[i]=!0:delete this.defines[i],this.needsUpdate=!0)}})},ns=s=>{Object.defineProperties(s,{selectedObjectColor:{get:function(){return this.uniforms.selectedObjectColor.value},set:function(t){this.uniforms.selectedObjectColor.value=t}},selectedObjectColorMode:{get:function(){return this.uniforms.selectedObjectColorMode.value},set:function(t){this.uniforms.selectedObjectColorMode.value=t}},selectedObjectIndex:{get:function(){return this.uniforms.selectedObjectIndex.value},set:function(t){this.uniforms.selectedObjectIndex.value=t}},selective:{get:function(){return!!this.defines.MVT_ENABLE_SELECTIVE},set:function(t){this.selective!==t&&(t?this.defines.MVT_ENABLE_SELECTIVE=!0:delete this.defines.MVT_ENABLE_SELECTIVE,this.needsUpdate=!0)}}})},Oc=s=>{Object.defineProperties(s,{keepSize:{get:function(){return this.uniforms.keepSize.value},set:function(t){this.uniforms.keepSize.value=t}},zoomUnits:{get:function(){return this.uniforms.zoomUnits.value},set:function(t){this.uniforms.zoomUnits.value=t}},zoomUnitsUniform:{get:function(){return this.uniforms.zoomUnits},set:function(t){this.uniforms.zoomUnits=t}}})},ss=s=>{Object.defineProperties(s,{emissiveEnabled:{get:function(){return this.defines.MVT_EMISSIVE_UNIFORM||!1},set:function(t){t?this.defines.MVT_EMISSIVE_UNIFORM=!0:delete this.defines.MVT_EMISSIVE_UNIFORM}},emissive:{get:function(){return this.uniforms.mvt_emissive.value},set:function(t){t?this.defines.MVT_EMISSIVE_COLOR=!0:delete this.defines.MVT_EMISSIVE_COLOR,this.uniforms.mvt_emissive.value=t}},emissiveIntensity:{get:function(){return this.uniforms.mvt_emissiveIntensity.value},set:function(t){this.uniforms.mvt_emissiveIntensity.value=t}}})},Ym=s=>{const t=s&&s.source&&s.source.data&&s.source.data.height||null;if(t===null)return null;const e=Math.log2(t)-2,i=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),112)),texelHeight:i,maxMip:e}},Yy={tDiffuse:{value:null},tNormal:{value:null},tMetalness:{value:null},tEnhancement:{value:null},tEnhancementScale:{value:new j(20,20)},tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new j},cameraProjectionMatrix:{value:new rt},cameraInverseProjectionMatrix:{value:new rt},mvt_viewInverseMatrix:{value:new rt},mvt_normalInverseMatrix:{value:new Ke},opacity:{value:.5},maxDistance:{value:180},cameraRange:{value:0},thickness:{value:.018},logDepthBufFC:{value:1},threshold:{value:.35}};class Zy extends Zt{constructor(t){super(),this.vertexShader=`#define GLSLIFY 1
varying vec2 vUv;

void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`,this.fragmentShader=`precision highp sampler2D;
#define GLSLIFY 1
varying vec2 vUv;
uniform sampler2D tDepth;
uniform sampler2D tNormal;
uniform sampler2D tMetalness;
uniform sampler2D tDiffuse;

#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
uniform sampler2D tEnhancement;
uniform vec2 tEnhancementScale;
uniform mat4 mvt_viewInverseMatrix;
uniform mat3 mvt_normalInverseMatrix;
#endif

uniform float cameraRange;
uniform vec2 resolution;
uniform float opacity;
uniform float cameraNear;
uniform float cameraFar;
uniform float maxDistance;
uniform float thickness;
uniform mat4 cameraProjectionMatrix;
uniform mat4 cameraInverseProjectionMatrix;
uniform float threshold; // 控制反射最低阈值，低于此致的不计算，可提高性能

#include <packing>
float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
    //x0: point, x1: linePointA, x2: linePointB
    //https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
    return length(cross(x0 - x1, x0 - x2)) / length(x2 - x1);
}
float pointPlaneDistance(vec3 point, vec3 planePoint, vec3 planeNormal) {
    // https://mathworld.wolfram.com/Point-PlaneDistance.html
    //// https://en.wikipedia.org/wiki/Plane_(geometry)
    //// http://paulbourke.net/geometry/pointlineplane/
    float a = planeNormal.x, b = planeNormal.y, c = planeNormal.z;
    float x0 = point.x, y0 = point.y, z0 = point.z;
    float x = planePoint.x, y = planePoint.y, z = planePoint.z;
    float d = -(a * x + b * y + c * z);
    float distance = (a * x0 + b * y0 + c * z0 + d) / sqrt(a * a + b * b + c * c);
    return distance;
}
// https://stackoverflow.com/questions/40373184/world-space-position-from-logarithmic-depth-buffer
float linearize_depth(in float depth) {
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(const in vec2 uv) {
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float getDepth(const in vec2 uv) {
    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
    return linearize_depth(reconstruct_depth(uv)); //exp2(logDepth * 2.0 / logDepthBufFC) - 1.0;
    #else
    return texture2D(tDepth, uv).x;
    #endif

}
float getViewZ(const in float depth) {
    #ifdef PERSPECTIVE_CAMERA
    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    #else
    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
    #endif
}
vec3 getViewPosition(const in vec2 uv, const in float depth/*clip space*/, const in float clipW) {
    vec4 clipPosition = vec4((vec3(uv, depth) - 0.5) * 2.0, 1.0);//ndc
    clipPosition *= clipW; //clip
    return (cameraInverseProjectionMatrix * clipPosition).xyz;//view
}
#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
vec3 getWorldPositionFromDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = cameraInverseProjectionMatrix * clipSpacePosition;
    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;
    return worldSpacePosition.xyz / worldSpacePosition.w;
}
#endif
vec3 getViewNormal(const in vec2 uv) {
    return unpackRGBToNormal(texture2D(tNormal, uv).xyz);
}
vec2 viewPositionToXY(vec3 viewPosition) {
    vec2 xy;
    vec4 clip = cameraProjectionMatrix * vec4(viewPosition, 1);
    xy = clip.xy;//clip
    float clipW = clip.w;
    xy /= clipW;//NDC
    xy = (xy + 1.) / 2.;//uv
    xy *= resolution;//screen
    return xy;
}
void main() {

    float depth = getDepth(vUv);
    vec3 viewNormal = getViewNormal(vUv);
    #ifdef SELECTIVE
    // 完全没反射的表面直接剔除
    float intensity = texture2D(tMetalness, vUv).x;

    #if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
        float dirAlpha = dot(viewNormal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));
        if (dirAlpha > 0.5) {
            vec3 worldSpacePosition = getWorldPositionFromDepth(depth);
            vec2 enhancementUv = vec2(mod(worldSpacePosition.x, tEnhancementScale.x) / tEnhancementScale.x, 
                    mod(worldSpacePosition.y, tEnhancementScale.y) / tEnhancementScale.y);
            float enhancement = texture2D(tEnhancement, enhancementUv).x;
            intensity += (1.0 - enhancement);
        }
        // gl_FragColor = vec4(enhancement, 0.0, 0.0, 1.0);
        // return;
    #endif

    if(intensity < threshold)
        return;
    intensity -= threshold;
    intensity *= 1.0 / (1.0 - threshold);
    #endif

    
    float viewZ = getViewZ(depth);
    // z值已经超过相机远端距离
    if(-viewZ >= cameraFar)
        return;

    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
    // 相机视图下的当前片元坐标
    vec3 viewPosition = getViewPosition(vUv, depth, clipW);

    // 起点的屏幕坐标
    vec2 d0 = gl_FragCoord.xy;
    vec2 d1;

    #ifdef PERSPECTIVE_CAMERA
    // 入射光方向，相机在原点，方向即为坐标的单位向量
    vec3 viewIncidentDir = normalize(viewPosition);
    // 反射光方向
    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);
    #else
    vec3 viewIncidentDir = vec3(0, 0, -1);
    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);
    #endif

    // 反射光线最长距离由输入的最大反射距离和入射角决定
    float maxReflectRayLen = maxDistance / dot(-viewIncidentDir, viewNormal);
    // dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
    // if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
    // maxDistance/maxReflectRayLen=cos(theta)
    // maxDistance/maxReflectRayLen==dot(a,b)
    // maxReflectRayLen==maxDistance/dot(a,b)

    // 反射最远距离下的坐标点
    vec3 d1viewPosition = viewPosition + viewReflectDir * maxReflectRayLen;
    #ifdef PERSPECTIVE_CAMERA
    if(d1viewPosition.z > -cameraNear) {
            //https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
        // 应该是处理反射点溢出相机视野外的情况
        float t = (-cameraNear - viewPosition.z) / viewReflectDir.z;
        d1viewPosition = viewPosition + viewReflectDir * t;
    }
    #endif
    // 反射最远点在屏幕上的位置
    d1 = viewPositionToXY(d1viewPosition);

    // 屏幕像素距离
    float totalLen = length(d1 - d0);
    float xLen = d1.x - d0.x;
    float yLen = d1.y - d0.y;
    // 最大步数取xy方向较大的一个方向，每次步进一个像素
    float totalStep = max(abs(xLen), abs(yLen));
    // x方向每次步进的大小
    float xSpan = xLen / totalStep;
    // y方向每次步进的大小
    float ySpan = yLen / totalStep;
    // 步进次数最大是屏幕对角线距离（应该是横向或者纵向的最大值），实际次数要远小于这个
    for(float i = 0.; i < float(MAX_STEP); i++) {
        if(i >= totalStep)
            break;
        // march到的当前屏幕像素
        vec2 xy = vec2(d0.x + i * xSpan, d0.y + i * ySpan);
        // 跑到屏幕外march失败
        if(xy.x < 0. || xy.x > resolution.x || xy.y < 0. || xy.y > resolution.y)
            break;
        // 当前百分比
        float s = length(xy - d0) / totalLen;
        // 当前uv
        vec2 uv = xy / resolution;
        // 计算当前点的各项参数，和一开始一样
        float d = getDepth(uv);
        float vZ = getViewZ(d);
        // gl_FragColor = vec4(-vZ / 1000., 0.0, 0.0, 1.0);
        // return;
        if(-vZ >= cameraFar)
            continue;
        float cW = cameraProjectionMatrix[2][3] * vZ + cameraProjectionMatrix[3][3];
        // 得到当前点的viewposition
        vec3 vP = getViewPosition(uv, d, cW);

        // 得到当前反射线的z
        #ifdef PERSPECTIVE_CAMERA
            // https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
        float recipVPZ = 1. / viewPosition.z;
        float viewReflectRayZ = 1. / (recipVPZ + s * (1. / d1viewPosition.z - recipVPZ));
        #else
        float viewReflectRayZ = viewPosition.z + s * (d1viewPosition.z - viewPosition.z);
        #endif

        // if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
        // https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
        // 反射线的z小于当前点的z,否则就是被遮挡住了
        if(viewReflectRayZ <= vZ) {

            bool hit;
            #ifdef INFINITE_THICK
            hit = true;
            #else
            // 点到射线的距离
            float away = pointToLineDistance(vP, viewPosition, d1viewPosition);

            // minThickness没看懂，和横向邻接点的viewx差值，大约代表了此处一个像素和实际距离的比例，乘3.0？
            float minThickness;
            vec2 xyNeighbor = xy;
            xyNeighbor.x += 1.;
            vec2 uvNeighbor = xyNeighbor / resolution;
            vec3 vPNeighbor = getViewPosition(uvNeighbor, d, cW);
            minThickness = vPNeighbor.x - vP.x;
            minThickness *= 3.;
            float tk = max(minThickness, thickness);
            // 当距离小于阈值时才算是真正相交
            hit = away <= tk;
            #endif

            if(hit) {
                vec3 vN = getViewNormal(uv);
                // 相交到物体的反面了，march无效
                if(dot(viewReflectDir, vN) >= 0.)
                    continue;
                float distance = pointPlaneDistance(vP, viewPosition, viewNormal);
                // march距离超过最大
                if(distance > maxDistance)
                    break;
                float op = opacity;
                // 随着距离减弱反射，防止反射突然消失
                #ifdef DISTANCE_ATTENUATION
                float ratio = 1. - (distance / maxDistance);
                float attenuation = ratio * ratio;
                op = opacity * attenuation;
                #endif
                // 菲涅尔反射定律，与视野角度偏离越大，颜色权重越大
                #ifdef FRESNEL
                float fresnelCoe = (dot(viewIncidentDir, viewReflectDir) + 1.) / 2.;
                op *= fresnelCoe;
                #endif
                // 读取反射颜色赋给当前片元
                vec4 reflectColor = texture2D(tDiffuse, uv);
                gl_FragColor.xyz = reflectColor.xyz;
                gl_FragColor.a = op;
                #ifdef SELECTIVE
                gl_FragColor.a *= intensity;
                #endif
                break;
            }
        }
    }
}`,this.uniforms=pt.clone(Yy),this.defines={MAX_STEP:0,PERSPECTIVE_CAMERA:!0,DISTANCE_ATTENUATION:!0,FRESNEL:!0,INFINITE_THICK:!1,SELECTIVE:!1},jt(this,["tDiffuse","tNormal","tDepth","tMetalness","cameraNear","cameraFar","threshold","thickness","opacity","tEnhancementScale"]),Qe(this,[]),Object.defineProperties(this,{tEnhancement:{get:function(){return this.uniforms.tEnhancement.value},set:function(e){e?(this.uniforms.tEnhancement.value=e,this.defines.MVT_SSR_USE_ENHANCEMENT_MAP=!0):(this.uniforms.tEnhancement.value=null,delete this.defines.MVT_SSR_USE_ENHANCEMENT_MAP)}}}),this.setValues(t)}dispose(){let t=["tEnhancement","tDiffuse","tNormal","tDepth","tMetalness"];for(let e=0;e<t.length;e++){const i=t[e];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}super.dispose()}}class Jy extends Fs{constructor(t,{tDiffuse:e,tDepth:i,tNormal:n,tMetalness:r,resolution:a}){super();const o=this.material=new Zy;o.uniforms.tDiffuse.value=e,o.uniforms.tDepth.value=i,o.uniforms.tNormal.value=n,o.uniforms.tMetalness.value=r,o.uniforms.resolution.value=a,o.defines.MAX_STEP=Math.sqrt(a.x*a.x+a.y*a.y),o.defines.DISTANCE_ATTENUATION=!0,o.defines.SELECTIVE=!0,this.renderTarget=t,this.fsQuad=new Vr(null)}render(t,e){const i=this.material;i.uniforms.cameraProjectionMatrix.value.copy(e.projectionMatrix),i.uniforms.cameraInverseProjectionMatrix.value.copy(e.projectionMatrixInverse),i.uniforms.mvt_viewInverseMatrix.value.copy(e.matrixWorld),i.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(e.matrixWorldInverse),i.uniforms.cameraNear.value=e.near,i.uniforms.cameraFar.value=e.far,this.fsQuad.material=i,t.setRenderTarget(this.renderTarget),this.fsQuad.render(t)}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class Ky{constructor(t){d(this,"_rendering"),d(this,"_enabled",!1),d(this,"_renderPass",null),d(this,"_threshold",.5),d(this,"_thickness",.018),d(this,"_opacity",.5),d(this,"_useMrt",!1),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this._useMrt=t,t||this.dispose())}set enabled(t){(t=!!t)!==this._enabled&&(this._enabled=t,t||this.dispose())}get enabled(){return this._enabled}_init(){const t=this._rendering,e=t.resolution,i=this._ssrRenderTarget=new de(e.x,e.y,{encoding:t.outputEncoding}),n=this._renderPass=new Jy(i,{tDiffuse:t.main.tDiffuse,tNormal:t.main.tNormal,tMetalness:t.main.tSpecular,tDepth:t.main.tDepth,resolution:e});n.material.threshold=this._threshold,n.material.thickness=this._thickness,n.material.opacity=this._opacity,t.composition.tReflection=i.texture,console.log("ssr init")}render(){if(!this._enabled||!this._useMrt)return;this._enabled&&!this._renderPass&&this._init();const t=this._rendering;this._renderPass.render(t.renderer,t.camera)}dispose(){this._rendering.composition.tReflection=null,this._renderPass&&(this._renderPass.dispose(),this._renderPass=null),this._ssrRenderTarget&&(this._ssrRenderTarget.dispose(),this._ssrRenderTarget=null)}getTextures(){const t=[];return this._ssrRenderTarget&&t.push(this._ssrRenderTarget.texture),t}setSize(t,e){this._ssrRenderTarget&&this._ssrRenderTarget.setSize(t,e)}get tReflection(){return this._ssrRenderTarget&&this._ssrRenderTarget.texture||null}get threshold(){return this._threshold}set threshold(t){this._threshold=t,this._renderPass&&(this._renderPass.material.threshold=t)}get thickness(){return this._thickness}set thickness(t){this._thickness=t,this._renderPass&&(this._renderPass.material.thickness=t)}get opacity(){return this._opacity}set opacity(t){this._opacity=t,this._renderPass&&(this._renderPass.material.opacity=t)}set tEnhancement(t){this._renderPass&&(this._renderPass.material.tEnhancement=t)}get tEnhancement(){return this._renderPass?this._renderPass.material.tEnhancement:null}set tEnhancementScale(t){this._renderPass&&(this._renderPass.material.tEnhancementScale=t)}get tEnhancementScale(){return this._renderPass?this._renderPass.material.tEnhancementScale:null}}const Qy={tDiffuse:{value:null},tBloom:{value:null},tNormal:{value:null},tReflection:{value:null},tDepth:{value:null},tEnv:{value:null},tCount:{value:0},tDebug1:{value:null},tDebug2:{value:null},tDebug3:{value:null},tDebug4:{value:null},debugDimension:{value:new j(.25,.2)},debugOffset:{value:new j(0,0)},mvt_normalInverseMatrix:{value:new Ke},mvt_projectionInverseMatrix:{value:new rt},mvt_viewInverseMatrix:{value:new rt},mvt_projectionMatrix:{value:new rt},coverageColor:{value:new tt(16777215)},coverageSacle:{value:new j(20,20)},coverageIntensity:{value:0},tCoverageIntensity:{value:null},resolution:{value:[1,1]},cameraNear:{value:1},cameraFar:{value:100},logDepthBufFC:{value:1},fogColor:{value:new tt(16777215)},fogDensity:{value:1},fogAltitudeBottom:{value:0},fogAltitudeTop:{value:1e3},fogSkyColorStartFactor:{value:.3},adjustBrightnessFactor:{value:0},adjustContrastFactor:{value:0},adjustSaturationFactor:{value:0}};class $y extends Zt{constructor(t){super(),this.vertexShader=`#define GLSLIFY 1
// attribute vec3 position;
// attribute vec2 uv;
varying vec2 vUv;
// uniform mat4 modelViewMatrix;
// uniform mat4 projectionMatrix;
void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`,this.fragmentShader=`precision highp float;
precision highp int;
#define GLSLIFY 1

#include <common>
#include <packing>
#include <cube_uv_reflection_fragment>

uniform sampler2D tDiffuse;
uniform sampler2D tNormal;
uniform sampler2D tDepth;

#if defined(MVT_POST_ENABLE_BLOOM)
    uniform sampler2D tBloom;
#endif

#if defined(MVT_POST_ENABLE_REFLECTION)
    uniform sampler2D tReflection;
#endif

#if defined(MVT_POST_ENABLE_COVERAGE)
    #if defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)
        uniform sampler2D tCoverageIntensity; 
    #endif
    uniform vec2 coverageSacle;
    uniform float coverageIntensity;
    // 覆盖层颜色
    uniform vec3 coverageColor;
#endif

// 加前缀防止被three.js本身变量覆盖
uniform float cameraNear;
uniform float cameraFar;
uniform mat3 mvt_normalInverseMatrix;
uniform mat4 mvt_projectionMatrix;
uniform mat4 mvt_projectionInverseMatrix;
uniform mat4 mvt_viewInverseMatrix;

#if defined(MVT_POST_USE_FOG)
    uniform vec3 fogColor;
    uniform float fogDensity;
    uniform float fogSkyColorStartFactor;
    uniform float fogAltitudeBottom;
    uniform float fogAltitudeTop;
#endif

#if defined(ENVMAP_TYPE_CUBE_UV)
    uniform sampler2D tEnv;
#elif defined(ENVMAP_TYPE_CUBE)
    uniform samplerCube tEnv;
#endif

#ifdef MVT_POST_ENABLE_COLOR_ADJUST
    uniform float adjustBrightnessFactor;
    uniform float adjustContrastFactor; 
    uniform float adjustSaturationFactor; 
#endif

#ifdef MVT_MRT_POST_DEBUG
    uniform vec2 debugDimension;
    uniform vec2 debugOffset;
    uniform int tCount;
    uniform sampler2D tDebug1;
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 1
        uniform sampler2D tDebug2;
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 2
        uniform sampler2D tDebug3;
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 3
        uniform sampler2D tDebug4;
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 4
        uniform sampler2D tDebug5;
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 5
        uniform sampler2D tDebug6;
    #endif
#endif

varying vec2 vUv;

float linearize_depth(in float depth){
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(const in vec2 uv){
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float getDepth(vec2 uv) {
    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
        return linearize_depth(reconstruct_depth(uv));
    #else
        return texture2D(tDepth, uv).x;
    #endif
}
vec3 getWorldPositionFromDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);

    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];
    // clipSpacePosition *= clipW;
    vec4 viewSpacePosition = mvt_projectionInverseMatrix * clipSpacePosition;
    
    // viewSpacePosition /= viewSpacePosition.w;
    // return viewSpacePosition.xyz;
    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;

    return worldSpacePosition.xyz / worldSpacePosition.w;
}

float getNoramlLength(vec3 normal) {
    if (normal.x < 0. || normal.y < 0. || normal.z < 0.) {
        return 0.;
    }
    return length(normal);
}
void renderOutputColor() {
    vec4 outColor = texture2D(tDiffuse, vUv);

    // bloom
    #if defined(MVT_POST_ENABLE_BLOOM)
    outColor += vec4( 1.0 ) * texture2D(tBloom, vUv);
    #endif

    // reflection
    #if defined(MVT_POST_ENABLE_REFLECTION)
    vec4 reflectionColor = texture2D( tReflection, vUv );
    outColor.xyz = mix(outColor.xyz, reflectionColor.xyz, reflectionColor.w);
    #endif

    vec4 viewNormal = texture2D(tNormal, vUv);
    vec3 normal = unpackRGBToNormal(viewNormal.xyz);
    float normalLength = getNoramlLength(normal);
    
    #if (defined(MVT_POST_ENABLE_COVERAGE) && defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)) || defined(MVT_POST_USE_FOG)
        float depth = getDepth(vUv);
        vec3 worldSpacePosition = getWorldPositionFromDepth(depth);
    #endif

    #if defined(MVT_POST_ENABLE_COVERAGE)
    if (coverageIntensity > 0.0 && normalLength > 0.5) {
        float dirAlpha = dot(normal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));
        if (dirAlpha > 0.2) {
            float coverageAlpha = clamp(0.0, 1.0, dirAlpha) * coverageIntensity;
            vec3 coverageFinalColor = vec3(coverageColor);
            #if defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)
                
                vec2 coverageUv = vec2(mod(worldSpacePosition.x, coverageSacle.x) / coverageSacle.x, 
                    mod(worldSpacePosition.y, coverageSacle.y) / coverageSacle.y);
                coverageAlpha *= texture2D(tCoverageIntensity, coverageUv).x;
            #endif
            // outColor.xyz = vec3(coverageAlpha, 0.0, 0.0);
            outColor.xyz = mix(outColor.xyz, coverageFinalColor, coverageAlpha);
        }
    }
    #endif

    #if defined(MVT_POST_USE_FOG)
        vec3 cameraPosition = mvt_viewInverseMatrix[3].xyz;
        if (cameraPosition.z < 5000.) {
            float fogFactorMultiplier = clamp((5000. - cameraPosition.z) / 2000., 0., 1.);
            float fogDepth = texture2D(tDepth, vUv).x;
            float fogHeight = fogAltitudeTop - fogAltitudeBottom;
            float fogHeightRatio = (clamp(worldSpacePosition.z, fogAltitudeBottom, fogAltitudeTop) - fogAltitudeBottom) / fogHeight;
            // 混合大气雾，只混合除去天空的部分
            // if (normalLength > 0.00001) {
                #if defined(ENVMAP_TYPE_CUBE_UV) || defined(ENVMAP_TYPE_CUBE)
                    vec3 worldViewDir = normalize(worldSpacePosition.xyz - cameraPosition);
                    // worldViewDir.z = clamp(worldSpacePosition.z / 1000.0, 0.0, 0.2);
                    // worldViewDir = reflect(worldViewDir, vec3(0.0, 0.0, 1.0));
                    #if defined(ENVMAP_TYPE_CUBE_UV)
                        vec3 skyColor = textureCubeUV(tEnv, worldViewDir, 0.0).xyz;
                    #else
                        vec3 skyColor = textureCube(tEnv, worldViewDir).xyz;
                    #endif
                    float skyColorDepth = 1.0 - fogSkyColorStartFactor;
                    float skyColrFactor = clamp(fogDepth - fogSkyColorStartFactor, 0.0, skyColorDepth) / skyColorDepth;
                    skyColrFactor = skyColrFactor * skyColrFactor * skyColrFactor;
                    skyColrFactor *= 1.0 - fogHeightRatio;
                    outColor.xyz = mix(outColor.xyz, skyColor, skyColrFactor * fogFactorMultiplier);

                    // outColor.xyz = vec3(abs(normal.xyz)); //vec3(0.0, 0.0, normalLength);
                    // outColor.xyz = vec3(mod(worldSpacePosition.x, 1000.0), mod(worldSpacePosition.y, 1000.0), 0.0);
                    // outColor.xyz = skyColor;
                    // skyColor = vec3(0.0, 0.0, 1.0);
                    // outColor.xyz = vec3(clamp(fogDepth - 0.95, 0.0, 0.05) * 20.0, 0.0, 0.0);
                    // fogCompseColor = mix(fogColor, skyColor, clamp(fogDepth - 0.5, 0.0, 0.5) * 2.0);
                    // fogCompseColor = mix(fogCompseColor, fogColor, clamp(fogDensity - 0.5, 0.0, 1.0));
                #endif
            // }
            float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
            // fogFactor *= clamp(worldSpacePosition.z, 1.0, 0.0);
            // 高度衰减系数
            float heightAttenuation = fogHeightRatio;
            heightAttenuation = clamp(heightAttenuation - (fogDensity - 0.5), 0.0, 1.0);
            fogFactor = clamp(fogFactor - heightAttenuation, 0.0, 1.0);
            // vec3 fogCompseColor = vec3(fogColor);
            // #if defined(ENVMAP_TYPE_CUBE_UV) || defined(ENVMAP_TYPE_CUBE)
            //     vec3 worldViewDir = normalize(worldSpacePosition.xyz - mvt_viewInverseMatrix[3].xyz);
            //     worldViewDir.z = clamp(worldSpacePosition.z / 1000.0, 0.0, 0.2);
            //     // worldViewDir = reflect(worldViewDir, vec3(0.0, 0.0, 1.0));
            //     #if defined(ENVMAP_TYPE_CUBE_UV)
            //         vec3 skyColor = textureCubeUV(tEnv, worldViewDir, 0.0).xyz;
            //     #else
            //         vec3 skyColor = textureCube(tEnv, worldViewDir).xyz;
            //     #endif
            //     // skyColor = vec3(0.0, 0.0, 1.0);
            //     fogCompseColor = mix(fogColor, skyColor, clamp(fogDepth - 0.5, 0.0, 0.5) * 2.0);
            //     fogCompseColor = mix(fogCompseColor, fogColor, clamp(fogDensity - 0.5, 0.0, 1.0));
            // #endif
            
            // outColor.xyz = skyColor;
            outColor.xyz = mix(outColor.xyz, fogColor, fogFactor * fogFactorMultiplier);
        }
    #endif

    #ifdef MVT_POST_ENABLE_COLOR_ADJUST
        // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
        vec3 grayscale = vec3(dot(outColor.xyz,  vec3(0.2126, 0.7152, 0.0722)));
        outColor.xyz = mix(grayscale, outColor.xyz, 1.0 + adjustSaturationFactor);

        outColor.xyz = 0.5 + (1.0 + adjustContrastFactor) * (outColor.xyz - 0.5);
        outColor.xyz = outColor.xyz + adjustBrightnessFactor;
    #endif

    gl_FragColor = outColor;
}

#ifdef MVT_MRT_POST_DEBUG
void renderDebugColor(float u, float v) {
    vec4 color;
    
    if (u < 1.0) {
        color = texture2D(tDebug1, vec2(mod(u, 1.0), v));
    }
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 1
    else if (u < 2.0) {
        color = texture2D(tDebug2, vec2(mod(u, 1.0), v));
    }
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 2
    else if (u < 3.0) {
        color = texture2D(tDebug3, vec2(mod(u, 1.0), v));
    }
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 3
    else if (u < 4.0) {
        color = texture2D(tDebug4, vec2(mod(u, 1.0), v));
    }
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 4
    else if (u < 5.0) {
        color = texture2D(tDebug5, vec2(mod(u, 1.0), v));
    }
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 5
    else if (u < 6.0) {
        color = texture2D(tDebug6, vec2(mod(u, 1.0), v));
    }
    #endif

    gl_FragColor = color;
}
#endif

void main() {

    #ifdef MVT_MRT_POST_DEBUG
        float u = (debugOffset.x + vUv.x) / debugDimension.x;
        float v = (debugOffset.y + vUv.y) / debugDimension.y;
        if (v >= 0.0 && v <= 1.0 && u >= 0.0 && u <= 1.0 * float(tCount)) {
            renderDebugColor(u, v);
        }
        else {
            renderOutputColor();
        }
    #else
        renderOutputColor();
    #endif
    // #include <tonemapping_fragment>
    #include <encodings_fragment>
}`,this.uniforms=pt.clone(Qy),this.defines={MVT_POST_ENABLE_BLOOM:!1,MVT_POST_DEBUG_TEXTURE_COUNT:0,MVT_POST_USE_FOG:!1,MVT_POST_ENABLE_COLOR_ADJUST:!1,CUBEUV_TEXEL_WIDTH:.0003255208333333333,CUBEUV_TEXEL_HEIGHT:.000244140625,CUBEUV_MAX_MIP:"10.0"},jt(this,["tDiffuse","tNormal","tDepth","debugDimension","debugOffset","fogColor","fogDensity","fogAltitudeBottom","fogAltitudeTop","fogSkyColorStartFactor","adjustBrightnessFactor","adjustContrastFactor","adjustSaturationFactor"]),Object.defineProperties(this,{tBloom:{get:function(){return this.uniforms.tBloom.value},set:function(e){e?(this.uniforms.tBloom.value=e,this.defines.MVT_POST_ENABLE_BLOOM=!0):(this.uniforms.tBloom.value=null,delete this.defines.MVT_POST_ENABLE_BLOOM),this.needsUpdate=!0}},tReflection:{get:function(){return this.uniforms.tReflection.value},set:function(e){e?(this.uniforms.tReflection.value=e,this.defines.MVT_POST_ENABLE_REFLECTION=!0):(this.uniforms.tReflection.value=null,delete this.defines.MVT_POST_ENABLE_REFLECTION),this.needsUpdate=!0}},coverageIntensity:{get:function(){return this.uniforms.coverageIntensity.value},set:function(e){this.uniforms.coverageIntensity.value=e,e>0?this.defines.MVT_POST_ENABLE_COVERAGE=!0:delete this.defines.MVT_POST_ENABLE_COVERAGE,(e===0&&this._lastCoverageIntensity>0||e>0&&this._lastCoverageIntensity===0)&&(this.needsUpdate=!0),this._lastCoverageIntensity=e}},tCoverageIntensity:{get:function(){return this.uniforms.tCoverageIntensity.value},set:function(e){e?(this.uniforms.tCoverageIntensity.value=e,this.defines.MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP=!0):(this.uniforms.tCoverageIntensity.value=null,delete this.defines.MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP),this.needsUpdate=!0}},debugTextures:{get:function(){return null},set:function(e){if(Array.isArray(e)){this.defines.MVT_MRT_POST_DEBUG=!0;const i=e.length;this.uniforms.tCount.value=i,this.defines.MVT_POST_DEBUG_TEXTURE_COUNT=i,this.uniforms.tDebug1.value=e[0]||null,this.uniforms.tDebug2.value=e[1]||null,this.uniforms.tDebug3.value=e[2]||null,this.uniforms.tDebug4.value=e[3]||null}else delete this.defines.MVT_MRT_POST_DEBUG,this.defines.MVT_POST_DEBUG_TEXTURE_COUNT=0,this.uniforms.tCount.value=0,this.uniforms.tDebug1.value=null,this.uniforms.tDebug2.value=null,this.uniforms.tDebug3.value=null,this.uniforms.tDebug4.value=null;this.needsUpdate=!0}},useFog:{get:function(){return this.defines.MVT_POST_USE_FOG||!1},set:function(e){e!==!!this.defines.MVT_POST_USE_FOG&&(e?this.defines.MVT_POST_USE_FOG=!0:delete this.defines.MVT_POST_USE_FOG,this.needsUpdate=!0)}},tEnv:{get:function(){return this.uniforms.tEnv.value},set:function(e){if(e!==this.uniforms.tEnv.value){if(e)if(e.mapping===xs){this.defines.ENVMAP_TYPE_CUBE_UV=!0,delete this.defines.ENVMAP_TYPE_CUBE;const i=Ym(e);i&&(this.defines.CUBEUV_TEXEL_WIDTH=i.texelWidth,this.defines.CUBEUV_TEXEL_HEIGHT=i.texelHeight,this.defines.CUBEUV_MAX_MIP=i.maxMip+".0")}else this.defines.ENVMAP_TYPE_CUBE=!0,delete this.defines.ENVMAP_TYPE_CUBE_UV;else delete this.defines.ENVMAP_TYPE_CUBE,delete this.defines.ENVMAP_TYPE_CUBE_UV;this.uniforms.tEnv.value=e,this.needsUpdate=!0}}},colorAdjustEnabled:{get:function(){return this.defines.MVT_POST_ENABLE_COLOR_ADJUST},set:function(e){e!==this.defines.MVT_POST_ENABLE_COLOR_ADJUST&&(e?this.defines.MVT_POST_ENABLE_COLOR_ADJUST=!0:delete this.defines.MVT_POST_ENABLE_COLOR_ADJUST,this.needsUpdate=!0)}}}),this.setValues(t)}dispose(){let t=["tEnv","tDiffuse","tNormal","tDepth","tBloom","tReflection","tCoverageIntensity","tDebug1","tDebug2","tDebug3","tDebug4","tDebug5","tDebug6"];for(let e=0;e<t.length;e++){const i=t[e];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}super.dispose()}}class t1 extends Fs{constructor({tDiffuse:t,tDepth:e,tNormal:i,tMetalness:n,tBloom:r,tReflection:a}){super();const o=this.material=new $y;this.tBloom=r,this.tReflection=a,o.uniforms.tDiffuse.value=t,o.uniforms.tDepth.value=e,o.uniforms.tNormal.value=i,this.fsQuad=new Vr(null),this.renderTarget=null}render(t,e,i){const n=this.material;n.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(e.matrixWorldInverse),n.uniforms.mvt_projectionInverseMatrix.value.copy(e.projectionMatrixInverse),n.uniforms.mvt_projectionMatrix.value.copy(e.projectionMatrix),n.uniforms.mvt_viewInverseMatrix.value.copy(e.matrixWorld),n.uniforms.cameraNear.value=e.near,n.uniforms.cameraFar.value=e.far,n.tEnv=i.environment,this.fsQuad.material=n,t.setRenderTarget(this.renderTarget),this.fsQuad.render(t)}dispose(){this.material.dispose(),this.material=null,this.fsQuad.dispose(),this.fsQuad=null}get tBloom(){return this.material.tBloom}set tBloom(t){this.material.tBloom=t}get tReflection(){return this.material.tReflection}set tReflection(t){this.material.tReflection=t}}class e1{constructor(t){d(this,"_enabled",!0),d(this,"_rendering"),d(this,"_renderPass"),d(this,"_tDiffuse"),d(this,"_tDepth"),d(this,"_tNormal"),d(this,"_tSpecular"),d(this,"_tBloom"),d(this,"_tReflection"),d(this,"_useMrt",!1),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this._useMrt=t,t||this.dispose())}set enabled(t){(t=!!t)!==this._enabled&&(this._enabled=t,t||this.dispose())}get enabled(){return this._enabled}_init(){const t=this._rendering;this._tDiffuse=t.main.tDiffuse,this._tDepth=t.main.tDepth,this._tNormal=t.main.tNormal,this._tSpecular=t.main.tSpecular,this._tBloom=t.bloom.tBloom,this._tReflection=t.ssr.tReflection,this._renderPass=new t1({tDiffuse:this._tDiffuse,tNormal:this._tNormal,tDepth:this._tDepth,tBloom:this._tBloom,tReflection:this._tReflection,tSpecular:this._tSpecular}),this.colorAdjustEnabled=t.colorAdjust.enabled,this.adjustBrightnessFactor=t.colorAdjust.brightness,this.adjustContrastFactor=t.colorAdjust.contrast,this.adjustSaturationFactor=t.colorAdjust.saturation}render(){if(!this._enabled||!this._useMrt)return;this._enabled&&!this._renderPass&&this._init();const t=this._rendering;t.postprocessing.enabled&&t.postprocessing.composer?this._renderPass.renderTarget=t.postprocessing.composer.readBuffer:this._renderPass.renderTarget=null,this._renderPass.render(t.renderer,t.camera,t.scene)}dispose(){this._renderPass&&(this._renderPass.dispose(),this._renderPass=null)}set debugTextures(t){this._renderPass&&(this._renderPass.material.debugTextures=t)}set tDiffuse(t){this._tDiffuse=t,this._renderPass&&(this._renderPass.tDiffuse=t)}set tDepth(t){this._tDepth=t,this._renderPass&&(this._renderPass.tDepth=t)}set tNormal(t){this._tNormal=t,this._renderPass&&(this._renderPass.tNormal=t)}set tBloom(t){this._tBloom=t,this._renderPass&&(this._renderPass.tBloom=t)}set tReflection(t){this._tReflection=t,this._renderPass&&(this._renderPass.tReflection=t)}set tSpecular(t){this._tSpecular=t,this._renderPass&&(this._renderPass.tSpecular=t)}set coverageIntensity(t){this._renderPass&&(this._renderPass.material.coverageIntensity=t)}get coverageIntensity(){return this._renderPass&&this._renderPass.material.coverageIntensity||0}set tCoverageIntensity(t){this._renderPass&&(this._renderPass.material.tCoverageIntensity=t)}get tCoverageIntensity(){return this._renderPass&&null|this._renderPass.material.tCoverageIntensity}get debugDimension(){return this._renderPass&&this._renderPass.material.debugDimension||{x:0,y:0}}get debugOffset(){return this._renderPass&&this._renderPass.material.debugOffset||{x:0,y:0}}get tEnv(){return this._renderPass&&this._renderPass.material.tEnv||null}set tEnv(t){this.renderPass&&(this._renderPass.material.tEnv=t)}get useFog(){return this._renderPass&&this._renderPass.material.useFog||!1}set useFog(t){this._renderPass&&(this._renderPass.material.useFog=t)}get fogDensity(){return this._renderPass&&this._renderPass.material.fogDensity||0}set fogDensity(t){this._renderPass&&(this._renderPass.material.fogDensity=t)}get adjustBrightnessFactor(){return this._renderPass&&this._renderPass.material.adjustBrightnessFactor||0}set adjustBrightnessFactor(t){this._renderPass&&(this._renderPass.material.adjustBrightnessFactor=t)}get colorAdjustEnabled(){return this._renderPass&&this._renderPass.material.colorAdjustEnabled||!1}set colorAdjustEnabled(t){this._renderPass&&(this._renderPass.material.colorAdjustEnabled=!!t)}get adjustContrastFactor(){return this._renderPass&&this._renderPass.material.adjustContrastFactor||0}set adjustContrastFactor(t){this._renderPass&&(this._renderPass.material.adjustContrastFactor=t)}get adjustSaturationFactor(){return this._renderPass&&this._renderPass.material.adjustSaturationFactor||0}set adjustSaturationFactor(t){this._renderPass&&(this._renderPass.material.adjustSaturationFactor=t)}get fogSkyColorStartFactor(){return this._renderPass&&this._renderPass.material.fogSkyColorStartFactor||0}set fogSkyColorStartFactor(t){this._renderPass&&(this._renderPass.material.fogSkyColorStartFactor=t)}get fogAltitudeBottom(){return this._renderPass&&this._renderPass.material.fogAltitudeBottom||0}set fogAltitudeBottom(t){this._renderPass&&(this._renderPass.material.fogAltitudeBottom=t)}get fogAltitudeTop(){return this._renderPass&&this._renderPass.material.fogAltitudeTop||0}set fogAltitudeTop(t){this._renderPass&&(this._renderPass.material.fogAltitudeTop=t)}}const i1={uniforms:{tDiffuse:{value:null}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = LinearTosRGB( tex );

		}`};fl.prototype.dispose=function(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()},Hr.prototype.dispose=function(){this.material.dispose(),this.fsQuad.dispose()};class n1{constructor(t){d(this,"_enabled",!1),d(this,"_useMrt",!1),d(this,"_rendering"),d(this,"_renderComposer"),d(this,"_passes",[]),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this._useMrt=t)}set enabled(t){(t=!!t)!==this._enabled&&(this._enabled=t,t||this.dispose())}get enabled(){return this._enabled}_init(){const t=this._rendering,e=t.renderer,i=t.resolution,n=new j(i.x,i.y),r=t.pixelRatio,a=this._postRenderTarget=new de(n.x*r,n.y*r,{minFilter:Ft,magFilter:Ft,type:be,format:$t,encoding:t.outputEncoding,stencilBuffer:!0,samples:4});a.texture.name="EffectComposer.rt1";const o=this._renderComposer=new fl(e,a);o.setPixelRatio(r),o.setSize(n.x,n.y);const l=new Hr(i1);l.material.transparent=!0,o.addPass(l);for(let h=0;h<this._passes.length;h++){const c=this._passes[h];o.addPass(c)}}render(){if(!this._enabled)return;this._enabled&&!this._renderComposer&&this._init();const t=this._rendering;this.useMrt&&(this._setMrtUniforms("tDiffuse",t.main.tDiffuse),this._setMrtUniforms("tDepth",t.main.tDepth),this._setMrtUniforms("tNormal",t.main.tNormal),this._setMrtUniforms("tSpecular",t.main.tSpecular),this._setMrtUniforms("tBloom",t.bloom.tBloom),this._setMrtUniforms("tReflection",t.ssr.tReflection)),this._renderComposer.render()}_setMrtUniforms(t,e){for(let i=0;i<this._passes.length;i++){const n=this._passes[i];if(n.material){const r=n.material.uniforms;r[t]&&(r[t].value=e)}}}dispose(){this._renderComposer&&(this._renderComposer.dispose(),this._renderComposer=null,this._postRenderTarget=null)}addPass(t){if(this._passes.length!==0||this.enabled||(this.enabled=!0),t&&!t.renderOrder&&(t.renderOrder=0),this._passes.length===0)return this._passes.push(t),void(this._renderComposer&&this._renderComposer.addPass(t));for(let e=this._passes.length-1;e>=0;e--){if(t.renderOrder>=this._passes[e].renderOrder){this._passes.splice(e+1,0,t),this._renderComposer&&this._renderComposer.insertPass(t,e+2);break}e===0&&(this._passes.splice(e,0,t),this._renderComposer&&this._renderComposer.insertPass(t,e+1))}}removePass(t){const e=this._passes.indexOf(t);e!==-1&&(this._passes.splice(e,1),this._renderComposer.removePass(t)),this._passes.length===0&&this.enabled&&(this.enabled=!1)}get composer(){return this._renderComposer}}class s1 extends St{constructor(t){super(),d(this,"_enableRtc",!0),d(this,"_cachedRtc",[0,0,0]),d(this,"makeMeshPositionOffset",e=>{this._cachedRtc=[e[0],e[1],e[2]||0],this.updateTransform()}),d(this,"makeGeometryOffsetPosition",(e,i)=>{if(!this._enableRtc)return;const n=e.boundingSphere&&e.boundingSphere.center;if(!n)return this._cachedRtc=[0,0,0],void this.updateTransform();const{x:r,y:a,z:o}=n;e.isCustomInstancedBufferGeometry?this.makePostionArrayOffset(e.attributes.instancedPosition.array,r,a,o,i):(this.makePostionArrayOffset(e.attributes.position.array,r,a,o,i),e.attributes.position.array.length),e.computeBoundingSphere(),this._cachedRtc=[r,a,o],this.updateTransform()}),d(this,"makePostionArrayOffset",(e,i,n,r,a)=>{if(!e||e.length<3)return;let o=a||e;for(let l=0,h=e.length-2;l<h;l+=3)e[l]=o[l]-i,e[l+1]=o[l+1]-n,e[l+2]=o[l+2]-r}),d(this,"updateTransform",()=>{const[e,i,n]=this._cachedRtc;this.position.set(e,i,n),this.updateMatrixWorld(!0)}),Object.defineProperties(this,{enableRtc:{get:function(){return this._enableRtc},set:function(e){this._enableRtc=e}}})}defineGeometryProxyProperties(t=[]){for(let e=0;e<t.length;e++){const i=t[e];Object.defineProperty(this,i,{get:function(){return this.geometry[i]},set:function(n){this.geometry[i]=n}})}}defineMaterialProxyProperties(t=[]){for(let e=0;e<t.length;e++){const i=t[e];Object.defineProperty(this,i,{get:function(){return this.material[i]},set:function(n){this.material[i]=n}})}}}function Wr(s){var t,e=Math.PI/180,i=6378137,n=20037508342789244e-9,r=[i*(Math.abs(s[0])<=180?s[0]:s[0]-360*((t=s[0])<0?-1:t>0?1:0))*e,i*Math.log(Math.tan(.25*Math.PI+.5*s[1]*e))];return r[0]>n&&(r[0]=n),r[0]<-n&&(r[0]=-n),r[1]>n&&(r[1]=n),r[1]<-n&&(r[1]=-n),r}function zc(s){var t=180/Math.PI,e=6378137;return[s[0]*t/e,(.5*Math.PI-2*Math.atan(Math.exp(-s[1]/e)))*t]}function Xe(){}function kc(s,t){for(let e in t)s[e]=t[e]}function ci(s,t){this.lng=s,this.lat=t}function Xr(s,t){this.x=s,this.y=t}kc(ci.prototype,{equals:function(s){return this.lat===s.lat&&this.lng===s.lng},clone:function(){return new ci(this.lat,this.lng)},getLngSpan:function(s){let t=this.lng,e=Math.abs(s-t);return e>180&&(e=360-e),e},sub:function(s){return new ci(this.lat-s.lat,this.lng-s.lng)},toString:function(){return"Point"}}),kc(Xe,{EARTHRADIUS:637099681e-2,MCBAND:[1289059486e-2,836237787e-2,5591021,348198983e-2,167804312e-2,0],LLBAND:[75,60,45,30,15,0],MC2LL:[[1410526172116255e-23,898305509648872e-20,-1.9939833816331,200.9824383106796,-187.2403703815547,91.6087516669843,-23.38765649603339,2.57121317296198,-.03801003308653,173379812e-1],[-7435856389565537e-24,8983055097726239e-21,-.78625201886289,96.32687599759846,-1.85204757529826,-59.36935905485877,47.40033549296737,-16.50741931063887,2.28786674699375,1026014486e-2],[-3030883460898826e-23,898305509983578e-20,.30071316287616,59.74293618442277,7.357984074871,-25.38371002664745,13.45380521110908,-3.29883767235584,.32710905363475,685681737e-2],[-1981981304930552e-23,8983055099779535e-21,.03278182852591,40.31678527705744,.65659298677277,-4.44255534477492,.85341911805263,.12923347998204,-.04625736007561,448277706e-2],[309191371068437e-23,8983055096812155e-21,6995724062e-14,23.10934304144901,-.00023663490511,-.6321817810242,-.00663494467273,.03430082397953,-.00466043876332,25551644e-1],[2890871144776878e-24,8983055095805407e-21,-3068298e-14,7.47137025468032,-353937994e-14,-.02145144861037,-1234426596e-14,.00010322952773,-323890364e-14,826088.5]],LL2MC:[[-.0015702102444,111320.7020616939,0x60e374c3105a3,-0x24bb4115e2e164,0x5cc55543bb0ae8,-0x7ce070193f3784,0x5e7ca61ddf8150,-0x261a578d8b24d0,0x665d60f3742ca,82.5],[.0008277824516172526,111320.7020463578,6477955746671607e-7,-4082003173641316e-6,1077490566351142e-5,-1517187553151559e-5,1205306533862167e-5,-5124939663577472e-6,9133119359512032e-7,67.5],[.00337398766765,111320.7020202162,4481351045890365e-9,-2339375119931662e-8,7968221547186455e-8,-1159649932797253e-7,9723671115602145e-8,-4366194633752821e-8,8477230501135234e-9,52.5],[.00220636496208,111320.7020209128,51751.86112841131,3796837749470245e-9,992013.7397791013,-122195221711287e-8,1340652697009075e-9,-620943.6990984312,144416.9293806241,37.5],[-.0003441963504368392,111320.7020576856,278.2353980772752,2485758690035394e-9,6070.750963243378,54821.18345352118,9540.606633304236,-2710.55326746645,1405.483844121726,22.5],[-.0003218135878613132,111320.7020701615,.00369383431289,823725.6402795718,.46104986909093,2351.343141331292,1.58060784298199,8.77738589078284,.37238884252424,7.45]],getDistanceByMC:function(s,t){if(!s||!t)return 0;let e,i,n,r;return(s=this.convertMC2LL(s))?(e=this.toRadians(s.lng),i=this.toRadians(s.lat),(t=this.convertMC2LL(t))?(n=this.toRadians(t.lng),r=this.toRadians(t.lat),this.getDistance(e,n,i,r)):0):0},getDistanceByLL:function(s,t){if(!s||!t)return 0;let e,i,n,r;return s.lng=this.getLoop(s.lng,-180,180),s.lat=this.getRange(s.lat,-74,74),t.lng=this.getLoop(t.lng,-180,180),t.lat=this.getRange(t.lat,-74,74),e=this.toRadians(s.lng),n=this.toRadians(s.lat),i=this.toRadians(t.lng),r=this.toRadians(t.lat),this.getDistance(e,i,n,r)},convertMC2LL:function(s){if(s==null)return new ci(0,0);if(s.lng<180&&s.lng>-180&&s.lat<90&&s.lat>-90)return s;let t,e;t=new ci(Math.abs(s.lng),Math.abs(s.lat));for(let n=0;n<this.MCBAND.length;n++)if(t.lat>=this.MCBAND[n]){e=this.MC2LL[n];break}let i=this.convertor(s,e);return s=new ci(i.lng.toFixed(6),i.lat.toFixed(6))},convertLL2MC:function(s){if(s==null)return new ci(0,0);if(s.lng>180||s.lng<-180||s.lat>90||s.lat<-90)return s;let t,e;if(s.lng=this.getLoop(s.lng,-180,180),s.lat=this.getRange(s.lat,-74,74),t=new ci(s.lng,s.lat),window.BMAPGL_84){var i={},n=6378137;i.lng=t.lng*Math.PI/180*n;var r=t.lat*Math.PI/180;return i.lat=31890685e-1*Math.log((1+Math.sin(r))/(1-Math.sin(r))),new ci(Number(i.lng),Number(i.lat))}for(var a=0;a<this.LLBAND.length;a++)if(t.lat>=this.LLBAND[a]){e=this.LL2MC[a];break}if(!e){for(a=0;a<this.LLBAND.length;a++)if(t.lat<=-this.LLBAND[a]){e=this.LL2MC[a];break}}let o=this.convertor(s,e);return s=new ci(Number(o.lng),Number(o.lat))},convertor:function(s,t){if(!s||!t)return;let e=t[0]+t[1]*Math.abs(s.lng),i=Math.abs(s.lat)/t[9],n=t[2]+t[3]*i+t[4]*i*i+t[5]*i*i*i+t[6]*i*i*i*i+t[7]*i*i*i*i*i+t[8]*i*i*i*i*i*i;return e*=s.lng<0?-1:1,n*=s.lat<0?-1:1,new ci(e,n)},getDistance:function(s,t,e,i){return this.EARTHRADIUS*Math.acos(Math.sin(e)*Math.sin(i)+Math.cos(e)*Math.cos(i)*Math.cos(t-s))},toRadians:function(s){return Math.PI*s/180},toDegrees:function(s){return 180*s/Math.PI},getRange:function(s,t,e){return t!=null&&(s=Math.max(s,t)),e!=null&&(s=Math.min(s,e)),s},getLoop:function(s,t,e){for(;s>e;)s-=e-t;for(;s<t;)s+=e-t;return s}}),kc(Xe.prototype,{lngLatToMercator:function(s){return Xe.convertLL2MC(s)},lngLatToPoint:function(s){let t=Xe.convertLL2MC(s);return new Xr(t.lng,t.lat)},mercatorToLngLat:function(s){return Xe.convertMC2LL(s)},pointToLngLat:function(s){let t=new ci(s.x,s.y);return Xe.convertMC2LL(t)},pointToPixel:function(s,t,e,i,n){if(!s)return;s=this.lngLatToMercator(s,n);let r=this.getZoomUnits(t);return new Xr(Math.round((s.lng-e.lng)/r+i.width/2),Math.round((e.lat-s.lat)/r+i.height/2))},pixelToPoint:function(s,t,e,i,n){if(!s)return;let r=this.getZoomUnits(t),a=new ci(e.lng+r*(s.x-i.width/2),e.lat-r*(s.y-i.height/2));return this.mercatorToLngLat(a,n)},getZoomUnits:function(s){return Math.pow(2,18-s)}});const Zm=(s,t)=>{if(s)if(t===0)s[2]||(s[2]=0);else for(const e of s)Zm(e,t-1)};function xl(s,t){if(!s)return[];let e=null;return t&&Nc(s,t),e=s.features?s.features:Array.isArray(s)?s:[s],e}function Nc(s,t){if(s){if(s.type==="FeatureCollection"||s.features){const e=s.features;for(const i of e)Nc(i,t)}else if(Array.isArray(s)){const e=s;for(const i of e)Nc(i,t)}else if(s.type==="Feature"||s.geometry){if(!s.geometry)return;if(Array.isArray(s.geometry.coordinates)){if(s.geometry[t])return;Km(s);const e=yl(s.geometry.coordinates,t);s.geometry[t]=e}}}}function yl(s,t){if(Array.isArray(s[0])){const e=[];for(let i of s)e.push(yl(i,t));return e}if(typeof s[0]=="number"||typeof s[0]=="string")return Jm(s,t)}function Jm(s,t){if(!s)return[];let e=[];if(s[0]>180||s[0]<-180||s[1]>90||s[1]<-90)e=[s[0],s[1]];else if(t==="_bmap_mercator"){const i=Xe.convertLL2MC({lng:s[0],lat:s[1]});e[0]=i.lng,e[1]=i.lat}else e=Wr(s);return s[2]!==void 0?e[2]=s[2]:e[2]=0,e}function Km(s){s.type||(s.type="Feature");const t=s.geometry.type,e={Point:0,MultiPoint:1,LineString:1,MultiLineString:2,Polygon:2,MultiPolygon:3};return Object.keys(e).includes(t)&&Zm(s.geometry.coordinates,e[t]),s}function Qm(s,t){if(!s.geometry)return[];if(s.geometry.type==="Point")return[s];if(s.geometry.type==="MultiPoint"||s.geometry.type==="LineString"){const e=[],{type:i,geometry:n,...r}=s;for(let a=0;a<s.geometry.coordinates.length;a++){const o=s.geometry.coordinates[a];if(t){const l=s.geometry[t][a];e.push({type:"Feature",geometry:{type:"Point",coordinates:o,[t]:l},...r})}else e.push({type:"Feature",geometry:{type:"Point",coordinates:o},...r})}return e}return[]}function $m(s,t){if(!s.geometry)return[];if(s.geometry.type==="LineString")return[s];if(s.geometry.type==="MultiLineString"||s.geometry.type==="Polygon"){const e=[],{type:i,geometry:n,...r}=s;for(let a=0;a<s.geometry.coordinates.length;a++){const o=s.geometry.coordinates[a];if(t){const l=s.geometry[t][a];e.push({type:"Feature",geometry:{type:"LineString",coordinates:o,[t]:l},...r})}else e.push({type:"Feature",geometry:{type:"LineString",coordinates:o},...r})}return e}return[]}function tf(s,t){if(!s.geometry)return[];if(s.geometry.type==="Polygon")return[s];if(s.geometry.type==="MultiPolygon"){const e=[],{type:i,geometry:n,...r}=s;for(let a=0;a<s.geometry.coordinates.length;a++){const o=s.geometry.coordinates[a];if(t){const l=s.geometry[t][a];e.push({type:"Feature",geometry:{type:"Polygon",coordinates:o,[t]:l},...r})}else e.push({type:"Feature",geometry:{type:"Polygon",coordinates:o},...r})}return e}return[]}const r1=Object.freeze(Object.defineProperty({__proto__:null,getGeoFeatures:xl,projectCoordinates:yl,projectPointArr:Jm,unprojectPointArr:function(s,t){if(!s)return[];let e=[];if(s[0]<180&&s[0]>-180&&s[1]<90&&s[1]>-90)e=[s[0],s[1]];else if(t==="_bmap_mercator"){const i=Xe.convertMC2LL({lng:s[0],lat:s[1]});e[0]=i.lng,e[1]=i.lat}else e=zc(s);return s[2]!==void 0?e[2]=s[2]:e[2]=0,e},fixFeature:Km,multiPointToPoints:Qm,multiLineStringToLineStrings:$m,multiPolygonToPolygons:tf,convertLineString2Points:function(s){let t=this.getGeoFeatures(s),e=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.multiLineStringToLineStrings(n);for(let a=0;a<r.length;a++){const o=r[a],l=this.multiPointToPoints(o);e.push(...l)}}return e},convertPolygon2LineString:function(s){let t=this.getGeoFeatures(s),e=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.multiPolygonToPolygons(n);for(let a=0;a<r.length;a++){const o=r[a],l=this.multiLineStringToLineStrings(o);e.push(...l)}}return e}},Symbol.toStringTag,{value:"Module"}));function Ni(s,t={}){this.position=s,this.attributes=t,t.id!==void 0&&(this.id=t.id),this._projection=[]}function Uc(s,t,e,i,n){return function(r,a){const o=1-r;return o*o*o*a}(s,t)+function(r,a){const o=1-r;return 3*o*o*r*a}(s,e)+function(r,a){return 3*(1-r)*r*r*a}(s,i)+function(r,a){return r*r*r*a}(s,n)}Ni.prototype.getProjection=function(s){return this._projection=yl(this.position,s),this._projection};const a1=function(s,t){let e=s[0],i=s[1];return[(3*e+t[0])/4,(3*i+t[1])/4]},o1=function(s,t){let e=s[0],i=s[1],n=t[0],r=t[1];return Math.sqrt(Math.pow(e-n,2)+Math.pow(i-r,2))},ef=function(s,t,e=1){return[...a1(s,t),o1(s,t)/e]},l1=function(s,t,e,i,n){let r=[];return r.push(Uc(s,t[0],e[0],i[0],n[0]),Uc(s,t[1],e[1],i[1],n[1]),Uc(s,t[2],e[2],i[2],n[2])),r};function h1(s,t=20){const e=s[0],i=s[s.length-1],n=ef(e,i,2),r=ef(i,e,2);let a=[];for(let o=0;o<=t;o++)a.push(l1(o/t,e,n,r,i));return a}class rs{constructor(t={}){d(this,"_projectionName"),d(this,"_objects",[]),d(this,"_isLoading",!1),d(this,"_isLoaded",!1),d(this,"_url"),d(this,"_origin"),d(this,"_data",{}),d(this,"_userData",[]),d(this,"_addCache",[]),d(this,"_attributeMap",new Map),d(this,"_needsUpdate",!0),d(this,"_templateDataLength",0),d(this,"_idIndexMap",{}),d(this,"_indexIdMap",{}),d(this,"_isCurve",!1),this.options=t,this._id=t.id||new Date().valueOf()}async load(t){if(this._isLoaded&&this.clear(),this._isLoading)return this;if(this._isLoading=!0,typeof t=="string"){let e=await fetch(t),i=await this._getFetchData(e);this._url=t,this._origin=i}else typeof t=="object"&&(this._origin=t);return this._isLoading=!1,this._isLoaded=!0,this}async _getFetchData(t){return t}setAttribute(t,e){return e?this._attributeMap.set(t,e):this._attributeMap.set(t,t),this.needsUpdate=!0,this}setAttributes(t){let e=Object.keys(t);for(let i=0;i<e.length;i++){const n=e[i];this._attributeMap.set(n,t[n])}return this.needsUpdate=!0,this}removeAttribute(t){return this._attributeMap.delete(t),this.needsUpdate=!0,this}removeAllAttributes(){return this._attributeMap.clear(),this.needsUpdate=!0,this}add(t){if(t instanceof Ni){const e=t.id;if(e!==void 0){if(this._idIndexMap[e]!==void 0)return this;const i=this._addCache.length;this._indexIdMap[i]=e,this._idIndexMap[e]=i}this._addCache.push(t)}else if(t instanceof Array)for(let e=0;e<t.length;e++){const i=t[e];this.add(i)}return this.needsUpdate=!0,this}remove(t){let e;if(t instanceof Ni||Array.prototype.toString.call(t)==="[object Object]"?e=t.id:typeof t=="string"&&(e=t),e!==void 0){const i=this._idIndexMap[e];if(i===void 0)return void console.warn("remove fail1",i,e);const n=this._addCache.length-1;if(i>n)return void console.warn("remove fail2",i,e);if(i<n){const r=this._indexIdMap[n];this._addCache[i]=this._addCache[n],this._indexIdMap[i]=r,this._idIndexMap[r]=i}delete this._idIndexMap[e],delete this._indexIdMap[n],this._addCache.length=this._addCache.length-1}return this.needsUpdate=!0,this}get(t){let e={};if(this.data.position&&this.data.position.length&&t!==void 0&&!(t>=this.data.position.length)){for(const i in this.data)if(Object.hasOwnProperty.call(this.data,i)){const n=this.data[i];e[i]=n[t]}return e}}getOriginDataIndex(t){return[t,0]}getOriginData(t){return this._addCache[t]}exportToGeoJSON(){let t=[];this.originToFeatures(t);for(let e=0;e<this._addCache.length;e++){const i=this._addCache[e];t.push({type:"Feature",geometry:{type:this._getDataTypeByCoordinates(i.position),coordinates:i.position},properties:i.attributes})}return{type:"FeatureCollection",features:t}}originToFeatures(t){return t}update(){let t={position:[],index:[]},e=[];for(const i of this._attributeMap.keys())t[i]=[];if(this._onProcessTemplateData(t,e),this._onProcessAddData(t,e),this._isCurve&&t.position.length>0&&Array.isArray(t.position[0])&&Array.isArray(t.position[0][0])&&!Array.isArray(t.position[0][0][0]))for(let i=0;i<t.position.length;i++){const n=t.position[i];t.position[i]=h1(n)}this.data=t,this.userData=e,this.needsUpdate=!1}setData(t){this.clear(),this._isLoaded=!0,this._origin=t,this.needsUpdate=!0}clear(){this._isLoaded=!1,this._url=void 0,this._origin=void 0,this._data={},this._userData=[],this._addCache=[],this.needsUpdate=!0,this._idIndexMap={},this._indexIdMap={},this.onClear()}onClear(){}_onProcessTemplateData(t,e){return t}_onProcessAddData(t,e){const i=this.projectionName,n=t.index[t.index.length-1];this._templateDataLength=t.index.length;for(let r=0;r<this._addCache.length;r++){const a=this._addCache[r],o=a.getProjection(i);t.position.push(o),n!==void 0?t.index.push(n+r+1):t.index.push(r);let l={position:o,index:n!==void 0?n+r+1:r};for(const h of this._attributeMap.keys()){let c;a.attributes&&a.attributes[this._attributeMap.get(h)]!==void 0&&a.attributes[this._attributeMap.get(h)]!==null?(t[h].push(),c=a.attributes[this._attributeMap.get(h)]):this._attributeMap.get(h)instanceof Function&&(t[h].push(),c=this._attributeMap.get(h)(a.attributes)),t[h].push(c),l[h]=c}e.push(l)}}_getDataType(t){let e;return/Point/.test(t)?e="Point":/LineString/.test(t)?e="LineString":/Polygon/.test(t)&&(e="Polygon"),e}_getDataTypeByCoordinates(t){let e;return typeof t[0]=="number"||typeof t[0]=="string"?e="Point":t[0]instanceof Array&&(typeof t[0][0]=="number"||typeof t[0][0]=="string")?e="LineString":t[0]instanceof Array&&t[0][0]instanceof Array&&(typeof t[0][0][0]=="number"||typeof t[0][0][0]=="string")&&(e="Polygon"),e}_onDecomposeFeature(t,e){let i=n=>[n];return t==="Point"?i=Qm:t==="LineString"?i=$m:t==="Polygon"&&(i=tf),i(e,this.projectionName)}dispose(){this.clear()}get size(){return this.needsUpdate&&this.update(),this.data&&this.data.position&&this.data.position.length||0}get data(){return this._data}set data(t){this._data=t}get userData(){return this._userData}set userData(t){this._userData=t}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}get origin(){return this._origin}get projectionName(){return this._projectionName}set projectionName(t){this._projectionName=t}get objects(){return this._objects}set objects(t){this._objects=t}get isCurve(){return this._isCurve}set isCurve(t){this._isCurve=t,this.needsUpdate=!0}}class ee extends rs{constructor(t){super(t),this.type="BufferDataSource"}getOriginData(t){return t<this._templateDataLength&&this.data.payload?this.data.payload[t]:this._addCache[t-this._templateDataLength]}originToFeatures(t){if(!this.data.payload)return t;for(let e=0;e<this.data.payload.length;e++){const i=this.data.payload[e],{position:n,index:r,...a}=i;t.push({type:"Feature",geometry:{type:this._getDataTypeByCoordinates(n),coordinates:n},properties:a})}return t}_onProcessTemplateData(t,e){let i=this._origin;if(i&&i.position){t.position=i.position,t.index=i.index;for(let n=0;n<i.payload.length;n++){const r=i.payload[n],a={...r};for(const o of this._attributeMap.keys())t[o]||(t[o]=[]),t[o]=t[o].concat(r[this._attributeMap.get(o)]),a[o]=r[this._attributeMap.get(o)];e.push(a)}}return t}}class Sn extends s1{constructor(){super(...arguments),d(this,"isGeoObject",!0),d(this,"dataAutoUpdate",!0),d(this,"_parameters"),d(this,"_dataSource"),d(this,"_dataSourceUpdated"),d(this,"_needsUpdate"),d(this,"_zooms",[0,100]),d(this,"_zoomVisibleCache"),d(this,"engine"),d(this,"_clampToGround"),d(this,"_renderMaterialOptions"),d(this,"_backMaterialOptions"),d(this,"_frontMaterialOptions"),d(this,"_terrain"),d(this,"_backObject"),d(this,"_frontObject"),d(this,"_renderObject"),d(this,"_VolumeClass"),d(this,"_volumeDataSource",new ee),d(this,"getGeoFeatures",(t,e=!1)=>{if(!t)return[];let i=null;return e||this.map.projectGeoJSON(t),i=t.features?t.features:Array.isArray(t)?t:[t],i}),d(this,"travelFeatureLineCoordinate",(t,e,i)=>{const n=t.geometry;if(!n||!n[e]||!n.type)return;const r=n[e];if(n.type==="LineString")i&&i(r);else if(n.type==="MultiLineString"||n.type==="Polygon")for(let a of r)i&&i(a);else if(n.type==="MultiPolygon")for(let a of r)for(let o of a)i&&i(o)}),d(this,"travelLineCoordinates",(t,e="coordinates",i,n=0)=>{if(Array.isArray(t)&&i)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=n+r,h=o.geometry;if(!h||!h[e]||!h.type)continue;const c=h[e];if(h.type==="LineString")i&&i(c,o,l);else if(h.type==="MultiLineString"||h.type==="Polygon")for(let u of c)i&&i(u,o,l);else if(h.type==="MultiPolygon")for(let u of c)for(let p of u)i&&i(p,o,l)}}),d(this,"travelPolygonCoordinates",(t,e="coordinates",i,n=0)=>{if(Array.isArray(t)&&i)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=n+r,h=o.geometry;if(!h||!h[e]||!h.type)continue;const c=h[e];if(h.type==="Polygon")i&&i(c,o,l);else if(h.type==="MultiPolygon")for(let u of c)i&&i(u,o,l);else if(h.type==="LineString")i&&i([c],o,l);else if(h.type==="MultiLineString")for(let u of c)i&&i([u],o,l)}}),d(this,"travelPointCoordinates",(t,e="coordinates",i,n=0)=>{if(Array.isArray(t)&&i)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=n+r,h=o.geometry;if(!h||!h[e]||!h.type)continue;const c=h[e];h.type==="Point"&&i&&i(c,o,l)}}),d(this,"getPointsBounding",(t,e="coordinates")=>{let i=1/0,n=1/0,r=1/0,a=-1/0,o=-1/0,l=-1/0;return this.travelPointCoordinates(t,e,h=>{const[c,u,p=0]=h;c<i&&(i=c),c>a&&(a=c),u<n&&(n=u),u>o&&(o=u),p<r&&(r=p),p>l&&(l=p)}),isFinite(i)||(i=0),isFinite(a)||(a=0),isFinite(n)||(n=0),isFinite(o)||(o=0),isFinite(r)||(r=0),isFinite(l)||(l=0),[i,n,r,a,o,l]})}get parameters(){return this._parameters}set parameters(t){this._parameters?this._parameters={...this._parameters,...t}:this._parameters={...this.getDefaultParams(),...t}}get dataSource(){return this._dataSource}set dataSource(t){this.setDataSource(t)}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}get zooms(){return this._zooms}set zooms(t){this._zooms=t}get inZoomsRange(){const t=this.engine;return!!t&&t.map.getZoom()>=this.zooms[0]&&t.map.getZoom()<=this.zooms[1]}afterAddToEngine(t){this.engine=t,this.initObject(),this.isInstancedMesh&&(this.material.defines.IS_INSTANCE=!0)}beforeRemoveFromEngine(t){this.dispose()}initObject(){}getDefaultParams(){return{}}getEntityByIndex(t){const e=this.dataSource;if(!e)return;const i={index:t,value:e.getOriginData(t),itemIndex:e.getOriginDataIndex(t),pairs:{}},n=e.data;for(const r of Object.keys(n))i.pairs[r]=n[r][t];return i}setDataSource(t){if(!t&&this._dataSource){const e=this._dataSource.objects.indexOf(this);e>-1&&this._dataSource.splice(e,1),this._dataSource=null}t.objects.indexOf(this)>-1||(this._dataSource=t,t.projectionName=this.engine.map.projectionCoordsName,t.objects.push(this),this.needsUpdate=!0,this.engine.requestRender())}onBeforeScenePrepareRender(t,e,i,n){if(this.dataSource&&(this.dataSource.needsUpdate&&(this.dataSource.update(),this._dataSourceUpdated=!0),this.dataAutoUpdate&&(this._dataSourceUpdated||this.needsUpdate)&&this._enableCollision&&(t.rendering.collision.needsUpdate=!0),this.onBeforeScenePrepareRenderHook&&this.onBeforeScenePrepareRenderHook(t,e,i,n),this.clampToGround)){const r=this.getShadowVolumeOptions();this._volumeDataSource=this.createVolumeDataSource();const a=this._VolumeClass;this._backObject&&this.engine.remove(this._backObject),this._backObject=t.add(new a({...this._backMaterialOptions,...r})),this._frontObject&&this.engine.remove(this._frontObject),this._frontObject=t.add(new a({...this._frontMaterialOptions,...r})),this._renderObject&&this.engine.remove(this._renderObject),this._renderObject=t.add(new a({...this._renderMaterialOptions,...r,...this.filterVolumeParamter(this.parameters)})),this._frontObject.dataSource=this._volumeDataSource,this._backObject.dataSource=this._volumeDataSource,this._renderObject.dataSource=this._volumeDataSource}}onBeforeSceneRender(t,e,i,n){this.dataSource&&(this.dataAutoUpdate&&this._dataSourceUpdated||this.dataAutoUpdate&&this.needsUpdate?this.setData():this.geometry&&this.geometry.needsUpdate&&this.geometry.updateGeometry&&(this.geometry.updateGeometry(),this.afterGeometryUpdate&&this.afterGeometryUpdate()),delete this._dataSourceUpdated,this.visible&&!this.inZoomsRange?(this._zoomVisibleCache=this.visible,this.visible=!1):!this.visible&&this._zoomVisibleCache&&this.inZoomsRange&&(this.visible=this._zoomVisibleCache,this._zoomVisibleCache=void 0),this.onBeforeSceneRenderHook&&this.onBeforeSceneRenderHook(t,e,i,n))}setData(){}collisionTest(t){return{}}createVolumeDataSource(){return this.dataSource}specifiedVolumeClass(){this._VolumeClass=this.constructor}filterVolumeParamter(t){const e=["opacity","color","vertexColors","emissive","mapSrc","mapScale"];let i={};return Object.keys(t).filter(n=>e.includes(n)).forEach(n=>{i[n]=t[n]}),i}onDispose(){}dispose(){if(this.geometry&&this.geometry.dispose(),this.material)if(Array.isArray(this.material))for(let t=0;t<this.material.length;t++)this.material[t].dispose();else this.material.dispose();this.onDispose()}bindTerrain(t){this._terrain=t}initMaterialOptions(){this._frontMaterialOptions={side:Fn,depthWrite:!1,colorWrite:!1,stencilWrite:!0,stencilFunc:519,stencilZFail:34056,stencilZPass:ba},this._backMaterialOptions={side:pi,depthWrite:!1,colorWrite:!1,stencilWrite:!0,stencilFunc:519,stencilZFail:34055,stencilZPass:ba},this._renderMaterialOptions={side:ce,stencilWrite:!0,stencilRef:0,depthTest:!1,stencilFunc:517,stencilZFail:0,stencilFail:0,stencilZPass:0}}getShadowVolumeOptions(){this.geometry.computeBoundingBox();const{min:t,max:e}=this.geometry.boundingBox,i=this.position;let n=new j(t.x,t.y).add(i),r=new j(e.x,e.y).add(i);const a=new Mm(n,r);let[o,l]=this._terrain._intersectHeightRange(a);return{opacity:.4,extrude:!0,extrudeValue:l-o,zOffset:o,enableBottomFace:!0}}get clampToGround(){return this._clampToGround}set clampToGround(t){this.clampToGround!==t&&(this._clampToGround=t,t?(this.initMaterialOptions(),this.specifiedVolumeClass(),this.material.visible=!1):(this._frontObject&&this.engine.remove(this._frontObject),this._backObject&&this.engine.remove(this._backObject),this._renderObject&&this.engine.remove(this._renderObject),this.material.visible=!0))}}class as extends Sn{constructor(){super(...arguments),d(this,"isMesh",!0)}}function nf(s){let t=0,e=0;for(const a of s)t+=a.w*a.h,e=Math.max(e,a.w);s.sort((a,o)=>o.h-a.h);const i=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(t/.95)),e),h:1/0}];let n=0,r=0;for(const a of s)for(let o=i.length-1;o>=0;o--){const l=i[o];if(!(a.w>l.w||a.h>l.h)){if(a.x=l.x,a.y=l.y,r=Math.max(r,a.y+a.h),n=Math.max(n,a.x+a.w),a.w===l.w&&a.h===l.h){const h=i.pop();o<i.length&&(i[o]=h)}else a.h===l.h?(l.x+=a.w,l.w-=a.w):a.w===l.w?(l.y+=a.h,l.h-=a.h):(i.push({x:l.x+a.w,y:l.y,w:l.w-a.w,h:a.h}),l.y+=a.h,l.h-=a.h);break}}return{w:n,h:r,fill:t/(n*r)||0}}class Be extends Zt{constructor(t){super(),d(this,"isCommonShaderMaterial",!0),d(this,"setCommonUniforms",e=>{for(const i of Object.keys(e))this.uniforms[i]=e[i]}),this.setValues(t)}}const c1=pt.merge([ot.fog,ki,is,{map:{value:null},pixelRatio:{value:1},lineHeight:{value:14},pixelOffsetX:{value:0},pixelOffsetY:{value:0},positionOffsetX:{value:0},positionOffsetZ:{value:0},positionOffsetY:{value:0},backgroundColor:{value:[1,1,0,0]},uFlat:{value:!1},opacity:{value:1},isEmissive:{value:!1}}]);class u1 extends Be{constructor(t){super(),this.type="DefaultTextMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float pixelRatio;
uniform float positionOffsetX;
uniform float positionOffsetY;
uniform float pixelOffsetX;
uniform float pixelOffsetY;
uniform float positionOffsetZ;
uniform bool uFlat;
uniform vec2 resolution;

attribute float pIndex;
attribute vec2 wh;
attribute float rotateZ;

varying vec2 vUv;
#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {
    #include <mvt_selective_vertex>
    // float x = position.x;
    // float y = position.y;
    vUv = uv;

    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));
    if (uFlat) {
        // TODO 支持offset
        float pixelSize = getPixelSize(worldPosition.xyz);
        float hw = wh.x * 0.5 * pixelSize;
        float hh = wh.y * 0.5 * pixelSize;
        if (pIndex == 1.0) {
            hw = -hw;
        } else if (pIndex == 2.0) {
            
        } else if (pIndex == 3.0) {
            hh = -hh;
        } else {
            hw = -hw;
            hh = -hh;
        }
        vec2 rotatedPosition;
	    rotatedPosition.x = cos( rotateZ ) * hw - sin( rotateZ ) * hh;
	    rotatedPosition.y = sin( rotateZ ) * hw + cos( rotateZ ) * hh;
        // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + rotatedPosition.x, position.y + rotatedPosition.y, position.z, 1.0);

    }
    else {
        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);
        worldPosition.x += positionOffsetX;
        worldPosition.y += positionOffsetY;
        worldPosition.z += positionOffsetZ;
        gl_Position = projectionMatrix * viewMatrix * worldPosition;
       
        float w = gl_Position.w;
        gl_Position /= w;
        float hw = wh.x / resolution.x;
        float hh = wh.y / resolution.y;
        gl_Position.x += pixelOffsetX * 2. / resolution.x;
        gl_Position.y += pixelOffsetY * 2. / resolution.y;
        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }
        gl_Position *= w;
    }
    #include <logdepthbuf_vertex>
    // gl_PointSize = size * pixelRatio;
    // vSize = size;
    // vOffset = offset;
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D map;
uniform vec4 backgroundColor;
uniform float opacity;
uniform float lineHeight;

varying vec2 vUv;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    // gl_FragColor = vec4(1., 0, 0, 1.);
    gl_FragColor = texture2D(map, vec2(vUv.x, 1.0 - vUv.y));

    if (backgroundColor.a > 0.0) {
        gl_FragColor = mix(backgroundColor, gl_FragColor, gl_FragColor.a);
    }

    if (gl_FragColor.a == 0.0) {
        discard;
    }
    gl_FragColor.a *= opacity;

    #include <mvt_selective_fragment> 
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}`,this.isDefaultTextMaterial=!0,this.transparent=!0,this.depthTest=!1,this.depthWrite=!1,Object.assign(this.uniforms,pt.clone(c1)),ns(this),jt(this,["lineHeight","pixelRatio","map","pixelOffsetX","pixelOffsetY","positionOffsetX","positionOffsetY","positionOffsetZ","backgroundColor","resolution","opacity","isEmissive"]),_i(this,[["flat","uFlat"]]),ss(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}}new rt;class bl extends as{constructor(t){super(t),d(this,"_fontSize"),d(this,"_fontFamily"),d(this,"_fillStyle"),d(this,"_padding"),d(this,"_margin"),d(this,"_strokeStyle"),d(this,"_shouldStroke"),d(this,"geometry"),d(this,"material"),d(this,"cachedData",[]),d(this,"drawingData"),d(this,"canvas"),d(this,"ctx"),d(this,"texture"),d(this,"matrixAutoUpdate",!0),d(this,"updateRenderingData",()=>{const n=this.engine.rendering.pixelRatio,r=this.canvas,a=this.ctx,o=this._fontSize,l=this._fontFamily,h=this._fillStyle,c=this._padding,u=this.cachedData||[],p=nf(u);let m=p.w,f=p.h;r.width=m*n,r.height=f*n,a.save(),a.scale(n,n),a.textBaseline="top",a.fillStyle=h,this._shouldStroke&&(a.strokeStyle=this._strokeStyle),a.font=o+"px "+l,this.shadowColor&&(a.shadowColor=this.shadowColor,a.shadowOffsetX=this.shadowOffsetX||0,a.shadowOffsetY=this.shadowOffsetY||0,a.shadowBlur=this.shadowBlur||0);const g=[],_=[],v=[],x=[],y=[],b=[],S=[];for(let C=0,L=u.length;C<L;++C){const T=u[C];let E=o;if(this.parameters.vertexStyles){let{fontWeight:H,fontSize:Z,fillStyle:mt,strokeStyle:_t,lineWidth:Mt}=T;a.font=H>=10&&H%10==0?10*H+" "+Z+"px "+l:Z+"px "+l,E=Z,Mt>0&&(a.lineWidth=Mt,a.strokeStyle="rgba("+_t.join(",")+")"),a.fillStyle="rgba("+mt.join(",")+")"}let I=T.text.split("\\");for(let H=0;H<I.length;H++)(this._shouldStroke||this.parameters.vertexStyles)&&a.strokeText(I[H],T.x+c[0],T.y+c[1]+H*E),a.fillText(I[H],T.x+c[0],T.y+c[1]+H*E);const[z,B,O=0]=T.position;g.push(z,B,O,z,B,O,z,B,O,z,B,O),v.push(0,1,2,3),y.push(T.w,T.h,T.w,T.h,T.w,T.h,T.w,T.h);const F=4*C;x.push(F,F+2,F+1,F,F+3,F+2);const Q=T.x/m,k=(T.x+T.w)/m,X=(T.y+T.h)/f,U=T.y/f;_.push(Q,X,Q,U,k,U,k,X),b.push(T.index,T.index,T.index,T.index),S.push(T.rotateZ,T.rotateZ,T.rotateZ,T.rotateZ)}a.restore();const w=this.geometry;w.setAttribute("position",new et(g,3)),w.setAttribute("pIndex",new et(v,1)),w.setAttribute("wh",new et(y,2)),w.setAttribute("uv",new et(_,2)),w.setAttribute("rotateZ",new et(S,1)),w.setIndex(x),w.computeBoundingSphere(),this.makeGeometryOffsetPosition(w,g),g.length>0&&(this.texture&&this.texture.dispose(),this.texture=new Le(this.canvas),this.material.uniforms.map.value=this.texture),this.needsUpdate=!1}),this.parameters=t,this._collides=this.parameters.collides===void 0||this.parameters.collides,this._fontSize=this.parameters.fontSize!==void 0?this.parameters.fontSize:16,this._fontFamily=this.parameters.fontFamily!==void 0?this.parameters.fontFamily:"Microsoft Yahei",this._fillStyle=this.parameters.fillStyle!==void 0?this.parameters.fillStyle:"#f00",this._padding=this.parameters.padding!==void 0?this.parameters.padding:[2,2],this._margin=this.parameters.margin,this.strokeStyle=this.parameters.strokeStyle,this.cachedData=[],this.drawingData=[];const e=this.canvas=document.createElement("canvas");e.width=e.height=1;const i=this.ctx=e.getContext("2d");i.textAlign="start",i.textBaseline="top",this.defineMaterialProxyProperties(["lineHeight","map","pixelOffsetX","pixelOffsetY","positionOffsetX","positionOffsetY","positionOffsetZ","backgroundColor","resolution","opacity","flat","emissive"])}initObject(){let{margin:t,padding:e,collides:i,fillStyle:n,strokeStyle:r,fontSize:a,fontFamily:o,vertexStyles:l,...h}=this.parameters;this.geometry=new Pt(this.parameters),this.material=new u1(h),this.material.setCommonUniforms(this.engine.rendering.uniforms),this.texture=new Le(this.canvas),this.material.uniforms.map.value=this.texture}setData(){this._enableCollision&&this._collisionData?this.cachedData=this._collisionData:this.cachedData=this.dataSource.userData.map(t=>{let e=this.collisionTest(t);return{...t,w:e.width,h:e.height}}),this.update()}update(){this.updateRenderingData()}collisionTest(t){const e=this.ctx,i=this.engine.rendering.pixelRatio,n=this._fontSize,r=this._fontFamily,a=this._padding;e.save(),e.scale(i,i),e.textBaseline="top";let o=n;if(this.parameters.vertexStyles){let{fontWeight:f,fontSize:g,lineWidth:_}=t;e.font=f>=10&&f%10==0?10*f+" "+g+"px "+r:g+"px "+r,o=g,_>0&&(e.lineWidth=_)}else e.font=n+"px "+r;let l=t.text.split("\\");const h=l.map(f=>e.measureText(f).width);let c=Math.max(...h),u=o*l.length;const p=c+2*a[0],m=u+2*a[1];return e.restore(),{width:p,height:m}}onDispose(){this.texture&&this.texture.dispose()}set fontSize(t){this._fontSize=t}get fontSize(){return this._fontSize}set fontFamily(t){this._fontFamily=t}get fontFamily(){return this._fontFamily}set fillStyle(t){this._fillStyle=t}get fillStyle(){return this._fillStyle}set strokeStyle(t){this._shouldStroke=!!t,this._strokeStyle=t}set padding(t){this._padding=t}get padding(){return this._padding}set margin(t){typeof t=="number"?this._margin=[t,t]:t instanceof Array&&(this._margin=t)}get margin(){return this._margin}}class d1{constructor(t){this._rendering=t}init(){const t=this._flatDataSource=new rs,e=this._flatText=this._rendering.add(new bl({fillStyle:"#fff",strokeStyle:"#000",flat:!0}));e.renderOrder=100,e.maxRenderDepth=.999999,e.dataSource=t,t.setAttribute("text","text").setAttribute("rotateZ","rotateZ");const i=this._fixDataSource=new rs,n=this._fixText=this._rendering.add(new bl({fillStyle:"#000",strokeStyle:"#fff",fontFamily:"sans-serif",vertexStyles:!0}));n.renderOrder=100,n.maxRenderDepth=.999999,n.dataSource=i,i.setAttributes({text:"text",fontSize:"fontSize",fontWeight:"fontWeight",fillStyle:"fontRgba",strokeStyle:"haloRgba",lineWidth:"haloSize"});const r=this._labelDataSource=new rs,a=this._flatText=this._rendering.add(new bl({fillStyle:"#000",strokeStyle:"#fff",fontFamily:"sans-serif",flat:!0,vertexStyles:!0}));a.renderOrder=100,a.maxRenderDepth=.999999,a.dataSource=r,r.setAttributes({text:"text",fontSize:"fontSize",fontWeight:"fontWeight",fillStyle:"fontRgba",strokeStyle:"haloRgba",lineWidth:"haloSize",rotateZ:"rotateZ"}),this._rendering.collision.add(n,{margin:[50,50]},"poi"),this._rendering.collision.add(a,{margin:[50,50]},"poi"),this._rendering.collision.add(e,{margin:[80,80]},"poi")}addLabel(t){let e=t;if(!(t instanceof Ni)&&Array.prototype.toString.call(t)==="[object Object]"){const{position:i,...n}=t;e=new Ni(i,n)}t.type==="flat"?this._flatDataSource.add(e):t.type==="labelp"?this._labelDataSource.add(e):this._fixDataSource.add(e)}addLabels(t){for(const e of t)this.addLabel(e);this._rendering.requestRender()}removeLabel(t){t.type==="flat"?this._flatDataSource.remove(t):t.type==="labelp"?this._labelDataSource.remove(t):this._fixDataSource.remove(t)}removeLabels(t){for(const e of t)this.removeLabel(e);this._rendering.requestRender()}}class p1{constructor(t){d(this,"_needsCreate",!1),d(this,"_rendering"),d(this,"_enabled",!1),d(this,"_brightness",0),d(this,"_saturation",0),d(this,"_contrast",0),d(this,"updateComposition",(e,i,n)=>{this[e]=n;const r=this._rendering;r.useMrt&&(r.composition[i]=n)}),d(this,"createFog",()=>{const e=this._rendering;if(e.useMrt){const i=e.composition;i.useFog=!0,i.fogDensity=this._density}}),d(this,"destory",()=>{const e=this._rendering;e.useMrt&&(e.composition.useFog=!1)}),this._rendering=t}get enabled(){return this._enabled}set enabled(t){t!==this._enabled&&(this._enabled=t,this.updateComposition("_enabled","colorAdjustEnabled",t),t?this._needsCreate=!0:this.destory())}get brightness(){return this._brightness}set brightness(t){this.updateComposition("_brightness","adjustBrightnessFactor",t)}get contrast(){return this._contrast}set contrast(t){this.updateComposition("_contrast","adjustContrastFactor",t)}get saturation(){return this._saturation}set saturation(t){this.updateComposition("_saturation","adjustSaturationFactor",t)}render(){}}function m1(s,t,e,i,n){sf(s,t,e||0,i||s.length-1,n||f1)}function sf(s,t,e,i,n){for(;i>e;){if(i-e>600){var r=i-e+1,a=t-e+1,o=Math.log(r),l=.5*Math.exp(2*o/3),h=.5*Math.sqrt(o*l*(r-l)/r)*(a-r/2<0?-1:1);sf(s,t,Math.max(e,Math.floor(t-a*l/r+h)),Math.min(i,Math.floor(t+(r-a)*l/r+h)),n)}var c=s[t],u=e,p=i;for(Ga(s,e,t),n(s[i],c)>0&&Ga(s,e,i);u<p;){for(Ga(s,u,p),u++,p--;n(s[u],c)<0;)u++;for(;n(s[p],c)>0;)p--}n(s[e],c)===0?Ga(s,e,p):Ga(s,++p,i),p<=t&&(e=p+1),t<=p&&(i=p-1)}}function Ga(s,t,e){var i=s[t];s[t]=s[e],s[e]=i}function f1(s,t){return s<t?-1:s>t?1:0}class g1{constructor(t=9){this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}all(){return this._all(this.data,[])}search(t){let e=this.data;const i=[];if(!wl(t,e))return i;const n=this.toBBox,r=[];for(;e;){for(let a=0;a<e.children.length;a++){const o=e.children[a],l=e.leaf?n(o):o;wl(t,l)&&(e.leaf?i.push(o):Bc(t,l)?this._all(o,i):r.push(o))}e=r.pop()}return i}collides(t){let e=this.data;if(!wl(t,e))return!1;const i=[];for(;e;){for(let n=0;n<e.children.length;n++){const r=e.children[n],a=e.leaf?this.toBBox(r):r;if(wl(t,a)){if(e.leaf||Bc(t,a))return!0;i.push(r)}}e=i.pop()}return!1}load(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(let i=0;i<t.length;i++)this.insert(t[i]);return this}let e=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===e.height)this._splitRoot(this.data,e);else{if(this.data.height<e.height){const i=this.data;this.data=e,e=i}this._insert(e,this.data.height-e.height-1,!0)}else this.data=e;return this}insert(t){return t&&this._insert(t,this.data.height-1),this}clear(){return this.data=Yr([]),this}remove(t,e){if(!t)return this;let i=this.data;const n=this.toBBox(t),r=[],a=[];let o,l,h;for(;i||r.length;){if(i||(i=r.pop(),l=r[r.length-1],o=a.pop(),h=!0),i.leaf){const c=_1(t,i.children,e);if(c!==-1)return i.children.splice(c,1),r.push(i),this._condense(r),this}h||i.leaf||!Bc(i,n)?l?(o++,i=l.children[o],h=!1):i=null:(r.push(i),a.push(o),o=0,l=i,i=i.children[0])}return this}toBBox(t){return t}compareMinX(t,e){return t.minX-e.minX}compareMinY(t,e){return t.minY-e.minY}toJSON(){return this.data}fromJSON(t){return this.data=t,this}_all(t,e){const i=[];for(;t;)t.leaf?e.push(...t.children):i.push(...t.children),t=i.pop();return e}_build(t,e,i,n){const r=i-e+1;let a,o=this._maxEntries;if(r<=o)return a=Yr(t.slice(e,i+1)),qr(a,this.toBBox),a;n||(n=Math.ceil(Math.log(r)/Math.log(o)),o=Math.ceil(r/Math.pow(o,n-1))),a=Yr([]),a.leaf=!1,a.height=n;const l=Math.ceil(r/o),h=l*Math.ceil(Math.sqrt(o));rf(t,e,i,h,this.compareMinX);for(let c=e;c<=i;c+=h){const u=Math.min(c+h-1,i);rf(t,c,u,l,this.compareMinY);for(let p=c;p<=u;p+=l){const m=Math.min(p+l-1,u);a.children.push(this._build(t,p,m,n-1))}}return qr(a,this.toBBox),a}_chooseSubtree(t,e,i,n){for(;n.push(e),!e.leaf&&n.length-1!==i;){let o,l=1/0,h=1/0;for(let c=0;c<e.children.length;c++){const u=e.children[c],p=Fc(u),m=(r=t,a=u,(Math.max(a.maxX,r.maxX)-Math.min(a.minX,r.minX))*(Math.max(a.maxY,r.maxY)-Math.min(a.minY,r.minY))-p);m<h?(h=m,l=p<l?p:l,o=u):m===h&&p<l&&(l=p,o=u)}e=o||e.children[0]}var r,a;return e}_insert(t,e,i){const n=i?t:this.toBBox(t),r=[],a=this._chooseSubtree(n,this.data,e,r);for(a.children.push(t),Xa(a,n);e>=0&&r[e].children.length>this._maxEntries;)this._split(r,e),e--;this._adjustParentBBoxes(n,r,e)}_split(t,e){const i=t[e],n=i.children.length,r=this._minEntries;this._chooseSplitAxis(i,r,n);const a=this._chooseSplitIndex(i,r,n),o=Yr(i.children.splice(a,i.children.length-a));o.height=i.height,o.leaf=i.leaf,qr(i,this.toBBox),qr(o,this.toBBox),e?t[e-1].children.push(o):this._splitRoot(i,o)}_splitRoot(t,e){this.data=Yr([t,e]),this.data.height=t.height+1,this.data.leaf=!1,qr(this.data,this.toBBox)}_chooseSplitIndex(t,e,i){let n,r=1/0,a=1/0;for(let o=e;o<=i-e;o++){const l=Wa(t,0,o,this.toBBox),h=Wa(t,o,i,this.toBBox),c=y1(l,h),u=Fc(l)+Fc(h);c<r?(r=c,n=o,a=u<a?u:a):c===r&&u<a&&(a=u,n=o)}return n||i-e}_chooseSplitAxis(t,e,i){const n=t.leaf?this.compareMinX:v1,r=t.leaf?this.compareMinY:x1;this._allDistMargin(t,e,i,n)<this._allDistMargin(t,e,i,r)&&t.children.sort(n)}_allDistMargin(t,e,i,n){t.children.sort(n);const r=this.toBBox,a=Wa(t,0,e,r),o=Wa(t,i-e,i,r);let l=Ml(a)+Ml(o);for(let h=e;h<i-e;h++){const c=t.children[h];Xa(a,t.leaf?r(c):c),l+=Ml(a)}for(let h=i-e-1;h>=e;h--){const c=t.children[h];Xa(o,t.leaf?r(c):c),l+=Ml(o)}return l}_adjustParentBBoxes(t,e,i){for(let n=i;n>=0;n--)Xa(e[n],t)}_condense(t){for(let e,i=t.length-1;i>=0;i--)t[i].children.length===0?i>0?(e=t[i-1].children,e.splice(e.indexOf(t[i]),1)):this.clear():qr(t[i],this.toBBox)}}function _1(s,t,e){if(!e)return t.indexOf(s);for(let i=0;i<t.length;i++)if(e(s,t[i]))return i;return-1}function qr(s,t){Wa(s,0,s.children.length,t,s)}function Wa(s,t,e,i,n){n||(n=Yr(null)),n.minX=1/0,n.minY=1/0,n.maxX=-1/0,n.maxY=-1/0;for(let r=t;r<e;r++){const a=s.children[r];Xa(n,s.leaf?i(a):a)}return n}function Xa(s,t){return s.minX=Math.min(s.minX,t.minX),s.minY=Math.min(s.minY,t.minY),s.maxX=Math.max(s.maxX,t.maxX),s.maxY=Math.max(s.maxY,t.maxY),s}function v1(s,t){return s.minX-t.minX}function x1(s,t){return s.minY-t.minY}function Fc(s){return(s.maxX-s.minX)*(s.maxY-s.minY)}function Ml(s){return s.maxX-s.minX+(s.maxY-s.minY)}function y1(s,t){const e=Math.max(s.minX,t.minX),i=Math.max(s.minY,t.minY),n=Math.min(s.maxX,t.maxX),r=Math.min(s.maxY,t.maxY);return Math.max(0,n-e)*Math.max(0,r-i)}function Bc(s,t){return s.minX<=t.minX&&s.minY<=t.minY&&t.maxX<=s.maxX&&t.maxY<=s.maxY}function wl(s,t){return t.minX<=s.maxX&&t.minY<=s.maxY&&t.maxX>=s.minX&&t.maxY>=s.minY}function Yr(s){return{children:s,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function rf(s,t,e,i,n){const r=[t,e];for(;r.length;){if((e=r.pop())-(t=r.pop())<=i)continue;const a=t+Math.ceil((e-t)/i/2)*i;m1(s,a,t,e,n),r.push(t,a,a,e)}}const b1=new rt;class M1{constructor(t){d(this,"_groupObjectMap",{}),d(this,"_groupDataMap",{}),d(this,"_objectDataMap",new Map),d(this,"_needsUpdate",!1),d(this,"_restrictCount",1e3),d(this,"_margin",[0,0]),d(this,"_maxRenderDepth",1),this._rendering=t}add(t,e={},i="_default"){t instanceof Sn?t.dataSource?(this._groupObjectMap[i]||(this._groupObjectMap[i]=[],this._groupDataMap[i]=[]),this._groupObjectMap[i].push(t),t._enableCollision=!0,t._collisionOptions=e,t.dataSource.setAttribute("rank","rank")):console.error("Object must have DataSource before it added to Collision!"):console.error("Collison Test only work with GeoObject.")}remove(t,e="_default"){if(!(t instanceof Sn))return void console.error("Collison Test only work with GeoObject.");let i=this._groupObjectMap[e].indexOf(t);i>-1?(this._groupObjectMap[e].splice(i,1),delete t._enableCollision,delete t._collisionOptions,delete t._collisionData,t.dataSource.removeAttribute("rank","rank")):console.error("remove error: cannot find object in this group.")}sortData(){let t=Object.keys(this._groupObjectMap);for(let e=0;e<t.length;e++){const i=t[e],n=this._groupObjectMap[i];for(let r=0;r<n.length;r++){const a=n[r];delete a._collisionData;let o=a.dataSource.userData;for(let l=0;l<o.length;l++)o[l]._objects=a.dataSource.objects}this._groupDataMap[i]=[];for(let r=0;r<n.length;r++){const a=n[r];this._groupDataMap[i]=this._groupDataMap[i].concat(a.dataSource.userData)}this._groupDataMap[i]=this._groupDataMap[i].sort((r,a)=>a.rank-r.rank||a.position[0]-r.position[0]||a.position[1]-r.position[1]).slice(0,this.restrictCount)}this._needsUpdate=!1}collisionTest(){let t=Object.keys(this._groupDataMap);if(!t.length)return;this.needsUpdate&&this.sortData();const e=this._rendering.camera;let i=b1.copy(this._rendering.renderState.viewMatrixWorldInverse),n=e.projectionMatrix;const r=this._rendering.resolution?this._rendering.resolution.toArray():[0,0],[a,o]=r;if(isNaN(a)||a<=0||isNaN(o)||o<=0)return console.warn("resolution is invalid"),!1;const l=this._objectDataMap;l.clear();for(let h=0;h<t.length;h++){const c=t[h],u=this._groupDataMap[c];if(!u)continue;const p=new g1;for(let m=0;m<u.length;m++){const f=u[m],g=f._objects,_=g.filter(k=>k._enableCollision)[0],[v,x,y]=f.position,b=new Lt(v,x,y,1);b.applyMatrix4(i).applyMatrix4(n),b.divideScalar(b.w);const S=(b.x+1)/2*a,w=(1-b.y)/2*o;if(b.z>this._maxRenderDepth)continue;let{width:C,height:L}=_.collisionTest(f);if(!C||!L)continue;let T=C,E=L;if(_._collisionOptions.margin){let k=_._collisionOptions.margin;typeof k=="number"&&(k=[k,k]),C+=k[0],L+=k[1]}else C+=this.margin[0],L+=this.margin[1];const I=S-C/2,z=w-L/2,B=I+C,O=z+L;if(B<0||O<0||I>a||z>o)continue;const F={minX:I,minY:z,maxX:B,maxY:O};if(p.collides(F))continue;p.insert(F);let Q={...f,w:T,h:E};for(let k=0;k<g.length;k++){const X=g[k];l.get(X)||l.set(X,[]),l.get(X).push(Q)}}}Array.from(l.entries()).forEach(([h,c])=>{h._collisionData&&h._collisionData.length===c.length||(h._collisionData=c,h.needsUpdate=!0)})}set margin(t){typeof t=="number"?this._margin=[t,t]:t instanceof Array&&(this._margin=t)}get margin(){return this._margin}set maxRenderDepth(t){this._maxRenderDepth=t}set restrictCount(t){this._restrictCount=t}get restrictCount(){return this._restrictCount}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}class w1{constructor(t){d(this,"_rendering",null),d(this,"_mixer",null),d(this,"_customMixers",[]),this._rendering=t}update(t){this._mixer&&this._mixer.update(t.deltaSeconds);for(const e of this._customMixers)e.update(t.deltaSeconds)}addMixer(t){this._customMixers.indexOf(t)===-1&&this._customMixers.push(t)}removeMixer(t){let e=this._customMixers.indexOf(t);e!==-1&&this._customMixers.splice(e,1)}get mixer(){return this._mixer||(this._mixer=new My(this._rendering.scene)),this._mixer}}class S1{constructor(){d(this,"_time",0),d(this,"_viewChanged",!1),d(this,"_viewMatrixWorld",new rt),d(this,"_viewMatrixWorldInverse",new rt),d(this,"_projectionMatrix",new rt),d(this,"_cameraMatrix",new rt),d(this,"_cameraMatrixInverse",new rt),d(this,"_cameraOffsetX",0),d(this,"_cameraOffsetY",0)}beginFrame(t,e){this._deltaTime=e-this._time,this._deltaSeconds=this._deltaTime/1e3,this._time=e;const i=t.camera,n=i.matrixWorld,r=i.projectionMatrix;n.equals(this._viewMatrixWorld)&&r.equals(this._projectionMatrix)?this._viewChanged=!1:this._viewChanged=!0,this._viewMatrixWorld.copy(i.matrixWorld),this._viewMatrixWorldInverse.copy(i.matrixWorldInverse),this._projectionMatrix.copy(i.projectionMatrix)}endFrame(){}updateCameraOffsetState(t,e,i){this._cameraMatrix.copy(t.matrixWorld),this._cameraMatrixInverse.copy(t.matrixWorldInverse),this._cameraOffsetX=e,this._cameraOffsetY=i}get time(){return this._time}get viewChanged(){return this._viewChanged}get viewMatrixWorld(){return this._viewMatrixWorld}get viewMatrixWorldInverse(){return this._viewMatrixWorldInverse}get cameraMatrix(){return this._cameraMatrix}get cameraMatrixInverse(){return this._cameraMatrixInverse}get cameraOffsetX(){return this._cameraOffsetX}get cameraOffsetY(){return this._cameraOffsetY}get deltaTime(){return this._deltaTime}get deltaSeconds(){return this._deltaSeconds}}new Ke;class T1{constructor(t,e={}){d(this,"_engine"),d(this,"_outputEncoding"),d(this,"_enableAnimationLoop"),d(this,"_animationLoopFrameTime"),d(this,"_uniforms"),d(this,"_main"),d(this,"_shadow"),d(this,"_bloom"),d(this,"_ssr"),d(this,"_composition"),d(this,"_fog"),d(this,"_label"),d(this,"_colorAdjust"),d(this,"_renderState"),d(this,"_camera"),d(this,"_canvas"),d(this,"_context"),d(this,"_renderer"),d(this,"_scene"),d(this,"_weather"),d(this,"_useMrt",!1),d(this,"_mainRenderTarget",null),d(this,"_needsPrepareRendering",!0),d(this,"_needsUpdateExtraProgramCacheKey",!0),d(this,"_tDiffuse",null),d(this,"_tDepth",null),d(this,"_tEmissive",null),d(this,"_tNormal",null),d(this,"_tSpecular",null),d(this,"_freezeUpdate",!1),d(this,"_isRunning",!1),d(this,"_needsRenderImmediately",!1),d(this,"_needsRenderNext",!1),d(this,"_beforeRenderListeners",[]),d(this,"_prepareRenderListeners",[]),d(this,"_startTime",0),d(this,"_pixelRatio",window.devicePixelRatio),d(this,"_resolution"),d(this,"_sky",null),d(this,"_debugShaderType",0),d(this,"_beforeScenePrepareRenderObjects",new Set),d(this,"_beforeSceneRenderObjects",new Set),d(this,"_onRenderModeChangedObjects",new Set),d(this,"_wireframe",!1),d(this,"_wireframeMaterial",null),d(this,"_autoOffsetRelativeCenter",!0),d(this,"handleShaderBeforeResolve",(i,n,r)=>{if(this._useMrt){const a=this._renderer.getRenderTarget();a&&a.isWebGLMultipleRenderTargets&&(n=this.convertMrtSupportedFragment(n))}else this._bloom.enabled&&(n=this.convertNMrtSupportedFragment(n,r.shaderID));return r.shaderID==="basic"&&(n=`#define BASIC
uniform vec3 emissive;
`+n),{vertexShader:i=(a=>{const o="void main()",l=(a=a.replace(o,`#include <mvt_clip_pars_vertex>
`+o)).indexOf(o),h=a.slice(l+o.length),c=l+o.length+h.indexOf("{")+1;return a.slice(0,c)+`
    #include <mvt_clip_vertex>
`+a.slice(c)})(i),fragmentShader:n=(a=>{const o="void main()",l=(a=a.replace(o,`#include <mvt_clip_pars_fragment>
`+o)).indexOf(o),h=a.slice(l+o.length),c=l+o.length+h.indexOf("{")+1;return a.slice(0,c)+`
    #include <mvt_clip_fragment>
`+a.slice(c)})(n)}}),d(this,"handleShaderBeforeCompile",(i,n,r)=>{if(i=((a,o,l,h)=>{if(a=a.replace("void main()",o+`void main()
`),h){const c=a.lastIndexOf("}");a=a.substring(0,c),a+=h+"}"}return a})(i,`
attribute float _tileEditableValue;
`,null,`
if (_tileEditableValue == 1.0) {
    gl_Position = vec4(-1.0, -1.0, -1.0, -1.0);
}
`),this._useMrt){const a=this._renderer.getRenderTarget();a&&a.isWebGLMultipleRenderTargets&&r.isRawShaderMaterial&&r.glslVersion!==Rh&&(i=["#version 300 es","precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+i,n=["#version 300 es","#define varying in","layout(location = 0) out highp vec4 pc_fragColor;","#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+n)}return{vertexShader:i,fragmentShader:n}}),d(this,"convertMrtSupportedFragment",(i,n)=>(r=>{let a=r;a=a.replace("void main() {",`#include <mvt_mrt_output_pars_fragment>
void main() {`);const o=a.lastIndexOf("}");return a=a.substring(0,o),a+=`#include <mvt_mrt_output_fragment>
}`,a})(i)),d(this,"convertNMrtSupportedFragment",(i,n)=>(r=>{let a=r;a=a.replace("void main() {",`#include <mvt_nmrt_output_pars_fragment>
void main() {`);const o=a.lastIndexOf("}");return a=a.substring(0,o),a+=`#include <mvt_nmrt_output_fragment>
}`,a})(i)),d(this,"render",()=>{if(!this._isRunning)return;requestAnimationFrame(this.render);const i=new Date().valueOf();if((this._needsRenderNext||this._enableAnimationLoop)&&this._animationLoopFrameTime<17&&(this._needsRenderImmediately=!0),!(this._needsRenderImmediately||(this._needsRenderNext||this._enableAnimationLoop)&&i-this.lastRenderTime>=this._animationLoopFrameTime))return;let n=this._needsRenderImmediately?0:i-this.lastRenderTime-this._animationLoopFrameTime;n>this._animationLoopFrameTime-16&&(n=this._animationLoopFrameTime-16),this.lastRenderTime=i-n,this._needsRenderImmediately=!1,this._needsRenderNext=!1,this.renderScene(i)}),d(this,"getExtraProgramCacheKey",()=>{if(this._useMrt){const i=this._renderer.getRenderTarget();if(i&&i.isWebGLMultipleRenderTargets)return"1"}return"0"}),d(this,"scaleZAtCurrentPosition",()=>{const i=this._engine.map,n=i.getScaleAt(i.getCenter());this.scene.scale.z=n}),this._engine=t,this._outputEncoding=e.outputEncoding||Bt,this._preserveDrawingBuffer=e.preserveDrawingBuffer||!1,this._enableAnimationLoop=e.enableAnimationLoop||!1,this._animationLoopFrameTime=e.animationLoopFrameTime||16,this._pixelRatio=e.pixelRatio||window.devicePixelRatio,this._resolution=e.resolution,this._uniforms={time:{value:0},elapsedTime:{value:0},pixelRatio:{value:this._pixelRatio},zoomUnits:{value:1},resolution:{value:new j(e.resolution.x,e.resolution.y)},mvt_clipParameters:{value:{isClip:!1,clip_type:0,u_polygon:[new M,new M,new M],clip_point:new j,clip_radius:0,clip_width:0,clip_height:0}}},Object.freeze(this._uniforms),this._main=new Py(this),this._shadow=new Ry(this),this._bloom=new Ny(this),this._ssr=new Ky(this),this._composition=new e1(this),this._fog=new Dy(this),this._postprocessing=new n1(this),this._label=new d1(this),this._colorAdjust=new p1(this),this._collision=new M1(this),this._animation=new w1(this),this._renderState=new S1(this)}init(){const t=this._canvas=document.createElement("canvas");xt(t,`${te}-canvas`),t.style.position="absolute",t.style.top="0",t.style.left="0",t.style.zIndex="2";const e=this._context=t.getContext("webgl2",{alpha:!0,stencil:!0,antialias:!0,powerPreference:"high-performance",preserveDrawingBuffer:this._preserveDrawingBuffer}),i=this._resolution;(this._camera=new ye(35,i.x/i.y,.1,100)).matrixAutoUpdate=!1;const n=this._scene=new Gp,r=this.objectsScene=new De,a=this.environmentScene=new De;n.add(r),n.add(a),n.autoUpdate=!1;const o=this._renderer=new jp({canvas:t,context:e,logarithmicDepthBuffer:!0});o.setClearColor(16777215,0),o.setPixelRatio(this._pixelRatio),o.setSize(i.x,i.y),o.outputEncoding=this._outputEncoding,o.info.autoReset=!1,this._renderer.extraProgramCacheKey="0",o.onShaderBeforeResolve=this.handleShaderBeforeResolve,o.onShaderBeforeCompile=this.handleShaderBeforeCompile,this._uniforms.resolution.value[0]=i.x,this._uniforms.resolution.value[1]=i.y,this._label.init()}addBeforeRenderListener(t){this._beforeRenderListeners.indexOf(t)===-1&&this._beforeRenderListeners.push(t)}removeBeforeRenderListener(t){const e=this._beforeRenderListeners.indexOf(t);e>-1&&this._beforeRenderListeners.splice(e,1)}addPrepareRenderListener(t){this._prepareRenderListeners.indexOf(t)===-1&&this._prepareRenderListeners.push(t)}removePrepareRenderListener(t){const e=this._prepareRenderListeners.indexOf(t);e>-1&&this._prepareRenderListeners.splice(e,1)}add(t){return t.traverse(e=>{e.afterAddToEngine&&!e.__initInEngine&&(e.__initInEngine=!0,e.afterAddToEngine(this._engine)),e instanceof Fr?this._sky=e:e instanceof Ec&&(this._weather=e),this.addBeforePrepareRenderObject(e),this.addBeforeRenderObject(e),this.addOnRenderModeChangeObject(e)}),t.__isEnvironment?this.environmentScene.add(t):this.objectsScene.add(t),this._needsRenderImmediately=!0,t}remove(t){t.traverse(e=>{e.beforeRemoveFromEngine&&(e.__initInEngine=void 0,e.beforeRemoveFromEngine(this._engine)),e instanceof Fr?this._sky=null:e instanceof Ec&&(this._weather=null),this.removeBeforeRenderObject(e),this.removeBeforePrepareRenderObject(e),this.removeOnRenderModeChangeObject(e)}),t.__isEnvironment?this.environmentScene.remove(t):this.objectsScene.remove(t),this._needsRenderImmediately=!0}addBeforePrepareRenderObject(t){t.onBeforeScenePrepareRender&&this._beforeScenePrepareRenderObjects.add(t)}removeBeforePrepareRenderObject(t){this._beforeScenePrepareRenderObjects.delete(t)}addBeforeRenderObject(t){t.onBeforeSceneRender&&this._beforeSceneRenderObjects.add(t)}removeBeforeRenderObject(t){this._beforeSceneRenderObjects.delete(t)}addOnRenderModeChangeObject(t){t.onRenderModeChanged&&this._onRenderModeChangedObjects.add(t)}removeOnRenderModeChangeObject(t){t.onRenderModeChanged&&this._onRenderModeChangedObjects.delete(t)}startRenderLoop(){this._isRunning=!0,this._needsRenderImmediately=!0,this._startTime=new Date().valueOf(),this.render()}stopRenderLoop(){this._isRunning=!1}updateCamera(){this._engine.map.updateCamera()}requestRender(){this._needsRenderImmediately=!0}renderScene(t){const e=this._engine;t||(t=new Date().valueOf()),this._uniforms.time.value=t,this._uniforms.elapsedTime.value=t-this._startTime,this._uniforms.zoomUnits.value=this._engine.map.getZoomUnits(),this.camera._isLocked||this.updateCamera(),e.event.executeMousemoveRaycast();const i=this._camera,n=this._scene,r=this._renderState;r.beginFrame(this,t),this._animation.update(r);for(let p of this._prepareRenderListeners)p(this._engine,r);this._beforeScenePrepareRenderObjects.forEach(p=>{p.onBeforeScenePrepareRender(e,n,i,r)});const a=new M(i.matrix.elements[12],i.matrix.elements[13],i.matrix.elements[14]);let o=0,l=0;const h=1e3,c=Math.floor(a.x/h)*h,u=Math.floor(a.y/h)*h;o=a.x-c,l=a.y-u,this._autoOffsetRelativeCenter&&(i.position.set(o,l,a.z),i.updateMatrix(),i.updateMatrixWorld(),n.position.set(-c,-u,0)),r.updateCameraOffsetState(i,c,u),n.updateMatrix(),n.updateMatrixWorld(),this._renderer.info.reset(),this._collision.collisionTest(),this._beforeSceneRenderObjects.forEach(p=>{p.onBeforeSceneRender(e,n,i,r)});for(let p of this._beforeRenderListeners)p(this._engine,r);this._renderer.extraProgramCacheKey=this._useMrt?"1":"0",this._main.render(),this._renderer.extraProgramCacheKey="0",this._bloom.render(),this._ssr.render(),this._composition.render(),this._fog.render(),this._postprocessing.render(),this._autoOffsetRelativeCenter&&(i.position.set(a.x,a.y,a.z),i.updateMatrix(),i.updateMatrixWorld(),n.position.set(0,0,0),n.updateMatrix(),n.updateMatrixWorld()),r.endFrame(this)}setResolution(t){this._resolution.copy(t),this._uniforms.resolution.value.copy(t),this._renderer.setSize(t.x,t.y),this._main.setSize(t.x,t.y),this._bloom.setSize(t.x,t.y),this._ssr.setSize(t.x,t.y),this._needsRenderNext=!0}dispose(){this.stopRenderLoop(),this._wireframeMaterial&&this._wireframeMaterial.dispose();const t=Array.from(this.objectsScene.children),e=Array.from(this.environmentScene.children);for(const n of t)this.remove(n),n.dispose&&n.dispose();for(const n of e)this.remove(n),n.dispose&&n.dispose();this._renderer.dispose();let i=this._context.getExtension("WEBGL_lose_context");i&&i.loseContext()}get sky(){return this._sky}get weather(){return this._weather}get debugShaderType(){return this._debugShaderType}set debugShaderType(t){if(this._debugShaderType=t,!this._useMrt)return;t=parseInt(t,10);const e=this._composition;if(t&&t!==0)if(t===1)e.debugTextures=this._main.getTextures();else if(t===2){const i=[];this.objectsScene.traverse(n=>{n.isLight&&n.shadow&&n.shadow.map&&i.push(n.shadow.map.texture)}),e.debugTextures=i}else t===3?e.debugTextures=this._bloom.getTextures():t===4?e.debugTextures=this._ssr.getTextures():t===5&&this._sky&&this._sky.getTextures&&(e.debugTextures=this._sky.getTextures());else e.debugTextures=null}get useMrt(){return this._useMrt}set useMrt(t){this._useMrt!==t&&(this._useMrt=t,this._main.useMrt=t,this._bloom.useMrt=t,this._ssr.useMrt=t,this._composition.useMrt=t,this._postprocessing.useMrt=t,this._needsUpdateExtraProgramCacheKey=!0,this._onRenderModeChangedObjects.forEach(e=>{e.onRenderModeChanged&&e.onRenderModeChanged(t)}))}get main(){return this._main}get shadow(){return this._shadow}get bloom(){return this._bloom}get ssr(){return this._ssr}get composition(){return this._composition}get fog(){return this._fog}get postprocessing(){return this._postprocessing}get label(){return this._label}get colorAdjust(){return this._colorAdjust}get renderState(){return this._renderState}get collision(){return this._collision}get animation(){return this._animation}get enableAnimationLoop(){return this._enableAnimationLoop}set enableAnimationLoop(t){this._enableAnimationLoop=t}get animationLoopFrameTime(){return this._animationLoopFrameTime}set animationLoopFrameTime(t){this._animationLoopFrameTime=t}get resolution(){return this._resolution}set resolution(t){this._resolution=t}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t}get outputEncoding(){return this._outputEncoding}set outputEncoding(t){this._outputEncoding=t}get canvas(){return this._canvas}get renderer(){return this._renderer}get camera(){return this._camera}get scene(){return this._scene}get uniforms(){return this._uniforms}set wireframe(t){t?(this._wireframe=!0,this._wireframeMaterial||(this._wireframeMaterial=new ae({color:35071,wireframe:!0})),this._scene.overrideMaterial=this._wireframeMaterial):(this._wireframe=!1,this._scene.overrideMaterial=null)}get wireframe(){return this._wireframe}get autoOffsetRelativeCenter(){return this._autoOffsetRelativeCenter}set autoOffsetRelativeCenter(t){this._autoOffsetRelativeCenter=t}get freezeUpdate(){return this._freezeUpdate}set freezeUpdate(t){!!t!==this._freezeUpdate&&(this._freezeUpdate=!!t,t?this.stopRenderLoop():this.startRenderLoop())}}class C1{constructor(){d(this,"isFlowEvent",!0)}execute(){}}class E1 extends C1{constructor(t,e=0){super(),d(this,"_currentIndex",0),d(this,"_callbacks",[]),e>t.length-1&&(e=t.length-1),e<0&&(e=0),this._currentIndex=e,Array.isArray(t)?this._callbacks=t:console.warn("callbacks must be an array")}execute(t){const e=this._callbacks[this._currentIndex];e&&e(t,this._currentIndex),this._currentIndex++,this._currentIndex>this._callbacks.length-1&&(this._currentIndex=0)}}const qe=class{constructor(s){d(this,"_realtimePickEnabled",!1),d(this,"_mousePickNeedsUpdate",!1),d(this,"_mouse",new j),d(this,"_mousePosition",new j),d(this,"_eventMaps",{}),d(this,"_objectEvents",new Map),d(this,"_raycaster",new Us),d(this,"_mapPlane",new ai(new M(0,0,1),0)),d(this,"_tempVector3",new M),d(this,"_intersections"),d(this,"_defaultEventObject"),d(this,"_mousePickParams",null),d(this,"_lastMousePickIntersectParams",null),d(this,"_engine",null),d(this,"_pickEventNames",null),d(this,"_checkShouldEnableRealtimePick",()=>{let t=null;for(const e of Object.keys(this._eventMaps))if(this._pickEventNames[e]&&(t=this._eventMaps[e],t&&t.size>0))return void(this._realtimePickEnabled=!0);this._realtimePickEnabled=!1}),d(this,"_raycast",()=>{const t=this._engine;this._raycaster.setFromCamera(this._mouse,t.camera),this._raycaster.mouse.copy(this._mouse);const e=this._raycaster.intersectObjects(t.rendering.objectsScene.children,!0);this._intersections=e}),d(this,"get3DTilesObject",t=>{for(;t&&!t.is3DTiles;)t=t.parent;return t}),d(this,"get3DTilesPropertiesByBatchId",(t,e)=>{let i=t;for(;!i.batchTable;)i=i.parent;if(!i)return void console.warn("batch table not found");const n=i.batchTable,r={};for(const a of Object.keys(n.header)){const o=n.header[a];r[a]=o[e]}return r._tileUri=i._tileUri,r.tile=i,r}),d(this,"triggerFirstEventObject",(t,e)=>{if(!this._intersections||this._intersections.length===0||!this._eventMaps[t])return!1;const i=this._eventMaps[t];for(let n=0,r=this._intersections.length;n<r;++n){const a=this._intersections[n],o=a.object;if(!o.visible)continue;let l=this._getEventProxyObject(o);if(!l.visible)continue;const h=o.geometry?o.geometry.getAttribute("_batchid"):void 0;let c=!1,u=!1,p=null;if(h){const m=this.get3DTilesObject(o);m&&(l=m,c=!0)}else{const m=this.get3DTilesObject(o);m&&(u=!0,p=l,l=m)}if(i.has(l)){if(e.object=l,a.point&&this._correctHitPosition(a.point,e),c){const f=h.getX(a.face.a);if(e.entity=this.get3DTilesPropertiesByBatchId(o,f),!this.get3DTilesObject(o).isEntityVisible(e.entity))continue}else u?p.isEventEntitySupported&&(e.entity=this._getEventEntity(p,a)):l.isEventEntitySupported&&(e.entity=this._getEventEntity(l,a));e.directObject=o;const m=i.get(l);return this._executeCallbacks(m,e),!0}}return!1}),d(this,"_getEventEntity",(t,e)=>{let i=-1;return e.instanceId!==void 0?i=e.instanceId:e.face!==void 0&&e.face!==null?t.getEntityIndexByFace&&(i=t.getEntityIndexByFace(e.faceIndex,e.face.a)):e.index!==void 0&&(i=e.index),i<0?null:t.getEntityByIndex(i)}),d(this,"_getEventProxyObject",t=>{for(;t.__eventProxyObject||t.__eventProxyByParent;)t=t.__eventProxyByParent?t.parent:t.__eventProxyObject;return t}),d(this,"_correctHitPosition",(t,e)=>{const i=[t.x,t.y,t.z],n=this._engine.map._map.normalizeEarthPointArr(i);n[2]=i[2],e.point=n,e.position=i}),d(this,"_handleClick",t=>{if(this._updateMouse(t),this._raycast(),this.triggerFirstEventObject(qe.EVENT_NAME_CLICK,t)&&(t.event.defaultPrevented||t.event.domEvent&&t.event.domEvent.defaultPrevented))return;const e=this._eventMaps.click&&this._eventMaps.click.get(this._defaultEventObject);e&&this._executeCallbacks(e,t)}),d(this,"_handleDblClick",t=>{if(this._updateMouse(t),this._raycast(),this.triggerFirstEventObject(qe.EVENT_NAME_DOUBLE_CLICK,t)&&(t.event.defaultPrevented||t.event.domEvent&&t.event.domEvent.defaultPrevented))return;const e=this._eventMaps.dblclick&&this._eventMaps.dblclick.get(this._defaultEventObject);e&&this._executeCallbacks(e,t)}),d(this,"_handleRightClick",t=>{if(this._updateMouse(t),this._raycast(),this.triggerFirstEventObject(qe.EVENT_NAME_RIGHT_CLICK,t)&&(t.event.defaultPrevented||t.event.domEvent&&t.event.domEvent.defaultPrevented))return;const e=this._eventMaps.rightclick&&this._eventMaps.rightclick.get(this._defaultEventObject);e&&this._executeCallbacks(e,t)}),d(this,"_handleRightDblClick",t=>{if(this._updateMouse(t),this._raycast(),this.triggerFirstEventObject(qe.EVENT_NAME_RIGHT_DOUBLE_CLICK,t)&&(t.event.defaultPrevented||t.event.domEvent&&t.event.domEvent.defaultPrevented))return;const e=this._eventMaps.rightdblclick&&this._eventMaps.rightdblclick.get(this._defaultEventObject);e&&this._executeCallbacks(e,t)}),d(this,"_updateMouse",t=>{const e=this._engine.map.getResolution(),i=t.pixel[0]/e.x,n=t.pixel[1]/e.y;this._mouse.set(2*i-1,1-2*n),this._mousePosition.set(t.pixel[0],t.pixel[1])}),d(this,"_triggerMouseleaveEvent",()=>{const t=this._lastMousePickIntersectParams,e=t.object;if(!e)return;const i=this._objectEvents.get(e);i&&i[qe.EVENT_NAME_MOUSE_LEAVE]&&this._executeCallbacks(i[qe.EVENT_NAME_MOUSE_LEAVE],{...this._mousePickParams,object:t.object,entity:t.entity})}),d(this,"_isSameObjectAndEntity",(t,e)=>{const i=t.object,n=e.object,r=t.entity,a=e.entity;return i===n&&(r===void 0&&a===void 0||r!==void 0&&a!==void 0&&(r.index===void 0||r.index===a.index))}),d(this,"_getMouseHoverIntersetion",()=>{if(!this._intersections||this._intersections.length===0)return!1;const t=this._mousePickParams;for(let e=0,i=this._intersections.length;e<i;++e){const n=this._intersections[e],r=n.object;if(!r.visible)continue;let a=this._getEventProxyObject(r);if(!a.visible||!r.geometry)continue;const o=r.geometry.getAttribute("_batchid");let l=!1;if(o){const c=this.get3DTilesObject(r);c&&(a=c,l=!0)}else{const c=this.get3DTilesObject(r);c&&(a=c)}let h=null;if(this._objectEvents.has(a)&&(h=this._objectEvents.get(a)),h&&(h[qe.EVENT_NAME_MOUSE_MOVE]||h[qe.EVENT_NAME_MOUSE_ENTER]||h[qe.EVENT_NAME_MOUSE_LEAVE])){if(t.object=a,n.point&&this._correctHitPosition(n.point,t),l){const c=o.getX(n.face.a);t.entity=this.get3DTilesPropertiesByBatchId(r,c)}else a.isEventEntitySupported&&(t.entity=this._getEventEntity(a,n));return h}}}),this._engine=s,this._defaultEventObject={},this._raycaster.mouse=new j,this._pickEventNames={[qe.EVENT_NAME_MOUSE_MOVE]:!0,[qe.EVENT_NAME_MOUSE_ENTER]:!0,[qe.EVENT_NAME_MOUSE_LEAVE]:!0}}bind(s,t,e){typeof s=="string"&&(e=t,t=s,s=this._defaultEventObject),this._eventMaps[t]||(this._eventMaps[t]=new Map);const i=this._eventMaps[t];i.has(s)||i.set(s,[]);const n=i.get(s);n.indexOf(e)===-1&&n.push(e),this._objectEvents.has(s)||this._objectEvents.set(s,{});const r=this._objectEvents.get(s);r[t]||(r[t]=n),this._checkShouldEnableRealtimePick()}unbind(s,t,e){typeof s=="string"&&(e=t,t=s,s=this._defaultEventObject);const i=this._eventMaps[t];let n=!1;if(i&&i.has(s)){const r=i.get(s),a=r.indexOf(e);a>-1&&r.splice(a,1),r.length===0&&(i.delete(s),n=!0)}if(n){const r=this._objectEvents.get(s);r&&delete r[t]}this._checkShouldEnableRealtimePick()}markEventProxy(s,t){const e=t||s;if(s.children)for(let i=0,n=s.children.length;i<n;i++)s.children[i].__eventProxyObject=e,this.markEventProxy(s.children[i])}createMultipleToggleEvent(s,t=0){return new E1(s,t)}_executeCallbacks(s,t){if(s){for(const e of s)if(e){if(t.event&&(t.event.defaultPrevented||t.event.domEvent&&t.event.domEvent.defaultPrevented))return;e.isFlowEvent?e.execute(t):e(t)}}}requestMousemoveRaycast(s){if(!this._realtimePickEnabled)return;this._updateMouse(s),this._mousePickParams=s,this._mousePickNeedsUpdate=!0;const t=this._eventMaps.mousemove&&this._eventMaps.mousemove.get(this._defaultEventObject);if(t){this._raycaster.setFromCamera(this._mouse,this._engine.rendering.camera),this._raycaster.ray.intersectPlane(this._mapPlane,this._tempVector3);const e=[this._tempVector3.x,this._tempVector3.y,this._tempVector3.z],i=this._engine.map._map.normalizeEarthPointArr(e);this._executeCallbacks(t,{...s,point:i,position:e})}this._engine.requestRender()}executeMousemoveRaycast(){if(!this._mousePickNeedsUpdate)return;this._mousePickNeedsUpdate=!1,this._raycast();const s=this._getMouseHoverIntersetion();if(s){if(this._executeCallbacks(s[qe.EVENT_NAME_MOUSE_MOVE],this._mousePickParams),this._lastMousePickIntersectParams&&this._isSameObjectAndEntity(this._mousePickParams,this._lastMousePickIntersectParams))return void(this._lastMousePickIntersectParams=this._mousePickParams);this._lastMousePickIntersectParams&&this._triggerMouseleaveEvent(),this._executeCallbacks(s[qe.EVENT_NAME_MOUSE_ENTER],this._mousePickParams),this._lastMousePickIntersectParams=this._mousePickParams}else this._lastMousePickIntersectParams&&this._triggerMouseleaveEvent(),this._lastMousePickIntersectParams=null}dispose(){}};let Zi=qe;d(Zi,"EVENT_NAME_CLICK","click"),d(Zi,"EVENT_NAME_DOUBLE_CLICK","dblclick"),d(Zi,"EVENT_NAME_RIGHT_CLICK","rightclick"),d(Zi,"EVENT_NAME_RIGHT_DOUBLE_CLICK","rightdblclick"),d(Zi,"EVENT_NAME_MOUSE_MOVE","mousemove"),d(Zi,"EVENT_NAME_MOUSE_ENTER","mouseenter"),d(Zi,"EVENT_NAME_MOUSE_LEAVE","mouseleave"),d(Zi,"EVENT_NAME_MOUSE_DOWN","mousedown"),d(Zi,"EVENT_NAME_MOUSE_UP","mouseup");class Vc{init(){}parsePointToArr(t){if(!t)return null;let e=[];if(Array.isArray(t))for(let i of t)e.push(parseFloat(i));else if(typeof t=="string"){const i=t.split(",");for(let n=0;n<i.length;n++)e[n]=parseFloat(i[n])}return e}projectPointArr(t,e){}projectGeoJSON(t){if(t){if(t.type==="FeatureCollection"||t.features){const e=t.features;for(const i of e)this.projectGeoJSON(i)}else if(Array.isArray(t)){const e=t;for(const i of e)this.projectGeoJSON(i)}else if((t.type==="Feature"||t.geometry)&&Array.isArray(t.geometry.coordinates)){if(t.geometry[this.projectionCoordsName])return;const e=this.projectCoordinates(t.geometry.coordinates);t.geometry[this.projectionCoordsName]=e}}}projectCoordinates(t){if(Array.isArray(t[0])){const e=[];for(let i of t)e.push(this.projectCoordinates(i));return e}if(typeof t[0]=="number"||typeof t[0]=="string")return this.projectPointArr(t)}dispose(){}}const A1=!!window.PointerEvent,P1=/ipod|ipad|iphone|android/.test(navigator.userAgent.toLowerCase()),vt=(()=>{let s;return s=A1?{DOWN:"pointerdown",MOVE:"pointermove",UP:"pointerup",CANCEL:"pointercancel"}:P1?{DOWN:"touchstart",MOVE:"touchmove",UP:"touchend",CANCEL:"touchcancel"}:{DOWN:"mousedown",MOVE:"mousemove",UP:"mouseup",CANCEL:"mousecancel"},s})(),Zr=0,af=1,of=2,qa=new j,lf=new Us,R1=new ai(new M(0,0,1),0),Vs=new M,Hc=new M,Ya=new M,jc=new ye;jc.fov=35;class D1{constructor(t){d(this,"map"),d(this,"currentAction"),d(this,"startX"),d(this,"startY"),d(this,"startCenterX"),d(this,"startCenterY"),d(this,"startPitch"),d(this,"startHeading"),d(this,"startZoom"),d(this,"startZoomUnits"),d(this,"startAtTop"),d(this,"mapWidth"),d(this,"mapHeight"),d(this,"startCamera",new ye),d(this,"startCenter",new M),d(this,"startNdc",new j),d(this,"startPoint",new M),d(this,"startScaleX",1),d(this,"startScaleY",1),d(this,"startBoundX"),d(this,"startBoundY"),d(this,"_enabled",!1),d(this,"minPitch",0),d(this,"maxPitch",89),d(this,"zoomSpeed",.005),d(this,"headingSpeed",.4),d(this,"pitchSpeed",.3),d(this,"doubleClickTimer",null),d(this,"clickInterval",200),d(this,"init",()=>{const e=this.map.domContainer;e.addEventListener(vt.DOWN,this.handleMouseDown),e.addEventListener("wheel",this.handleWheel),e.addEventListener("contextmenu",this.handleContextMenu),e.addEventListener(vt.MOVE,this.handleMouseMove)}),d(this,"handleResize",e=>{const[i,n]=this.map.getContainerSize();this.mapWidth=i,this.mapHeight=n;const r=this.map.domContainer.getBoundingClientRect();this.startBoundX=r.left,this.startBoundY=r.top,this.startScaleX=r.width/i,this.startScaleY=r.height/n}),d(this,"handleMouseMove",e=>{this.currentAction===Zr&&this.onEventMouseMove&&this.onEventMouseMove(e)}),d(this,"handleMouseDown",e=>{let i=this.mapHeight,n=this.mapWidth;const r=this.map.domContainer.getBoundingClientRect();this.startBoundX=r.left,this.startBoundY=r.top,this.startScaleX=r.width/n,this.startScaleY=r.height/i;const a=(e.clientX-this.startBoundX)/this.startScaleX,o=(e.clientY-this.startBoundY)/this.startScaleY;if(e.button===0?(this.startZoomUnits=this.map.getZoomUnitsByZoom(this.map.zoom),this.setPanStartState(a,o),this.currentAction=af):e.button===2?this.currentAction=of:this.currentAction=Zr,this.currentAction===Zr)return;this.startX=a,this.startY=o;const l=this.map;this.startCenterX=l.center[0],this.startCenterY=l.center[1],this.startPitch=l.pitch,this.startHeading=l.heading,this.startZoom=l.zoom,this.startAtTop=o<i/2,document.addEventListener(vt.MOVE,this.handleMouseDragging),document.addEventListener(vt.UP,this.handleMouseUp)}),d(this,"handleMouseDragging",e=>{if(this.currentAction===Zr)return;this.hasMoved=!0;const i=this.currentPixelX=(e.clientX-this.startBoundX)/this.startScaleX,n=this.currentPixelY=(e.clientY-this.startBoundY)/this.startScaleY;this.currentAction===af?this.handlePan(i,n):this.currentAction===of&&this.handleRotate(i,n)}),d(this,"handleMouseUp",e=>{this.currentAction=Zr,document.removeEventListener(vt.MOVE,this.handleMouseDragging),document.removeEventListener(vt.UP,this.handleMouseUp),e&&this.onEventClick&&(this.hasMoved||this.onEventClick(e)),e&&this.onEventDblClick&&(!this.hasMoved&&this.waitSecondClick?(this.onEventDblClick(e),this.clearDoubleClickTimer()):this.waitSecondClick=!0),clearTimeout(this.doubleClickTimer),this.doubleClickTimer=setTimeout(()=>{this.clearDoubleClickTimer()},this.clickInterval),this.hasMoved=!1}),d(this,"clearDoubleClickTimer",()=>{this.doubleClickTimer&&clearTimeout(this.doubleClickTimer),this.waitSecondClick=!1,this.doubleClickTimer=null}),d(this,"handleContextMenu",e=>{e.preventDefault()}),d(this,"handleWheel",e=>{e.preventDefault(),e.stopPropagation();const i=(e.clientX-this.startBoundX)/this.startScaleX,n=(e.clientY-this.startBoundY)/this.startScaleY;this.handleZoom({deltaX:e.deltaX,deltaY:e.deltaY,pixelX:i,pixelY:n})}),d(this,"handlePan",(e,i)=>{const n=this.map;this.getNdc(e,i,qa),this.ndcToPoint(qa,this.startCamera,Ya),Ya.distanceTo(this.startCamera.position)>6e3*n.zoomUnits?this.handleMouseUp():(Vs.subVectors(this.startCenter,Ya.sub(this.startPoint)),n.center=[Vs.x,Vs.y],n.updateView())}),d(this,"setPanStartState",(e,i)=>{const n=this.map;this.startCamera.copy(n.camera),this.startCamera.updateMatrixWorld(),this.startCenter.set(n.center[0],n.center[1],0),this.getNdc(e,i,this.startNdc),this.ndcToPoint(this.startNdc,n.camera,this.startPoint)}),d(this,"handleRotate",(e,i)=>{const n=this.map;let r=e-this.startX;const a=i-this.startY;this.startAtTop||(r*=-1);let o=this.startHeading+r*this.headingSpeed;o=this.makeHeadingSafe(o),n.heading=o;let l=this.startPitch+a*this.pitchSpeed;l=this.makePitchSafe(l),n.pitch=l,n.updateView()}),d(this,"handleZoom",e=>{const i=this.map;let n=i.zoom,r=n+e.deltaY*this.zoomSpeed*-1;if(n===r)return;if(r=this.makeZoomSafe(r),r<i.earthViewZoomMax)return this.map.zoom=r,void this.map.updateView();let a=i.center,o=i.pitch,l=i.heading;this.getNdc(e.pixelX,e.pixelY,qa),Vs.set(a[0],a[1],0),this.ndcToPoint(qa,i.camera,Hc),Hc.distanceTo(i.camera.position)>6e3*i.zoomUnits||(i.computeMapCameraMatrix(jc,a,r,o,l),this.ndcToPoint(qa,jc,Ya),Vs.sub(Ya.sub(Hc)),this.map.center[0]=Vs.x,this.map.center[1]=Vs.y,this.map.zoom=r,this.map.updateView())}),d(this,"makeZoomSafe",e=>e>this.map.maxZoom?this.map.maxZoom:e<this.map.minZoom?this.map.minZoom:e),d(this,"makeHeadingSafe",e=>((e%=360)<0&&(e+=360),e)),d(this,"makePitchSafe",e=>e<this.minPitch?this.minPitch:e>this.maxPitch?this.maxPitch:e),d(this,"dispose",()=>{const e=this.map.domContainer;e.removeEventListener(vt.DOWN,this.handleMouseDown),e.removeEventListener("wheel",this.handleWheel),e.removeEventListener("contextmenu",this.handleContextMenu),document.removeEventListener(vt.MOVE,this.handleMouseDragging),document.removeEventListener(vt.UP,this.handleMouseUp),e.removeEventListener(vt.MOVE,this.handleMouseMove),this.clearDoubleClickTimer()}),this.map=t,this.enabled=!0,this.currentAction=Zr}set enabled(t){t!==this._enabled&&(t?this.init():this.dispose(),this._enabled=t)}ndcToPoint(t,e,i){lf.setFromCamera(t,e),lf.ray.intersectPlane(R1,i)}getNdc(t,e,i){i.x=t/this.mapWidth*2-1,i.y=1-e/this.mapHeight*2}}var Hs={},Jr={},hf={};(function(s){Object.defineProperty(s,"__esModule",{value:!0}),s.default=void 0;var t=1;s.default=function(){return"".concat(t++)}})(hf);var Sl={},Tl={},Gc={};(function(s){Object.defineProperty(s,"__esModule",{value:!0}),s.default=void 0,s.default=function(t){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:60,i=null;return function(){for(var n=this,r=arguments.length,a=new Array(r),o=0;o<r;o++)a[o]=arguments[o];clearTimeout(i),i=setTimeout(function(){t.apply(n,a)},e)}}})(Gc);var Tn={};Object.defineProperty(Tn,"__esModule",{value:!0}),Tn.SensorTabIndex=Tn.SensorClassName=Tn.SizeSensorId=void 0,Tn.SizeSensorId="size-sensor-id",Tn.SensorClassName="size-sensor-object",Tn.SensorTabIndex="-1",Object.defineProperty(Tl,"__esModule",{value:!0}),Tl.createSensor=void 0;var Cl,L1=(Cl=Gc)&&Cl.__esModule?Cl:{default:Cl},cf=Tn;Tl.createSensor=function(s){var t=void 0,e=[],i=(0,L1.default)(function(){e.forEach(function(r){r(s)})}),n=function(){t&&t.parentNode&&(t.contentDocument&&t.contentDocument.defaultView.removeEventListener("resize",i),t.parentNode.removeChild(t),t=void 0,e=[])};return{element:s,bind:function(r){t||(t=function(){getComputedStyle(s).position==="static"&&(s.style.position="relative");var a=document.createElement("object");return a.onload=function(){a.contentDocument.defaultView.addEventListener("resize",i),i()},a.style.display="block",a.style.position="absolute",a.style.top="0",a.style.left="0",a.style.height="100%",a.style.width="100%",a.style.overflow="hidden",a.style.pointerEvents="none",a.style.zIndex="-1",a.style.opacity="0",a.setAttribute("class",cf.SensorClassName),a.setAttribute("tabindex",cf.SensorTabIndex),a.type="text/html",s.appendChild(a),a.data="about:blank",a}()),e.indexOf(r)===-1&&e.push(r)},destroy:n,unbind:function(r){var a=e.indexOf(r);a!==-1&&e.splice(a,1),e.length===0&&t&&n()}}};var El={};Object.defineProperty(El,"__esModule",{value:!0}),El.createSensor=void 0;var I1=function(s){return s&&s.__esModule?s:{default:s}}(Gc);El.createSensor=function(s){var t=void 0,e=[],i=(0,I1.default)(function(){e.forEach(function(r){r(s)})}),n=function(){t.disconnect(),e=[],t=void 0};return{element:s,bind:function(r){var a;t||((a=new ResizeObserver(i)).observe(s),i(),t=a),e.indexOf(r)===-1&&e.push(r)},destroy:n,unbind:function(r){var a=e.indexOf(r);a!==-1&&e.splice(a,1),e.length===0&&t&&n()}}},Object.defineProperty(Sl,"__esModule",{value:!0}),Sl.createSensor=void 0;var O1=Tl,z1=typeof ResizeObserver<"u"?El.createSensor:O1.createSensor;Sl.createSensor=z1,Object.defineProperty(Jr,"__esModule",{value:!0}),Jr.removeSensor=Jr.getSensor=void 0;var k1=function(s){return s&&s.__esModule?s:{default:s}}(hf),N1=Sl,Al=Tn,Za={};Jr.getSensor=function(s){var t=s.getAttribute(Al.SizeSensorId);if(t&&Za[t])return Za[t];var e=(0,k1.default)();s.setAttribute(Al.SizeSensorId,e);var i=(0,N1.createSensor)(s);return Za[e]=i,i},Jr.removeSensor=function(s){var t=s.element.getAttribute(Al.SizeSensorId);s.element.removeAttribute(Al.SizeSensorId),s.destroy(),t&&Za[t]&&delete Za[t]},Object.defineProperty(Hs,"__esModule",{value:!0}),Hs.ver=Xc=Hs.clear=uf=Hs.bind=void 0;var Wc=Jr,uf=Hs.bind=function(s,t){var e=(0,Wc.getSensor)(s);return e.bind(t),function(){e.unbind(t)}},Xc=Hs.clear=function(s){var t=(0,Wc.getSensor)(s);(0,Wc.removeSensor)(t)};Hs.ver="1.0.1";const $e=new Us,js=new ai(new M(0,0,1),0),Ui=new M,df=new rt,vi=new Lt,U1=new j(-1,.9),F1=new j(1,.9),B1=new j(1,-1),xi=new M;class qc extends Vc{constructor(t,e,i={}){super(e,i),d(this,"isBlankMap",!0),d(this,"MERCATOR_LENGTH",200375083427892e-7),d(this,"projectionCoordsName","_web_mercator"),d(this,"origin",[0,0]),d(this,"center",[0,0]),d(this,"zoom",0),d(this,"pitch",0),d(this,"heading",0),d(this,"bounds",[[-this.MERCATOR_LENGTH,-this.MERCATOR_LENGTH],[this.MERCATOR_LENGTH,this.MERCATOR_LENGTH]]),d(this,"near",.1),d(this,"_far",38e3),d(this,"fov",35),d(this,"handleViewChange",()=>{this.onViewChanged&&this.onViewChanged()}),d(this,"handleMapResize",()=>{this.control&&this.control.handleResize(this.getResolution()),this.onResolutionChanged&&this.onResolutionChanged(this.getResolution())}),d(this,"handleEventClick",n=>{const r=this._engine,a=r.event,o=r.rendering.canvas.getBoundingClientRect(),l=n.clientX-o.left,h=n.clientY-o.top,c=l/o.width*2-1,u=1-2*h/o.height;$e.setFromCamera({x:c,y:u},r.rendering.camera),$e.ray.intersectPlane(js,Ui);const p=[l,h],m=[Ui.x,Ui.y,Ui.z],f=this.normalizeEarthPointArr(m);n.button===2?a._handleRightClick({pixel:p,point:f,position:m,event:n}):a._handleClick({pixel:p,point:f,position:m,event:n})}),d(this,"handleEventDblClick",n=>{const r=this._engine,a=r.event,o=r.rendering.canvas.getBoundingClientRect(),l=n.clientX-o.left,h=n.clientY-o.top,c=l/o.width*2-1,u=1-2*h/o.height;$e.setFromCamera({x:c,y:u},r.rendering.camera),$e.ray.intersectPlane(js,Ui);const p=[l,h],m=[Ui.x,Ui.y,Ui.z],f=this.normalizeEarthPointArr(m);n.button===2?a._handleRightDblClick({pixel:p,point:f,position:m,event:n}):a._handleDblClick({pixel:p,point:f,position:m,event:n})}),d(this,"handleEventMouseMove",n=>{this._engine.event.requestMousemoveRaycast({pixel:this._getPixelFromEvent(n),event:n})}),d(this,"_getPixelFromEvent",n=>{const r=this._engine.rendering.canvas.getBoundingClientRect();return[n.clientX-r.left,n.clientY-r.top]}),this._engine=t,this.domContainer=e}afterInit(){this.domContainer.appendChild(this.canvas),this.camera.matrixAutoUpdate=!1,this.handleMapResize(),uf(this.domContainer,this.handleMapResize),this.initControl()}initControl(){this.control=new D1(this),this.control.onEventClick=this.handleEventClick,this.control.onEventDblClick=this.handleEventDblClick,this.control.onEventMouseMove=this.handleEventMouseMove}getContainerSize(){return[this.domContainer.clientWidth,this.domContainer.clientHeight]}getResolution(){return new j(this.domContainer.clientWidth,this.domContainer.clientHeight)}getCenter(){return this.normalizeEarthPointArr(this.center)}getZoom(){return this.zoom}getPitch(){return this.pitch}getZoomUnitsByZoom(t){return this.MERCATOR_LENGTH/128/Math.pow(2,t)}getZoomByZoomUnits(t){return Math.log2(this.MERCATOR_LENGTH/128/t)}getZoomUnits(){return this.getZoomUnitsByZoom(this.zoom)}getHeading(){return this.heading}enableControl(){this.control.enabled=!0}disableControl(){this.control.enabled=!1}setCameraMatrix(){this.handleViewChange()}updateCamera(){this.computeMapCameraMatrix(this.camera,this.center,this.zoom,this.pitch,this.heading)}computeMapCameraMatrix(t,e,i,n,r){const[a,o]=this.getContainerSize();let l=this.zoomUnits=this.getZoomUnitsByZoom(i);if(a*l>this.bounds[1][0]-this.bounds[0][0]){let u=(this.bounds[1][0]-this.bounds[0][0])/a;l=this.zoomUnits=u,this.zoom=this.getZoomByZoomUnits(u)}if(o*l>this.bounds[1][1]-this.bounds[0][1]){let u=(this.bounds[1][1]-this.bounds[0][1])/o;l=this.zoomUnits=u,this.zoom=this.getZoomByZoomUnits(u)}e[0]-a/2*l<this.bounds[0][0]&&(e[0]=this.bounds[0][0]+a/2*l),e[0]+a/2*l>this.bounds[1][0]&&(e[0]=this.bounds[1][0]-a/2*l),e[1]-o/2*l<this.bounds[0][1]&&(e[1]=this.bounds[0][1]+o/2*l),e[1]+o/2*l>this.bounds[1][1]&&(e[1]=this.bounds[1][1]-o/2*l),this.center=e;const h=o/2/Math.tan(this.fov/2*Math.PI/180)*l;this.cameraDistance=h,t.position.set(0,0,0),t.quaternion.set(0,0,0,1),t.up.set(0,0,1),t.translateX(e[0]),t.translateY(e[1]),e[2]&&t.translateZ(e[2]),t.rotateOnAxis(new M(0,0,1),r*Math.PI/180),t.rotateOnAxis(new M(1,0,0),n*Math.PI/180),t.translateZ(h),t.updateMatrix(),t.updateMatrixWorld(),t.aspect=a/o;let c=l;c<1&&(c=1),t.near=this.near,t.far=this._far*c,t.updateProjectionMatrix()}setCenter(t){const e=this.normalizeMapPoint(t);e&&(this.center=e),this.setCameraMatrix()}setProjectionCenter(t){const e=this.normalizeEarthPointArr(t);this.setCenter(e)}setZoom(t){isNaN(t)||(this.zoom=t),this.setCameraMatrix()}zoomIn(){this.setZoom(this.zoom+1)}zoomOut(){this.setZoom(this.zoom-1)}setHeading(t){this.heading=t,this.setCameraMatrix()}setPitch(t){this.pitch=t,this.setCameraMatrix()}lookAt(t,e={}){let i=[];t.isVector3?t.toArray(i):i=t;const n=this.normalizeMapPoint(i);n&&(this.center=n),e.heading!==void 0&&(this.heading=e.heading),e.pitch!==void 0&&(this.pitch=e.pitch),e.zoom!==void 0&&(this.zoom=e.zoom),this.setCameraMatrix()}setBounds(t){this.bounds=[this.projectPointArr(t[0]),this.projectPointArr(t[1])]}getBoundsOld(){const t=[],e=new j,i=re.mapLinear(re.clamp(Math.abs(90-this.pitch),0,50),0,50,.1,1);e.set(-1,-1*i),$e.setFromCamera(e,this.camera),$e.ray.intersectPlane(js,xi);const n=xi.x,r=xi.y;e.set(-1,1*i),$e.setFromCamera(U1,this.camera),$e.ray.intersectPlane(js,xi);const a=xi.x,o=xi.y;e.set(1,1*i),$e.setFromCamera(F1,this.camera),$e.ray.intersectPlane(js,xi);const l=xi.x,h=xi.y;e.set(1,-1*i),$e.setFromCamera(B1,this.camera),$e.ray.intersectPlane(js,xi);const c=xi.x,u=xi.y;t[0]=Math.min(n,a,l,c),t[1]=Math.min(r,o,h,u),t[2]=Math.max(n,a,l,c),t[3]=Math.max(r,o,h,u);const p=this.normalizeEarthPointArr([t[0],t[1]]),m=this.normalizeEarthPointArr([t[2],t[3]]);return new He(new M(p[0],p[1],0),new M(m[0],m[1],0))}getBoundsLarger(){const t=this.camera;df.multiplyMatrices(t.matrixWorld,t.projectionMatrixInverse);let e=1/0,i=1/0,n=-1/0,r=-1/0;[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]].forEach(l=>{vi.set(l[0],l[1],l[2],1),vi.applyMatrix4(df),vi.divideScalar(vi.w),vi.x<e&&(e=vi.x),vi.x>n&&(n=vi.x),vi.y<i&&(i=vi.y),vi.y>r&&(r=vi.y)});const a=this.normalizeEarthPointArr([e,i]),o=this.normalizeEarthPointArr([n,r]);return new He(new M(a[0],a[1],0),new M(o[0],o[1],0))}getBounds(){$e.setFromCamera(new j,this.camera),$e.ray.intersectPlane(js,Ui);const t=Ui.clone(),e=this.camera.position.distanceTo(Ui),i=new M(2*e,2*e),n=new M,r=new M;return n.subVectors(t,i),r.addVectors(t,i),new He(n,r)}normalizeMapPoint(t){return this.normalizeProjectionPointArr(t)}normalizeProjectionPointArr(t){let e=this.parsePointToArr(t),i=Wr(e);return i[0]-=this.origin[0],i[1]-=this.origin[1],e[2]!==void 0&&(i[2]=e[2]),i}normalizeEarthPointArr(t){let e=this.parsePointToArr(t);e[0]+=this.origin[0],e[1]+=this.origin[1];let i=zc(e);return e[2]!==void 0&&(i[2]=e[2]),i}projectPointArr(t,e){if(!t)return e;let i=null;return i=t[0]>180||t[1]>90?[t[0],t[1]]:Wr(t),t[2]!==void 0&&(i[2]=t[2]),i[0]-=this.origin[0],i[1]-=this.origin[1],i}updateView(){this.setCameraMatrix()}getCameraDistance(){return this.cameraDistance}getProjectionCenter(){return[this.center[0],this.center[1]]}dispose(){Xc(this.domContainer),this.domContainer.removeChild(this.canvas),this._engine.event,this.control.dispose(),super.dispose()}get far(){return this._far}set far(t){this._far=t}}d(qc,"EARTH_RADIUS",637e4);const Kr=0,pf=1,mf=2,os=new j,Qr=new Us,ff=new ai(new M(0,0,1),0),Cn=new M,Ja=new ye;new ye,Ja.fov=35;class V1{constructor(t){d(this,"map"),d(this,"currentAction"),d(this,"startX"),d(this,"startY"),d(this,"startCenterX"),d(this,"startCenterY"),d(this,"startPitch"),d(this,"startHeading"),d(this,"startZoom"),d(this,"startZoomUnits"),d(this,"startAtTop"),d(this,"mapWidth"),d(this,"mapHeight"),d(this,"startCamera",new ye),d(this,"startCenter",new M),d(this,"startNdc",new j),d(this,"startPoint",new M),d(this,"startScaleX",1),d(this,"startScaleY",1),d(this,"startBoundX"),d(this,"startBoundY"),d(this,"_enabled",!1),d(this,"minPitch",0),d(this,"maxPitch",89),d(this,"zoomSpeed",.005),d(this,"headingSpeed",.4),d(this,"pitchSpeed",.3),d(this,"doubleClickTimer",null),d(this,"clickInterval",200),d(this,"_rotationMode",1),d(this,"init",()=>{const e=this.map.domContainer;e.addEventListener(vt.DOWN,this.handleMouseDown),e.addEventListener("wheel",this.handleWheel),e.addEventListener("contextmenu",this.handleContextMenu),e.addEventListener(vt.MOVE,this.handleMouseMove),this.initCursorAnchor()}),d(this,"initCursorAnchor",()=>{const e=this.cursorAnchor=document.createElement("div");e.style.position="absolute",e.style.width="40px",e.style.height="40px",e.style.backgroundColor="rgba(255, 255, 255, 0.5)",e.style.zIndex=100,e.style.pointerEvents="none",e.style.display="none",this.map.domContainer.appendChild(e)}),d(this,"showCursorAnchor",(e,i)=>{this._rotationMode!==1&&(this.cursorAnchor.style.left=e-20+"px",this.cursorAnchor.style.top=i-20+"px",this.cursorAnchor.style.display="block")}),d(this,"hideCursorAnchor",()=>{this.cursorAnchor.style.display="none"}),d(this,"handleResize",e=>{const[i,n]=this.map.getContainerSize();this.mapWidth=i,this.mapHeight=n;const r=this.map.domContainer.getBoundingClientRect();this.startBoundX=r.left,this.startBoundY=r.top,this.startScaleX=r.width/i,this.startScaleY=r.height/n}),d(this,"handleMouseMove",e=>{this.currentAction===Kr&&this.onEventMouseMove&&this.onEventMouseMove(e)}),d(this,"handleMouseDown",e=>{const i=this.map;let n=this.mapWidth,r=this.mapHeight;const a=this.map.domContainer.getBoundingClientRect();this.startBoundX=a.left,this.startBoundY=a.top,this.startScaleX=a.width/n,this.startScaleY=a.height/r;let o=e.clientX,l=e.clientY;e.type==="touchstart"&&(o=e.changedTouches[0].clientX,l=e.changedTouches[0].clientY);const h=(o-this.startBoundX)/this.startScaleX,c=(l-this.startBoundY)/this.startScaleY,u=new j(h/n*2-1,1-2*c/r);if(e.button===0){const p=i._getFirstIntersectionPoint(u);this.startCamera.copy(i.camera),this.startCamera.updateMatrixWorld(),ff.constant=-p.z,this.startPoint.copy(p),this.currentAction=pf}else if(e.button===2){if(this._rotationMode===1){const p=i.getProjectionCenter();this.startPoint.set(p[0],p[1],p[2]);const m=i.decomposeRotation();this.startHeading=m.heading,this.startPitch=m.pitch}else{const p=i._getFirstIntersectionPoint(u);this.startCamera.copy(i.camera),this.startCamera.updateMatrixWorld();const m=new M;m.subVectors(p,this.startCamera.position),m.normalize(),this.startPoint.copy(p);const f=i.decomposeRotationFromDirection(m);this.startHeading=f.heading,this.startPitch=f.pitch}this.startDistance=i.camera.position.distanceTo(this.startPoint),this.currentAction=mf,this.showCursorAnchor(h,c)}else this.currentAction=Kr;this.currentAction!==Kr&&(this.startX=h,this.startY=c,this.startAtTop=c<r/2,document.addEventListener(vt.MOVE,this.handleMouseDragging),document.addEventListener(vt.UP,this.handleMouseUp))}),d(this,"handleMouseDragging",e=>{if(this.currentAction===Kr)return;this.hasMoved=!0;let i=e.clientX,n=e.clientY;e.type==="touchmove"&&(i=e.changedTouches[0].clientX,n=e.changedTouches[0].clientY);const r=this.currentPixelX=(i-this.startBoundX)/this.startScaleX,a=this.currentPixelY=(n-this.startBoundY)/this.startScaleY;this.currentAction===pf?(this.map.domContainer.style.cursor="grabbing",this.handlePan(r,a)):this.currentAction===mf&&(this.map.domContainer.style.cursor="grabbing",this.handleRotate(r,a))}),d(this,"handleMouseUp",e=>{this.currentAction=Kr,this.map.domContainer.style.cursor="default",this.hideCursorAnchor(),document.removeEventListener(vt.MOVE,this.handleMouseDragging),document.removeEventListener(vt.UP,this.handleMouseUp),e&&this.onEventClick&&(this.hasMoved||this.onEventClick(e)),e&&this.onEventDblClick&&(!this.hasMoved&&this.waitSecondClick?(this.onEventDblClick(e),this.clearDoubleClickTimer()):this.waitSecondClick=!0),clearTimeout(this.doubleClickTimer),this.doubleClickTimer=setTimeout(()=>{this.clearDoubleClickTimer()},this.clickInterval),this.hasMoved=!1}),d(this,"clearDoubleClickTimer",()=>{this.doubleClickTimer&&clearTimeout(this.doubleClickTimer),this.waitSecondClick=!1,this.doubleClickTimer=null}),d(this,"handleContextMenu",e=>{e.preventDefault()}),d(this,"handleWheel",e=>{e.preventDefault(),e.stopPropagation();const i=(e.clientX-this.startBoundX)/this.startScaleX,n=(e.clientY-this.startBoundY)/this.startScaleY;this.handleZoom({deltaX:e.deltaX,deltaY:e.deltaY,pixelX:i,pixelY:n})}),d(this,"handlePan",(e,i)=>{const n=this.map;this.getNdc(e,i,os),this.ndcToPoint(os,this.startCamera,Cn),Cn.distanceTo(n.camera.position)>.8*n.camera.far?this.handleMouseUp():(Cn.sub(this.startPoint),Cn.subVectors(this.startCamera.position,Cn),n.camera.position.copy(Cn),n.center=[Cn.x,Cn.y],n.updateView())}),d(this,"handleRotate",(e,i)=>{const n=this.map,r=n.camera;let a=e-this.startX;const o=i-this.startY;this.startAtTop||(a*=-1);let l=this.startHeading+a*this.headingSpeed;l=this.makeHeadingSafe(l);let h=this.startPitch+o*this.pitchSpeed;if(h=this.makePitchSafe(h),this._rotationMode===1)n._cameraLookAt(r,this.startPoint,{heading:l,pitch:h,range:this.startDistance});else{n._cameraLookAt(Ja,this.startPoint,{heading:l,pitch:h,range:.2}),this.getNdc(this.startX,this.startY,os),Qr.setFromCamera(os,Ja);const c=Qr.ray.direction.clone();os.set(0,0),Qr.setFromCamera(os,Ja);const u=Qr.ray.direction.clone();c.angleTo(u);const p=new M;p.copy(c),p.normalize(),p.multiplyScalar(this.startDistance),r.position.copy(Cn.copy(this.startPoint).sub(p)),r.quaternion.copy(Ja.quaternion)}n.pitch=h,n.heading=l,n.updateView()}),d(this,"handleZoom",e=>{const i=this.map,n=i.camera,r=re.clamp(e.deltaY*this.zoomSpeed*-1,-.5,.5);this.getNdc(e.pixelX,e.pixelY,os);const a=i._getFirstIntersectionPoint(os),o=n.position.distanceTo(a);if(o>.8*n.far)return void this.handleMouseUp();let l=r*re.clamp(o,.5,1e7);l+.2>o?(l=o-.2,i.range=.2):i.range=o-l;const h=new M;h.subVectors(a,n.position),h.normalize();const c=new M;c.copy(h).multiplyScalar(l).add(n.position),n.position.copy(c),i.center=[c.x,c.y],i.updateView()}),d(this,"makeHeadingSafe",e=>((e%=360)<0&&(e+=360),e)),d(this,"makePitchSafe",e=>e<this.minPitch?this.minPitch:e>this.maxPitch?this.maxPitch:e),d(this,"dispose",()=>{const e=this.map.domContainer;e.removeEventListener(vt.DOWN,this.handleMouseDown),e.removeEventListener("wheel",this.handleWheel),e.removeEventListener("contextmenu",this.handleContextMenu),document.removeEventListener(vt.MOVE,this.handleMouseDragging),document.removeEventListener(vt.UP,this.handleMouseUp),e.removeEventListener(vt.MOVE,this.handleMouseMove),this.clearDoubleClickTimer(),this.cursorAnchor.remove()}),this.map=t,this.enabled=!0,this.currentAction=Kr}set enabled(t){t!==this._enabled&&(t?this.init():this.dispose(),this._enabled=t)}ndcToPoint(t,e,i){Qr.setFromCamera(t,e),Qr.ray.intersectPlane(ff,i)}getNdc(t,e,i){i.x=t/this.mapWidth*2-1,i.y=1-e/this.mapHeight*2}}const H1=new M(0,0,-1),j1=new M(0,1,0),Gs=new Us;Gs.mouse=new j;const gf=new ai(new M(0,0,1),0),En=new M;new rt;class Yc extends qc{constructor(){super(...arguments),d(this,"isBlankMap3D",!0),d(this,"_viewStateDirty",!0),d(this,"range",.2),d(this,"_getFirstIntersectionPoint",t=>{const e=this._engine;Gs.setFromCamera(t,e.camera),Gs.mouse.copy(t);const i=Gs.intersectObjects(e.rendering.objectsScene.children,!0);let n=null;for(let r=0,a=i.length;r<a;r++)if(!i[r].object.isPoints&&!i[r].object.collisionDisabled){n=i[r];break}return n!==null&&n.point?n.point:(Gs.ray.intersectPlane(gf,En),En)})}initControl(){this.control=new V1(this),this.control.onEventClick=this.handleEventClick,this.control.onEventDblClick=this.handleEventDblClick,this.control.onEventMouseMove=this.handleEventMouseMove}updateView(){this.handleViewChange()}getCenter(){return this.normalizeEarthPointArr(this.getProjectionCenter())}getProjectionCenter(){const t=new j,e=this._getFirstIntersectionPoint(t);return[e.x,e.y,e.z]}getPitch(){return this.pitch}getHeading(){return this.heading}getCalcRange(){const t=this.getProjectionCenter();return this.camera.position.distanceTo(En.set(t[0],t[1],t[2]))}getZoom(){return this.getZoomByZoomUnits(this.getZoomUnits())}getZoomUnits(){const[t,e]=this.getContainerSize();return this.getCameraDistance()*Math.tan(re.degToRad(this.fov/2))*2/e}getCameraDistance(){return Gs.setFromCamera(new j,this.camera),Gs.ray.intersectPlane(gf,En),this.camera.position.distanceTo(En)}setCenter(t){this.setProjectionCenter(this.normalizeProjectionPointArr(t))}setProjectionCenter(t){const e=this.decomposeRotation();this._cameraLookAt(this.camera,t,{...e,height:this.camera.position.z}),this.center=t,this.updateView()}setZoom(t){const e=this.decomposeRotation(),i=this.getProjectionCenter(),n=this.getZoomUnitsByZoom(t),[r,a]=this.getContainerSize(),o=a/2*n/Math.tan(re.degToRad(this.fov/2));this._cameraLookAt(this.camera,i,{...e,range:.1*o,height:o}),this.zoom=t,this.updateView()}setPitch(t){const e=this.decomposeRotation(),i=this.getProjectionCenter(),n=this.camera.position.distanceTo(En.set(i[0],i[1],i[2]));this._cameraLookAt(this.camera,i,{heading:e.heading,pitch:t,range:n}),this.pitch=t,this.updateView()}setHeading(t){const e=this.decomposeRotation(),i=this.getProjectionCenter(),n=this.camera.position.distanceTo(En.set(i[0],i[1],i[2]));this._cameraLookAt(this.camera,i,{heading:t,pitch:e.pitch,range:n}),this.heading=t,this.updateView()}setRange(t){const e=this.decomposeRotation(),i=this.getProjectionCenter();this._cameraLookAt(this.camera,i,{...e,range:t}),this.range=t,this.updateView()}zoomIn(){const t=this.decomposeRotation(),e=this.getProjectionCenter();let i=this.camera.position.distanceTo(En.set(e[0],e[1],e[2])),n=.5*re.clamp(i,.5,1e7);n+.2>i?(n=i-.2,i=.2):i-=n,this._cameraLookAt(this.camera,e,{...t,range:i}),this.range=i,this.updateView()}zoomOut(){const t=this.decomposeRotation(),e=this.getProjectionCenter();let i=this.camera.position.distanceTo(En.set(e[0],e[1],e[2])),n=-.5*re.clamp(i,.5,1e7);n+.2>i?(n=i-.2,i=.2):i-=n,this._cameraLookAt(this.camera,e,{...t,range:i}),this.range=i,this.updateView()}lookAt(t,e={}){let i=[];t.isVector3?t.toArray(i):i=t;let n=this.normalizeProjectionPointArr(i);const{heading:r,pitch:a,range:o}=e;isNaN(r)||(this.heading=r),isNaN(a)||(this.pitch=a),isNaN(o)||(this.range=o),this._cameraLookAt(this.camera,n,e)}_cameraLookAt(t,e,i){const{heading:n=this.heading,pitch:r=this.pitch,range:a,height:o}=i,l=new Ht;l.setFromAxisAngle(new M(0,0,1),n*Math.PI/180);const h=new Ht;h.setFromAxisAngle(new M(1,0,0),r*Math.PI/180);const c=new Ht;c.multiplyQuaternions(l,h);const u=new M(0,0,-1);u.applyQuaternion(c),u.negate();const p=new M;Array.isArray(e)?p.set(e[0],e[1],e[2]||0):e.isVector3&&p.copy(e);const m=new M;isNaN(a)||(m.copy(u),m.multiplyScalar(a),p.add(m)),t.position.copy(p),t.quaternion.copy(c),t.updateMatrix(),t.updateMatrixWorld()}offsetFromHeadingPitchRange(t=0,e=0,i=0){const n=new Ht;n.setFromAxisAngle(new M(0,0,1),t*Math.PI/180);const r=new Ht;r.setFromAxisAngle(new M(1,0,0),e*Math.PI/180);const a=new Ht;a.multiplyQuaternions(n,r);const o=new M(0,0,-1);o.applyQuaternion(a),o.negate();const l=new M;return l.copy(o).multiplyScalar(i),l}decomposeRotation(){const t=this.camera.quaternion,e=H1.clone(),i=j1.clone();return e.applyQuaternion(t),e.clampScalar(-1,1),i.applyQuaternion(t),this.decomposeRotationFromDirection(e,i)}decomposeRotationFromDirection(t,e){const i=180-re.radToDeg(Math.acos(t.z));let n=re.radToDeg(Math.atan2(t.y,t.x));return t.x===0&&t.y===0&&(n=re.radToDeg(Math.atan2(e.y,e.x))),n=(n-90)%360,{heading:n,pitch:i}}updateCamera(){const t=this.camera;t.updateMatrix(),t.updateMatrixWorld();const[e,i]=this.getContainerSize();t.aspect=e/i,t.near=this.near;let n=this.getZoomUnits();n<.5&&(n=.5),t.far=this._far*n*2,t.updateProjectionMatrix()}}class G1 extends Yc{constructor(){super(...arguments),d(this,"projectionCoordsName","_bmap_mercator")}normalizeMapPoint(t){return this.normalizeEarthPointArr(t)||[0,0]}normalizeProjectionPointArr(t){const e=this.parsePointToArr(t);if(e&&e[0]<180&&e[1]<90){const i=Xe.convertLL2MC({lng:e[0],lat:e[1]});e[0]=i.lng,e[1]=i.lat}return e}normalizeEarthPointArr(t){const e=this.parsePointToArr(t);if(e&&(e[0]>180||e[1]>90)){const i=Xe.convertMC2LL({lng:e[0],lat:e[1]});e[0]=i.lng,e[1]=i.lat}return e}projectPointArr(t){let e=[];if(t[0]>180||t[1]>90)e[0]=t[0],e[1]=t[1];else{const i=Xe.convertLL2MC({lng:t[0],lat:t[1]});e[0]=i.lng,e[1]=i.lat}return t[2]!==void 0&&(e[2]=t[2]),e}}var Pl=.9996,Ji=.00669438,Zc=Math.pow(Ji,2),Rl=Math.pow(Ji,3),$r=Ji/(1-Ji),_f=Math.sqrt(1-Ji),ta=(1-_f)/(1+_f),W1=Math.pow(ta,2),vf=Math.pow(ta,3),xf=Math.pow(ta,4),yf=Math.pow(ta,5),bf=1-Ji/4-3*Zc/64-5*Rl/256,X1=3*Ji/8+3*Zc/32+45*Rl/1024,q1=15*Zc/256+45*Rl/1024,Y1=35*Rl/3072,Z1=1.5*ta-27/32*vf+269/512*yf,J1=21/16*W1-55/32*xf,K1=151/96*vf-417/128*yf,Q1=1097/512*xf,Dl=6378137;function Mf(s){return 6*(s-1)-180+3}function wf(s){return s/Math.PI*180}function Jc(s){return s*Math.PI/180}class $1 extends Yc{constructor(t,e,i={}){super(t,e,i),d(this,"projectionCoordsName","_utm"),this.zone=i.utmZone||50}normalizeMapPoint(t){return this.normalizeEarthPointArr(t)||[0,0]}normalizeProjectionPointArr(t){const e=this.parsePointToArr(t);if(e&&e[0]<180&&e[1]<90){const i=function(n,r){const a=n[0],o=n[1];if(o>84||o<-80)throw new RangeError("latitude out of range (must be between 80 deg S and 84 deg N)");if(a>180||a<-180)throw new RangeError("longitude out of range (must be between 180 deg W and 180 deg E)");var l=Jc(o),h=Math.sin(l),c=Math.cos(l),u=Math.tan(l),p=Math.pow(u,2),m=Math.pow(u,4),f=Jc(a),g=Jc(Mf(r)),_=Dl/Math.sqrt(1-Ji*h*h),v=$r*c*c,x=c*(f-g),y=Math.pow(x,2),b=Math.pow(x,3),S=Math.pow(x,4),w=Math.pow(x,5),C=Math.pow(x,6),L=Dl*(bf*l-X1*Math.sin(2*l)+q1*Math.sin(4*l)-Y1*Math.sin(6*l)),T=Pl*(L+_*u*(y/2+S/24*(5-p+9*v+4*v*v)+C/720*(61-58*p+m+600*v-330*$r)));return o<0&&(T+=1e7),[Pl*_*(x+b/6*(1-p+v)+w/120*(5-18*p+m+72*v-58*$r))+5e5,T]}(e,this.zone);e[0]=i[0],e[1]=i[1]}return e}normalizeEarthPointArr(t){const e=this.parsePointToArr(t);if(e){const i=function(n,r,a){let o=n[0],l=n[1];if(r<1||r>60)throw new RangeError("zone number out of range (must be between 1 and 60)");var h=o-5e5,c=l/Pl/(Dl*bf),u=c+Z1*Math.sin(2*c)+J1*Math.sin(4*c)+K1*Math.sin(6*c)+Q1*Math.sin(8*c),p=Math.sin(u),m=Math.pow(p,2),f=Math.cos(u),g=Math.tan(u),_=Math.pow(g,2),v=Math.pow(g,4),x=1-Ji*m,y=Math.sqrt(x),b=(1-Ji)/x,S=ta*f*f,w=S*S,C=h/(Dl/y*Pl),L=Math.pow(C,2),T=Math.pow(C,3),E=Math.pow(C,4),I=Math.pow(C,5),z=Math.pow(C,6),B=u-g/b*(L/2-E/24*(5+3*_+10*S-4*w-9*$r))+z/720*(61+90*_+298*S+45*v-252*$r-3*w);return[wf((C-T/6*(1+2*_+S)+I/120*(5-2*S+28*_-3*w+8*$r+24*v))/f)+Mf(r),wf(B)]}(e,this.zone);e[0]=i[0],e[1]=i[1]}return e}projectPointArr(t){return this.normalizeProjectionPointArr(t)}}class tb extends Vc{constructor(t,e,i){super(e,i),d(this,"near",.1),d(this,"_far",4e3),d(this,"fov",35),d(this,"projectionCoordsName","_bmap_mercator"),d(this,"handleMapUpdate",()=>{this.onViewChanged&&this.onViewChanged()}),d(this,"handleMapResize",()=>{this.onResolutionChanged&&this.onResolutionChanged(this.getResolution())}),d(this,"handleEventClick",n=>{const r=this._engine.event,a=[n.pixel.x,n.pixel.y],o=[n.latlng.lng,n.latlng.lat],l=[n.point.lng,n.point.lat];r._handleClick({pixel:a,point:o,position:l,event:n})}),d(this,"handleEventRightClick",n=>{const r=this._engine.event,a=[n.pixel.x,n.pixel.y],o=[n.latlng.lng,n.latlng.lat],l=[n.point.lng,n.point.lat];r._handleRightClick({pixel:a,point:o,position:l,event:n})}),d(this,"handleEventDblClick",n=>{const r=this._engine.event,a=[n.pixel.x,n.pixel.y],o=[n.latlng.lng,n.latlng.lat],l=[n.point.lng,n.point.lat];r._handleDblClick({pixel:a,point:o,position:l,event:n})}),d(this,"handleEventRightDblClick",n=>{const r=this._engine.event,a=[n.pixel.x,n.pixel.y],o=[n.latlng.lng,n.latlng.lat],l=[n.point.lng,n.point.lat];r._handleRightDblClick({pixel:a,point:o,position:l,event:n})}),this._engine=t,this.map=e}getContainerSize(){const t=this.map.getSize();return[t.width,t.height]}getResolution(){const t=this.map.getSize();return new j(t.width,t.height)}afterInit(){const t=this.map;this.canvas.style.zIndex="3",t.getContainer().appendChild(this.canvas),t.addEventListener("update",this.handleMapUpdate),t.addEventListener("resize",this.handleMapResize),t.addEventListener("click",this.handleEventClick),t.addEventListener("rightclick",this.handleEventRightClick),t.addEventListener("dblclick",this.handleEventDblClick),t.addEventListener("rightdblclick",this.handleEventRightDblClick),this.handleMapResize()}getCenter(){const t=this.map.getCenter();return[t.lng,t.lat]}getZoom(){return this.map.getZoom()}getZoomUnits(){return this.map.getZoomUnits()}getZoomByZoomUnits(t){return window.BMAPGL_84?Math.log2(this.MERCATOR_LENGTH/128/t):18-Math.log2(t)}getZoomUnitsByZoom(t){return this.map.getZoomUnits(t)}getHeading(){return this.map.getHeading()}getPitch(){return this.map.getTilt()}setCenter(t){this.map.setCenter(this.normalizeMapPoint(t))}setProjectionCenter(t){const e=this.normalizeEarthPointArr(t);this.setCenter(e)}setZoom(t){this.map.setZoom(t)}setPitch(t){this.map.setTilt(t)}setHeading(t){this.map.setHeading(t)}setBounds(t){let e=[this.projectPointArr(t[0]),this.projectPointArr(t[1])];this.map.setBounds(new BMapGL.Point(e[0][0],e[0][1]),new BMapGL.Point(e[1][0],e[1][1]))}getBounds(){this.map.getBounds()}enableControl(){this.map.enableDragging()}disableControl(){this.map.disableDragging()}zoomIn(){this.map.zoomIn()}zoomOut(){this.map.zoomOut()}updateCamera(){this.updateMatrixWorld(),this.updateProjectionMatrix()}updateMatrixWorld(){const t=this.map,e=this.camera,i=t.getCenterIn(),n=[i.lng,i.lat],r=t.getZoomUnits(),a=t.getTilt(),o=t.getHeading(),[l,h]=this.getContainerSize(),c=h/2/Math.tan(this.fov/2*Math.PI/180)*r;this.cameraDistance=c,e.position.set(0,0,0),e.quaternion.set(0,0,0,1),e.up.set(0,1,0),e.translateX(n[0]),e.translateY(n[1]),e.rotateOnAxis(new M(0,0,1),o*Math.PI/180),e.rotateOnAxis(new M(1,0,0),a*Math.PI/180),e.translateZ(c),e.updateMatrix(),e.updateMatrixWorld()}updateProjectionMatrix(){const t=this.camera,[e,i]=this.getContainerSize(),n=this.map.getZoomUnits();t.aspect=e/i,t.near=.1,t.far=this._far*n,t.far<1e3&&(t.far=1e3),t.updateProjectionMatrix()}normalizeMapPoint(t){const e=this.normalizeEarthPointArr(t)||[0,0];return new BMapGL.Point(e[0],e[1],e[2])}normalizeProjectionPointArr(t){const e=this.parsePointToArr(t);return e&&e[0]<180&&e[1]<90?this.map.lnglatToMercator(e[0],e[1]):e}normalizeEarthPointArr(t){const e=this.parsePointToArr(t);if(e&&(e[0]>180||e[1]>90)){const i=this.map.mercatorToLnglat(e[0],e[1]);return e[2]!==void 0&&(i[2]=e[2]),i}return e}projectPointArr(t){let e=[];return t[0]>180||t[1]>90?(e[0]=t[0],e[1]=t[1]):e=this.map.lnglatToMercator(t[0],t[1]),t[2]!==void 0&&(e[2]=t[2]),e}getCameraDistance(){return this.cameraDistance}getProjectionCenter(){const t=this.map.getCenterIn();return[t.lng,t.lat]}dispose(){const t=this.map;t.getContainer().removeChild(this.canvas),t.removeEventListener("update",this.handleMapUpdate),t.removeEventListener("resize",this.handleMapResize),t.removeEventListener("click",this.handleEventClick),super.dispose()}get far(){return this._far}set far(t){}}class Sf extends Vc{constructor(t,e,i){super(e,i),d(this,"MERCATOR_LENGTH",200375083427892e-7),d(this,"projectionCoordsName","_web_mercator"),d(this,"origin",[0,0]),d(this,"center",[0,0]),d(this,"pitch",0),d(this,"heading",0),d(this,"near",.1),d(this,"_far",8e3),d(this,"fov",35),d(this,"cameraDistance",1e3),d(this,"handleEventClick",n=>{const r=this._engine.event,a=[n.point.x,n.point.y],o=[n.lngLat.lng,n.lngLat.lat],l=this.normalizeProjectionPointArr(o);r._handleClick({pixel:a,point:o,position:l,event:n.originalEvent})}),d(this,"handleEventDblClick",n=>{const r=this._engine.event,a=[n.point.x,n.point.y],o=[n.lngLat.lng,n.lngLat.lat],l=this.normalizeProjectionPointArr(o);r._handleDblClick({pixel:a,point:o,position:l,event:n.originalEvent})}),d(this,"handleEventRightClick",n=>{const r=this._engine.event,a=[n.point.x,n.point.y],o=[n.lngLat.lng,n.lngLat.lat],l=this.normalizeProjectionPointArr(o);r._handleRightClick({pixel:a,point:o,position:l,event:n.originalEvent})}),d(this,"handleMapResize",()=>{this.onResolutionChanged&&this.onResolutionChanged(this.getResolution())}),this._engine=t,this.map=e,this.domContainer=e._container}afterInit(){this.canvas.style.pointerEvents="none",this.domContainer.appendChild(this.canvas);const t=this.map;t.on("render",e=>{this.onViewChanged&&this.onViewChanged()}),t.on("click",this.handleEventClick),t.on("contextmenu",this.handleEventRightClick),t.on("dblclick",this.handleEventDblClick),t.on("resize",()=>{this.handleMapResize()}),this.handleMapResize()}getContainerSize(){return[this.domContainer.clientWidth,this.domContainer.clientHeight]}getResolution(){return new j(this.domContainer.clientWidth,this.domContainer.clientHeight)}setCenter(t){this.map.setCenter(t)}setZoom(t){this.map.setZoom(t)}setHeading(t){this.map.setBearing(t)}setPitch(t){this.map.setPitch(t)}getCenter(){const t=this.map.getCenter();return[t.lng,t.lat]}getZoom(){return this.map.getZoom()}getZoomUnitsByZoom(t){return this.MERCATOR_LENGTH/256/Math.pow(2,t)}getZoomByZoomUnits(t){return Math.log2(this.MERCATOR_LENGTH/256/t)}getZoomUnits(){return this.getZoomUnitsByZoom(this.map.getZoom())}getPitch(){return this.map.getPitch()}getHeading(){return this.map.getBearing()}enableControl(){this.map.dragPan.enable(),this.map.dragRotate.enable()}disableControl(){this.map.dragPan.disable(),this.map.dragRotate.disable()}zoomIn(){this.setZoom(this.getZoom()+1)}zoomOut(){this.setZoom(this.getZoom()-1)}flyTo(t){}updateCamera(){this.updateMatrixWorld(),this.updateProjectionMatrix()}updateMatrixWorld(){this.map;const t=this.camera,e=this.getCenter(),i=this.getZoomUnits(),n=this.getPitch(),r=this.getHeading(),[a,o]=this.getContainerSize(),l=this.normalizeProjectionPointArr(e),h=o/2/Math.tan(this.fov/2*Math.PI/180)*i;this.cameraDistance=h,t.position.set(0,0,0),t.quaternion.set(0,0,0,1),t.up.set(0,1,0),t.translateX(l[0]),t.translateY(l[1]),t.rotateOnAxis(new M(0,0,-1),r*Math.PI/180),t.rotateOnAxis(new M(1,0,0),n*Math.PI/180),t.translateZ(h),t.updateMatrix()}updateProjectionMatrix(){const t=this.camera,e=this.getZoomUnits(),[i,n]=this.getContainerSize();t.aspect=i/n,t.fov=this.fov,t.near=this.near*e,t.far=this._far*e,t.updateProjectionMatrix()}normalizeMapPoint(t){return this.normalizeEarthPointArr(t)}normalizeProjectionPointArr(t){let e=this.parsePointToArr(t);return e=Wr(e),e[0]-=this.origin[0],e[1]-=this.origin[1],e}normalizeEarthPointArr(t){let e=this.parsePointToArr(t);e[0]+=this.origin[0],e[1]+=this.origin[1];let i=zc(e);return e[2]!==void 0&&(i[2]=e[2]),i}projectPointArr(t,e){if(!t)return e;let i=null;return i=t[0]>180||t[1]>90?[t[0],t[1]]:Wr(t),t[2]!==void 0&&(i[2]=t[2]),i[0]-=this.origin[0],i[1]-=this.origin[1],i}dispose(){Xc(this.domContainer),this.domContainer.removeChild(this.canvas),this._engine.event,super.dispose()}getProjectionCenter(){const t=this.map.getCenter();return this.normalizeProjectionPointArr(t)}getCameraDistance(){return this.cameraDistance}get far(){return this._far}set far(t){}}d(Sf,"EARTH_RADIUS",637e4);class eb{constructor(t,e={}){d(this,"_engine"),d(this,"_map"),d(this,"_container"),d(this,"_mapType"),d(this,"handleViewChange",()=>{this._engine.rendering.requestRender()}),d(this,"handleResolutionChange",r=>{this._engine.rendering.setResolution(r)}),this._engine=t;const i=t.container,n=e.coordType;if(i instanceof HTMLElement?n==="ecef"||(n==="bd09"?(this._map=new G1(t,i,e),this._container=i,this._mapType="blank_bd09"):n==="utm"?(this._map=new $1(t,i,e),this._container=i,this._mapType="blank_utm"):e.is3DControl?(this._map=new Yc(t,i,e),this._container=i,this._mapType="blank_3dcontrol"):(this._map=new qc(t,i,e),this._container=i,this._mapType="blank")):window.BMapGL&&i instanceof BMapGL.Map?(this._map=new tb(t,i,e),this._container=i.container,this._mapType="bmapgl"):i._mapId&&(this._map=new Sf(t,i,e),this._container=i._container,this._mapType="mapbox"),!this._map)throw new Error("map is invalid")}init(){this._map.init(),this._map.onViewChanged=this.handleViewChange,this._map.onResolutionChanged=this.handleResolutionChange}afterInit(){const t=this._engine,e=this._map;e.canvas=t.rendering.canvas,e.camera=t.rendering.camera,xt(this._container,`${te}-container`),e.afterInit()}setCenter(t){this._map.setCenter(t)}setZoom(t){this._map.setZoom(t)}setHeading(t){this._map.setHeading(t)}setPitch(t){this._map.setPitch(t)}setBounds(t){this._map.setBounds(t)}lookAt(t,e={}){this._map.lookAt(t,e)}getBoundingBox(){return this._map.getBounds()}getCenter(){return this._map.getCenter()}getZoom(){return this._map.getZoom()}getZoomUnits(){return this._map.getZoomUnits()}getZoomByZoomUnits(t){return this._map.getZoomByZoomUnits(t)}getZoomUnitsByZoom(t){return this._map.getZoomUnitsByZoom(t)}getHeading(){return this._map.getHeading()}getPitch(){return this._map.getPitch()}getProjectionCenter(){return this._map.getProjectionCenter()}getCameraDistance(){return this._map.getCameraDistance()}getResolution(){return this._map.getResolution()}projectPointArr(t){return this._map.projectPointArr(t)}unprojectPointArr(t){return this._map.normalizeEarthPointArr(t)}projectCoordinates(t){return this._map.projectCoordinates(t)}enableControl(){this._map.enableControl()}disableControl(){this._map.disableControl()}updateCamera(){this._map.updateCamera()}getScaleAt(t){return 1/Math.cos(Math.PI*t[1]/180)}zoomIn(){this._map.zoomIn()}zoomOut(){this._map.zoomOut()}zoomTo(t){let e=null;if(t.is3DTiles)e=t.getBounds();else if(t.isMesh){const h=t.geometry;e=h.boundingBox,e||(h.computeBoundingBox(),e=h.boundingBox),e=e.clone(),e.applyMatrix4(t.matrixWorld)}else t.boundingBox&&(e=t.boundingBox,e=e.clone(),e.applyMatrix4(t.matrixWorld));if(!e)return;const i=this.getResolution(),n=(e.max.x-e.min.x)/i.x,r=(e.max.y-e.min.y)/i.y,a=Math.max(n,r),o=this._map.getZoomByZoomUnits(a),l=[(e.max.x+e.min.x)/2,(e.max.y+e.min.y)/2,(e.max.z+e.min.z)/2];if(this._map.isBlankMap3D){let h=Math.max(e.max.x-e.min.x,e.max.y-e.min.y)/Math.tan(this.fov/2*Math.PI/180);this._map._cameraLookAt(this._map.camera,l,{range:h}),this._map.range=h}else this._map.setProjectionCenter(l),this._map.setZoom(o);this._engine.requestRender()}dispose(){this._map.dispose()}set onResolutionChanged(t){this._map.onResolutionChanged=t}get projectionCoordsName(){return this._map.projectionCoordsName}get map(){return this._map}get mapType(){return this._mapType}get container(){return this._container}get fov(){return this._map.fov}get near(){return this._map.near}get far(){return this._map.far}}class ib extends St{constructor(){super(),d(this,"_boxGeometry"),d(this,"_boxMesh"),this._boxMaterial=new ae({transparent:!0,color:16711680,opacity:.3})}attach(t){this._object=t;const e=t.geometry;e.boundingBox||e.computeBoundingBox(),this._boxGeometry&&this._boxGeometry.dispose();const i=e.boundingBox;if(this._boxGeometry=new oe(i.max.x-i.min.x,i.max.y-i.min.y,i.max.z-i.min.z),this._boxMesh)this._boxMesh.geometry=this._boxGeometry;else{const n=this._boxMesh=new lt(this._boxGeometry,this._boxMaterial);this.add(n)}}detach(){this._object=null,this.remove(this._boxMesh),this._boxMesh=null}onBeforeScenePrepareRender(){if(this._object){this._object.updateMatrixWorld();const t=this._boxMesh;this._object.matrixWorld.decompose(t.position,t.rotation,t.scale)}}}const Ws=new Us,ti=new M,ls=new M,he=new Ht,Tf={X:new M(1,0,0),Y:new M(0,1,0),Z:new M(0,0,1)},Kc={type:"change"},Cf={type:"mouseDown"},Ef={type:"mouseUp",mode:null},Af={type:"objectChange"};class Pf extends St{constructor(t,e){super(),d(this,"_cameraScale"),d(this,"_endNorm"),d(this,"_gizmo"),d(this,"_getPointer"),d(this,"_onPointerDown"),d(this,"_onPointerHover"),d(this,"_onPointerMove"),d(this,"_onPointerUp"),d(this,"_parentPosition"),d(this,"_parentQuaternion"),d(this,"_parentQuaternionInv"),d(this,"_parentScale"),d(this,"_plane"),d(this,"_positionStart"),d(this,"_quaternionStart"),d(this,"_scaleStart"),d(this,"_startNorm"),d(this,"_worldQuaternionInv"),d(this,"_worldScale"),d(this,"_worldScaleStart"),d(this,"_offset"),d(this,"isTransformControls"),e===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),e=document),this.visible=!1,this.domElement=e,this.domElement.style.touchAction="none";const i=new If;this._gizmo=i,this.add(i);const n=new Of;this._plane=n,this.add(n);const r=this;function a(v,x){let y=x;Object.defineProperty(r,v,{get:function(){return y!==void 0?y:x},set:function(b){y!==b&&(y=b,n[v]=b,i[v]=b,r.dispatchEvent({type:v+"-changed",value:b}),r.dispatchEvent(Kc))}}),r[v]=x,n[v]=x,i[v]=x}a("camera",t),a("object",void 0),a("enabled",!0),a("axis",null),a("mode","translate"),a("translationSnap",null),a("rotationSnap",null),a("scaleSnap",null),a("space","local"),a("size",.7),a("dragging",!1),a("showX",!0),a("showY",!0),a("showZ",!0);const o=new M,l=new M,h=new Ht,c=new Ht,u=new M,p=new Ht,m=new M,f=new M,g=new M,_=new M;a("worldPosition",o),a("worldPositionStart",l),a("worldQuaternion",h),a("worldQuaternionStart",c),a("cameraPosition",u),a("cameraQuaternion",p),a("pointStart",m),a("pointEnd",f),a("rotationAxis",g),a("rotationAngle",0),a("eye",_),this._offset=new M,this._startNorm=new M,this._endNorm=new M,this._cameraScale=new M,this._parentPosition=new M,this._parentQuaternion=new Ht,this._parentQuaternionInv=new Ht,this._parentScale=new M,this._worldScaleStart=new M,this._worldQuaternionInv=new Ht,this._worldScale=new M,this._positionStart=new M,this._quaternionStart=new Ht,this._scaleStart=new M,this._getPointer=nb.bind(this),this._onPointerDown=rb.bind(this),this._onPointerHover=sb.bind(this),this._onPointerMove=ab.bind(this),this._onPointerUp=ob.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(t){if(this.object===void 0||this.dragging===!0)return;Ws.setFromCamera(t,this.camera);const e=Qc(this._gizmo.picker[this.mode],Ws);this.axis=e?e.object.name:null}pointerDown(t){if(this.object!==void 0&&this.dragging!==!0&&t.button===0&&this.axis!==null){Ws.setFromCamera(t,this.camera);const e=Qc(this._plane,Ws,!0);e&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)),this.dragging=!0,Cf.mode=this.mode,this.dispatchEvent(Cf)}}pointerMove(t){const e=this.axis,i=this.mode,n=this.object;let r=this.space;if(i==="scale"?r="local":e!=="E"&&e!=="XYZE"&&e!=="XYZ"||(r="world"),n===void 0||e===null||this.dragging===!1||t.button!==-1)return;Ws.setFromCamera(t,this.camera);const a=Qc(this._plane,Ws,!0);if(a){if(this.pointEnd.copy(a.point).sub(this.worldPositionStart),i==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),r==="local"&&e!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),e.indexOf("X")===-1&&(this._offset.x=0),e.indexOf("Y")===-1&&(this._offset.y=0),e.indexOf("Z")===-1&&(this._offset.z=0),r==="local"&&e!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),n.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(r==="local"&&(n.position.applyQuaternion(he.copy(this._quaternionStart).invert()),e.search("X")!==-1&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.position.applyQuaternion(this._quaternionStart)),r==="world"&&(n.parent&&n.position.add(ti.setFromMatrixPosition(n.parent.matrixWorld)),e.search("X")!==-1&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.parent&&n.position.sub(ti.setFromMatrixPosition(n.parent.matrixWorld))));else if(i==="scale"){if(e.search("XYZ")!==-1){let o=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(o*=-1),ls.set(o,o,o)}else ti.copy(this.pointStart),ls.copy(this.pointEnd),ti.applyQuaternion(this._worldQuaternionInv),ls.applyQuaternion(this._worldQuaternionInv),ls.divide(ti),e.search("X")===-1&&(ls.x=1),e.search("Y")===-1&&(ls.y=1),e.search("Z")===-1&&(ls.z=1);n.scale.copy(this._scaleStart).multiply(ls),this.scaleSnap&&(e.search("X")!==-1&&(n.scale.x=Math.round(n.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Y")!==-1&&(n.scale.y=Math.round(n.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Z")!==-1&&(n.scale.z=Math.round(n.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(i==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const o=20/this.worldPosition.distanceTo(ti.setFromMatrixPosition(this.camera.matrixWorld));e==="E"?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):e==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(ti.copy(this.rotationAxis).cross(this.eye))*o):e!=="X"&&e!=="Y"&&e!=="Z"||(this.rotationAxis.copy(Tf[e]),ti.copy(Tf[e]),r==="local"&&ti.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(ti.cross(this.eye).normalize())*o),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),r==="local"&&e!=="E"&&e!=="XYZE"?(n.quaternion.copy(this._quaternionStart),n.quaternion.multiply(he.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),n.quaternion.copy(he.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),n.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(Kc),this.dispatchEvent(Af)}}pointerUp(t){t.button===0&&(this.dragging&&this.axis!==null&&(Ef.mode=this.mode,this.dispatchEvent(Ef)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()})}attach(t){return this.object=t,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(Kc),this.dispatchEvent(Af),this.pointStart.copy(this.pointEnd))}getRaycaster(){return Ws}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function nb(s){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:s.button};{const t=this.domElement.getBoundingClientRect();return{x:(s.clientX-t.left)/t.width*2-1,y:-(s.clientY-t.top)/t.height*2+1,button:s.button}}}function sb(s){if(this.enabled)switch(s.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(s))}}function rb(s){this.enabled&&(this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(s)),this.pointerDown(this._getPointer(s)))}function ab(s){this.enabled&&this.pointerMove(this._getPointer(s))}function ob(s){this.enabled&&(this.domElement.releasePointerCapture(s.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(s)))}function Qc(s,t,e){const i=t.intersectObject(s,!0);for(let n=0;n<i.length;n++)if(i[n].object.visible||e)return i[n];return!1}Pf.prototype.isTransformControls=!0;const Ll=new Wi,ie=new M(0,1,0),Rf=new M(0,0,0),Df=new rt,Il=new Ht,Ol=new Ht,Ki=new M,Lf=new rt,Ka=new M(1,0,0),Xs=new M(0,1,0),Qa=new M(0,0,1),zl=new M,$a=new M,to=new M;class If extends St{constructor(){super(),this.type="TransformControlsGizmo";const t=new ae({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=new Is({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),i=t.clone();i.opacity=.15;const n=e.clone();n.opacity=.5;const r=t.clone();r.color.setHex(16711680);const a=t.clone();a.color.setHex(65280);const o=t.clone();o.color.setHex(255);const l=t.clone();l.color.setHex(16711680),l.opacity=.5;const h=t.clone();h.color.setHex(65280),h.opacity=.5;const c=t.clone();c.color.setHex(255),c.opacity=.5;const u=t.clone();u.opacity=.25;const p=t.clone();p.color.setHex(16776960),p.opacity=.25,t.clone().color.setHex(16776960);const m=t.clone();m.color.setHex(7895160);const f=new Ue(0,.04,.1,12);f.translate(0,.05,0);const g=new oe(.08,.08,.08);g.translate(0,.04,0);const _=new Pt;_.setAttribute("position",new et([0,0,0,1,0,0],3));const v=new Ue(.0075,.0075,.5,3);function x(B,O){const F=new zs(B,.0075,3,64,O*Math.PI*2);return F.rotateY(Math.PI/2),F.rotateX(Math.PI/2),F}v.translate(0,.25,0);const y={X:[[new lt(f,r),[.5,0,0],[0,0,-Math.PI/2]],[new lt(f,r),[-.5,0,0],[0,0,Math.PI/2]],[new lt(v,r),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new lt(f,a),[0,.5,0]],[new lt(f,a),[0,-.5,0],[Math.PI,0,0]],[new lt(v,a)]],Z:[[new lt(f,o),[0,0,.5],[Math.PI/2,0,0]],[new lt(f,o),[0,0,-.5],[-Math.PI/2,0,0]],[new lt(v,o),null,[Math.PI/2,0,0]]],XYZ:[[new lt(new Lr(.1,0),u.clone()),[0,0,0]]],XY:[[new lt(new oe(.15,.15,.01),c.clone()),[.15,.15,0]]],YZ:[[new lt(new oe(.15,.15,.01),l.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new lt(new oe(.15,.15,.01),h.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},b={X:[[new lt(new Ue(.2,0,.6,4),i),[.3,0,0],[0,0,-Math.PI/2]],[new lt(new Ue(.2,0,.6,4),i),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new lt(new Ue(.2,0,.6,4),i),[0,.3,0]],[new lt(new Ue(.2,0,.6,4),i),[0,-.3,0],[0,0,Math.PI]]],Z:[[new lt(new Ue(.2,0,.6,4),i),[0,0,.3],[Math.PI/2,0,0]],[new lt(new Ue(.2,0,.6,4),i),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new lt(new Lr(.2,0),i)]],XY:[[new lt(new oe(.2,.2,.01),i),[.15,.15,0]]],YZ:[[new lt(new oe(.2,.2,.01),i),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new lt(new oe(.2,.2,.01),i),[.15,0,.15],[-Math.PI/2,0,0]]]},S={START:[[new lt(new Lr(.01,2),n),null,null,null,"helper"]],END:[[new lt(new Lr(.01,2),n),null,null,null,"helper"]],DELTA:[[new Li(function(){const B=new Pt;return B.setAttribute("position",new et([0,0,0,1,1,1],3)),B}(),n),null,null,null,"helper"]],X:[[new Li(_,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Li(_,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Li(_,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},w={XYZE:[[new lt(x(.5,1),m),null,[0,Math.PI/2,0]]],X:[[new lt(x(.5,.5),r)]],Y:[[new lt(x(.5,.5),a),null,[0,0,-Math.PI/2]]],Z:[[new lt(x(.5,.5),o),null,[0,Math.PI/2,0]]],E:[[new lt(x(.75,1),p),null,[0,Math.PI/2,0]]]},C={AXIS:[[new Li(_,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},L={XYZE:[[new lt(new Os(.25,10,8),i)]],X:[[new lt(new zs(.5,.1,4,24),i),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new lt(new zs(.5,.1,4,24),i),[0,0,0],[Math.PI/2,0,0]]],Z:[[new lt(new zs(.5,.1,4,24),i),[0,0,0],[0,0,-Math.PI/2]]],E:[[new lt(new zs(.75,.1,2,24),i)]]},T={X:[[new lt(g,r),[.5,0,0],[0,0,-Math.PI/2]],[new lt(v,r),[0,0,0],[0,0,-Math.PI/2]],[new lt(g,r),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new lt(g,a),[0,.5,0]],[new lt(v,a)],[new lt(g,a),[0,-.5,0],[0,0,Math.PI]]],Z:[[new lt(g,o),[0,0,.5],[Math.PI/2,0,0]],[new lt(v,o),[0,0,0],[Math.PI/2,0,0]],[new lt(g,o),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new lt(new oe(.15,.15,.01),c),[.15,.15,0]]],YZ:[[new lt(new oe(.15,.15,.01),l),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new lt(new oe(.15,.15,.01),h),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new lt(new oe(.1,.1,.1),u.clone())]]},E={X:[[new lt(new Ue(.2,0,.6,4),i),[.3,0,0],[0,0,-Math.PI/2]],[new lt(new Ue(.2,0,.6,4),i),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new lt(new Ue(.2,0,.6,4),i),[0,.3,0]],[new lt(new Ue(.2,0,.6,4),i),[0,-.3,0],[0,0,Math.PI]]],Z:[[new lt(new Ue(.2,0,.6,4),i),[0,0,.3],[Math.PI/2,0,0]],[new lt(new Ue(.2,0,.6,4),i),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new lt(new oe(.2,.2,.01),i),[.15,.15,0]]],YZ:[[new lt(new oe(.2,.2,.01),i),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new lt(new oe(.2,.2,.01),i),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new lt(new oe(.2,.2,.2),i),[0,0,0]]]},I={X:[[new Li(_,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Li(_,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Li(_,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function z(B){const O=new St;for(const F in B)for(let Q=B[F].length;Q--;){const k=B[F][Q][0].clone(),X=B[F][Q][1],U=B[F][Q][2],H=B[F][Q][3],Z=B[F][Q][4];k.name=F,k.tag=Z,X&&k.position.set(X[0],X[1],X[2]),U&&k.rotation.set(U[0],U[1],U[2]),H&&k.scale.set(H[0],H[1],H[2]),k.updateMatrix();const mt=k.geometry.clone();mt.applyMatrix4(k.matrix),k.geometry=mt,k.renderOrder=1/0,k.position.set(0,0,0),k.rotation.set(0,0,0),k.scale.set(1,1,1),O.add(k)}return O}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=z(y)),this.add(this.gizmo.rotate=z(w)),this.add(this.gizmo.scale=z(T)),this.add(this.picker.translate=z(b)),this.add(this.picker.rotate=z(L)),this.add(this.picker.scale=z(E)),this.add(this.helper.translate=z(S)),this.add(this.helper.rotate=z(C)),this.add(this.helper.scale=z(I)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}onBeforeScenePrepareRender(){const t=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:Ol;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let e=[];e=e.concat(this.picker[this.mode].children),e=e.concat(this.gizmo[this.mode].children),e=e.concat(this.helper[this.mode].children);for(let i=0;i<e.length;i++){const n=e[i];let r;n.visible=!0,n.rotation.set(0,0,0),n.position.copy(this.worldPosition),r=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),n.scale.set(1,1,1).multiplyScalar(r*this.size/4),n.tag!=="helper"?(n.quaternion.copy(t),this.mode==="translate"||this.mode==="scale"?(n.name==="X"&&Math.abs(ie.copy(Ka).applyQuaternion(t).dot(this.eye))>.99&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="Y"&&Math.abs(ie.copy(Xs).applyQuaternion(t).dot(this.eye))>.99&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="Z"&&Math.abs(ie.copy(Qa).applyQuaternion(t).dot(this.eye))>.99&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="XY"&&Math.abs(ie.copy(Qa).applyQuaternion(t).dot(this.eye))<.2&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="YZ"&&Math.abs(ie.copy(Ka).applyQuaternion(t).dot(this.eye))<.2&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="XZ"&&Math.abs(ie.copy(Xs).applyQuaternion(t).dot(this.eye))<.2&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1)):this.mode==="rotate"&&(Il.copy(t),ie.copy(this.eye).applyQuaternion(he.copy(t).invert()),n.name.search("E")!==-1&&n.quaternion.setFromRotationMatrix(Df.lookAt(this.eye,Rf,Xs)),n.name==="X"&&(he.setFromAxisAngle(Ka,Math.atan2(-ie.y,ie.z)),he.multiplyQuaternions(Il,he),n.quaternion.copy(he)),n.name==="Y"&&(he.setFromAxisAngle(Xs,Math.atan2(ie.x,ie.z)),he.multiplyQuaternions(Il,he),n.quaternion.copy(he)),n.name==="Z"&&(he.setFromAxisAngle(Qa,Math.atan2(ie.y,ie.x)),he.multiplyQuaternions(Il,he),n.quaternion.copy(he))),n.visible=n.visible&&(n.name.indexOf("X")===-1||this.showX),n.visible=n.visible&&(n.name.indexOf("Y")===-1||this.showY),n.visible=n.visible&&(n.name.indexOf("Z")===-1||this.showZ),n.visible=n.visible&&(n.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),n.material._color=n.material._color||n.material.color.clone(),n.material._opacity=n.material._opacity||n.material.opacity,n.material.color.copy(n.material._color),n.material.opacity=n.material._opacity,this.enabled&&this.axis&&(n.name===this.axis||this.axis.split("").some(function(a){return n.name===a}))&&(n.material.color.setHex(16776960),n.material.opacity=1)):(n.visible=!1,n.name==="AXIS"?(n.position.copy(this.worldPositionStart),n.visible=!!this.axis,this.axis==="X"&&(he.setFromEuler(Ll.set(0,0,0)),n.quaternion.copy(t).multiply(he),Math.abs(ie.copy(Ka).applyQuaternion(t).dot(this.eye))>.9&&(n.visible=!1)),this.axis==="Y"&&(he.setFromEuler(Ll.set(0,0,Math.PI/2)),n.quaternion.copy(t).multiply(he),Math.abs(ie.copy(Xs).applyQuaternion(t).dot(this.eye))>.9&&(n.visible=!1)),this.axis==="Z"&&(he.setFromEuler(Ll.set(0,Math.PI/2,0)),n.quaternion.copy(t).multiply(he),Math.abs(ie.copy(Qa).applyQuaternion(t).dot(this.eye))>.9&&(n.visible=!1)),this.axis==="XYZE"&&(he.setFromEuler(Ll.set(0,Math.PI/2,0)),ie.copy(this.rotationAxis),n.quaternion.setFromRotationMatrix(Df.lookAt(Rf,ie,Xs)),n.quaternion.multiply(he),n.visible=this.dragging),this.axis==="E"&&(n.visible=!1)):n.name==="START"?(n.position.copy(this.worldPositionStart),n.visible=this.dragging):n.name==="END"?(n.position.copy(this.worldPosition),n.visible=this.dragging):n.name==="DELTA"?(n.position.copy(this.worldPositionStart),n.quaternion.copy(this.worldQuaternionStart),ti.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),ti.applyQuaternion(this.worldQuaternionStart.clone().invert()),n.scale.copy(ti),n.visible=this.dragging):(n.quaternion.copy(t),this.dragging?n.position.copy(this.worldPositionStart):n.position.copy(this.worldPosition),this.axis&&(n.visible=this.axis.search(n.name)!==-1)))}}}If.prototype.isTransformControlsGizmo=!0;class Of extends lt{constructor(){super(new Rs(1e5,1e5,2,2),new ae({visible:!1,wireframe:!0,side:ce,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(e="local"),zl.copy(Ka).applyQuaternion(e==="local"?this.worldQuaternion:Ol),$a.copy(Xs).applyQuaternion(e==="local"?this.worldQuaternion:Ol),to.copy(Qa).applyQuaternion(e==="local"?this.worldQuaternion:Ol),ie.copy($a),this.mode){case"translate":case"scale":switch(this.axis){case"X":ie.copy(this.eye).cross(zl),Ki.copy(zl).cross(ie);break;case"Y":ie.copy(this.eye).cross($a),Ki.copy($a).cross(ie);break;case"Z":ie.copy(this.eye).cross(to),Ki.copy(to).cross(ie);break;case"XY":Ki.copy(to);break;case"YZ":Ki.copy(zl);break;case"XZ":ie.copy(to),Ki.copy($a);break;case"XYZ":case"E":Ki.set(0,0,0)}break;default:Ki.set(0,0,0)}Ki.length()===0?this.quaternion.copy(this.cameraQuaternion):(Lf.lookAt(ti.set(0,0,0),Ki,ie),this.quaternion.setFromRotationMatrix(Lf)),super.updateMatrixWorld(t)}}Of.prototype.isTransformControlsPlane=!0;class zf extends Pf{constructor(t){super(t.camera,t.map.container),d(this,"_enableKeyboardEvent",!1),d(this,"handleKeyboardEvent",e=>{switch(e.keyCode){case 81:this.setSpace(this.space==="local"?"world":"local");break;case 87:this.setMode("translate");break;case 69:this.setMode("rotate");break;case 82:this.setMode("scale");break;case 187:case 107:this.setSize(this.size+.1);break;case 189:case 109:this.setSize(Math.max(this.size-.1,.1));break;case 88:this.showX=!this.showX;break;case 89:this.showY=!this.showY;break;case 90:this.showZ=!this.showZ;break;case 32:this.enabled=!this.enabled;break;case 27:this.reset()}}),this.engine=t,this.addEventListener("change",e=>{t.requestRender()}),this.addEventListener("objectChange",e=>{t.requestRender()}),this.addEventListener("dragging-changed",e=>{e.value?t.map.disableControl():t.map.enableControl()})}dispose(){super.dispose(),this.enableKeyboardEvent=!1}set enableKeyboardEvent(t){t!==this._enableKeyboardEvent&&(this._enableKeyboardEvent=t,t?window.addEventListener("keydown",this.handleKeyboardEvent):window.removeEventListener("keydown",this.handleKeyboardEvent))}}class lb extends pn{constructor(t,e={}){super(),d(this,"_engine"),d(this,"_boundingBoxHelper"),d(this,"_selectedObject"),d(this,"_transformControl"),this._engine=t}isSelected(t){return t===this._selectedObject}select(t){t.__engine_selected||(this._selectedObject&&(this._selectedObject.__engine_selected=!1),this._boundingBoxHelper||(this._boundingBoxHelper=new ib,this._engine.add(this._boundingBoxHelper)),this._boundingBoxHelper.attach(t),this._selectedObject=t,t.__engine_selected=!0,this._engine.requestRender())}deselect(t){this.isSelected(t)&&(this._boundingBoxHelper.detach(),this._selectedObject=null,t.__engine_selected=!1,this._engine.requestRender())}get transformControl(){return this._transformControl||(this._transformControl=new zf(this._engine),this._transformControl.enableKeyboardEvent=!0),this._transformControl}attachTransform(t){const e=this._engine,i=this.transformControl;e.add(i),i.attach(t),i.updateMatrixWorld(),e.requestRender()}detachTransform(){const t=this._engine,e=this.transformControl;t.remove(e),e.detach()}dispose(){}}class An{constructor(t,e,i=null){d(this,"_container"),d(this,"_enabled"),d(this,"_controlOptions",{}),d(this,"_element"),d(this,"_engine"),this._container=t;let n=!1;e?(n=!0,e instanceof Object&&(this._controlOptions=e)):n=!1,this._enabled=n,this._engine=i,this._element=null,this._enabled&&this.init()}init(){let t=this._element=this.createDom();this._container.appendChild(t)}createDom(){}dispose(){this._element&&(this.onDispose(),this._element.remove())}onDispose(){}get container(){return this._container}get element(){return this._element}get enabled(){return this._enabled}set enabled(t){const e=!!t;if(this._enabled!==e){const i=e?"visible":"hidden";this._element?(this._element.style.visibility=i,this.onDispose()):i&&this.init(),this._enabled=e}}}class hb extends An{createDom(){return this._element=document.createElement("img"),xt(this._element,"logo"),this._url=this._url||Jt("assets/images/bdImg.png"),this._element.src=this._url,this._element}set url(t){this._element&&(this._element.src=t),this._url=t}get url(){return this._url}}class cb extends An{createDom(){this.handleZoomIn=this.handleZoomIn.bind(this),this.handleZoomOut=this.handleZoomOut.bind(this),this._element=document.createElement("div"),xt(this._element,"zoom");const t=this._zoomAdd=document.createElement("div");xt(t,"zoom-add");const e=document.createElement("div");xt(e,"zoom-add-tag"),e.setAttribute("style",`background-image: url(${Jt("assets/images/mapZoom2x.png")});`),t.addEventListener(vt.DOWN,this.handleZoomIn),t.appendChild(e);const i=this._zoomSub=document.createElement("div");xt(i,"zoom-sub");const n=document.createElement("div");return xt(n,"zoom-sub-tag"),n.setAttribute("style",`background-image: url(${Jt("assets/images/mapZoom2x.png")});`),i.addEventListener(vt.DOWN,this.handleZoomOut),i.appendChild(n),this._element.appendChild(t),this._element.appendChild(i),this._element}handleZoomIn(){this._engine.map.zoomIn()}handleZoomOut(){this._engine.map.zoomOut()}onDispose(){this._zoomAdd.removeEventListener(vt.DOWN,this.handleZoomIn),this._zoomSub.removeEventListener(vt.DOWN,this.handleZoomOut)}}class ub extends An{createDom(){this._element=document.createElement("div"),xt(this._element,"scale"),this._text=document.createElement("div"),xt(this._text,"scale-text"),this._text.innerText="20km";const t=document.createElement("div");xt(t,"scale-line");const e=document.createElement("div");xt(e,"scale-line-mid");const i=document.createElement("div");xt(i,"scale-line-left");const n=document.createElement("div");return xt(n,"scale-line-right"),t.appendChild(e),t.appendChild(i),t.appendChild(n),this._element.appendChild(this._text),this._element.appendChild(t),this.calculateScale=this.calculateScale.bind(this),this._engine.rendering.addPrepareRenderListener(this.calculateScale),this._element}calculateScale(){const t=this._engine.map.getZoomUnitsByZoom(this._engine.map.getZoom());let e=0;const i=[.05,.1,.2];for(let n=0;n<3&&e<7;n++){const r=i[n]*Math.pow(10,e),a=r/t;if(a>=50&&a<=150){if(this._element.style.width=a+"px",e<1)this._text.innerText=(r<.1?5:100*r)+"cm";else if(e<2)this._text.innerText=(r<1?5:10*r)+"dm";else{const o=r/1e3,l=o<1;this._text.innerText=l?r+"m":o+"km"}break}n<1&&e<1&&a>150&&(this._element.style.width="150px",this._text.innerText="< 5cm"),n>1&&(e++,n=0)}}onDispose(){this._engine.rendering.removePrepareRenderListener(this.calculateScale)}}const kf="M358.4 768H426.666667v85.333333H213.333333v-213.333333h85.333334v68.266667l128-128 59.733333 59.733333-128 128z m345.6 0l-128-128 59.733333-59.733333 132.266667 132.266666V640h85.333333v213.333333h-213.333333v-85.333333h64zM358.4 298.666667l128 128-59.733333 59.733333-128-128V426.666667H213.333333V213.333333h213.333334v85.333334H358.4z m345.6 0H640V213.333333h213.333333v213.333334h-85.333333V354.133333l-132.266667 132.266667-59.733333-59.733333 128-128z";class db extends An{createDom(){this.handleClick=this.handleClick.bind(this),this.handleFullscreenChange=this.handleFullscreenChange.bind(this),this._element=document.createElement("div"),xt(this._element,"fullscreen");const t=document.createElementNS("http://www.w3.org/2000/svg","svg");return t.setAttribute("class","control-group-svg fullscreen-svg"),t.setAttribute("viewBox","0 0 1024 1024"),t.setAttribute("version","1.1"),this._path=document.createElementNS("http://www.w3.org/2000/svg","path"),this._path.setAttribute("d",kf),this._path.setAttribute("class","fullscreen-path"),t.appendChild(this._path),this._flag=!0,this._element.addEventListener(vt.DOWN,this.handleClick),document.addEventListener("fullscreenchange",this.handleFullscreenChange),this._element.appendChild(t),this._element}handleClick(){const t=this._engine.container,e=t instanceof HTMLElement||t&&typeof t=="object"&&t.nodeType===1&&typeof t.nodeName=="string"?t:t.container||t._container;this._flag?e.requestFullscreen?e.requestFullscreen():e.msRequestFullscreen?e.msRequestFullscreen():e.mozRequestFullScreen?e.mozRequestFullScreen():e.webkitRequestFullScreen&&e.webkitRequestFullScreen():document.exitFullscreen?document.exitFullscreen():document.msExitFullscreen?document.msExitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitCancelFullScreen&&document.webkitCancelFullScreen()}handleFullscreenChange(){this._flag=!this._flag,this._flag?this._path.setAttribute("d",kf):this._path.setAttribute("d","M298.666667 631.466667H226.133333v-81.066667h217.6v204.8h-85.333333v-68.266667l-128 128L170.666667 759.466667l128-128z m422.4 0l128 128-59.733334 59.733333-128-128v68.266667h-85.333333V554.666667h217.6v81.066666h-72.533333zM298.666667 341.333333L187.733333 230.4 243.2 170.666667l115.2 115.2V217.6h85.333333v204.8H226.133333V341.333333H298.666667z m430.933333 0h64v81.066667h-217.6V217.6h85.333333v72.533333L780.8 170.666667l59.733333 59.733333L729.6 341.333333z")}onDispose(){this._element.removeEventListener(vt.DOWN,this.handleClick),document.removeEventListener("fullscreenchange",this.handleFullscreenChange)}}class pb extends An{createDom(){this.locate=this.locate.bind(this),this._element=document.createElement("div"),xt(this._element,"geo-locate");const t=document.createElementNS("http://www.w3.org/2000/svg","svg");t.setAttribute("class","control-group-svg geo-locate-svg"),t.setAttribute("viewBox","0 0 1024 1024"),t.setAttribute("version","1.1");const e=document.createElementNS("http://www.w3.org/2000/svg","path");return e.setAttribute("d","M87.424 469.312A426.816 426.816 0 0 1 469.312 87.424V0h85.376v87.424a426.816 426.816 0 0 1 381.888 381.888H1024v85.376h-87.424a426.816 426.816 0 0 1-381.888 381.888V1024h-85.376v-87.424A426.816 426.816 0 0 1 87.424 554.688H0v-85.376h87.424z m424.576 384a341.312 341.312 0 1 0 0-682.624 341.312 341.312 0 0 0 0 682.624z m0-170.624a170.688 170.688 0 1 0 0-341.376 170.688 170.688 0 0 0 0 341.376z"),e.setAttribute("class","geo-locate-path"),t.appendChild(e),this._element.addEventListener(vt.DOWN,this.locate),this._element.appendChild(t),this._element}locate(){window.navigator.geolocation.getCurrentPosition(t=>{var e;const{longitude:i,latitude:n}=(e=t.coords)!=null?e:{};isNaN(i)||isNaN(n)?console.error("定位出错，请重新定位！"):(this._engine.map.setCenter([i,n]),this._engine.map.setZoom(18))},t=>{console.error("定位未开启")})}onDispose(){this._element.removeEventListener(vt.DOWN,this.locate)}}class mb extends An{constructor(){super(...arguments),d(this,"screenshot",(t,e)=>{const i=this._engine.rendering.canvas,n=this._engine.map.mapType,r=document.createElement("canvas"),a=r.getContext("2d");if(r.width=i.width,r.height=i.height,n==="bmapgl"){const l=this._engine.container._webglPainter._canvas;a.drawImage(l,0,0,l.width,l.height)}else if(n==="mapbox"){const l=this._engine.container._canvas;a.drawImage(l,0,0,l.width,l.height)}a.drawImage(i,0,0,i.width,i.height);let o=r.toDataURL();if(e){t=t||"download.png";const l=document.createElement("a");l.href=o,l.download=t,l.click()}return o})}createDom(){this.handleClick=this.handleClick.bind(this),this._element=document.createElement("div"),xt(this._element,"export-image");const t=document.createElementNS("http://www.w3.org/2000/svg","svg");t.setAttribute("class","control-group-svg export-image-svg"),t.setAttribute("viewBox","0 0 1024 1024"),t.setAttribute("version","1.1");const e=document.createElementNS("http://www.w3.org/2000/svg","path");return e.setAttribute("d","M867.90864 574.538232V257.779543a50.844091 50.844091 0 0 0-50.844092-50.844091h-610.129096a50.844091 50.844091 0 0 0-50.844092 50.844091v499.797418l430.141013-257.779543a152.532274 152.532274 0 0 1 157.108243 0z m0 118.466733l-177.445879-106.264151a50.844091 50.844091 0 0 0-50.844092 0L254.220457 817.064548h562.844091a50.844091 50.844091 0 0 0 50.844092-50.844091z m-660.973188-587.757696h610.129096a152.532274 152.532274 0 0 1 152.532274 152.532274v508.440914a152.532274 152.532274 0 0 1-152.532274 152.532274h-610.129096a152.532274 152.532274 0 0 1-152.532274-152.532274v-508.440914a152.532274 152.532274 0 0 1 152.532274-152.532274z m127.110228 355.90864a76.266137 76.266137 0 1 1 76.266137-76.266137 76.266137 76.266137 0 0 1-76.266137 76.266137z"),t.appendChild(e),this._element.addEventListener(vt.DOWN,this.handleClick),this._element.appendChild(t),this._element}handleClick(){this.screenshot("download.png",!0)}onDispose(){this._element.removeEventListener(vt.DOWN,this.handleClick)}}class fb extends An{constructor(){super(...arguments),d(this,"_mapInfo",{pitch:0,heading:0,zoom:0,center:[0,0,0],mousePoint:[0,0,0]}),d(this,"_template","MZ")}createDom(){return this._element=document.createElement("div"),xt(this._element,"mouse-location"),this.mouseMove=this.mouseMove.bind(this),this._engine.event.bind("mousemove",this.mouseMove),this._viewChangedCallback=()=>{if(this._engine.rendering.renderState.viewChanged){const t=this._engine.map,e=t.getCenter();this._mapInfo.pitch=$c(t.getPitch()),this._mapInfo.heading=$c(t.getHeading()),this._mapInfo.zoom=$c(t.getZoom()),this._mapInfo.center=[e[0].toFixed(6),e[1].toFixed(6),e[2].toFixed(2)],this.updateInfoText()}},this._engine.rendering.addPrepareRenderListener(this._viewChangedCallback),this._element}mouseMove(t){const e=t.point;e&&/M/gi.test(this._template)&&(this._mapInfo.mousePoint=[e[0].toFixed(6),e[1].toFixed(6)],this.updateInfoText())}updateInfoText(){const{center:t,heading:e,pitch:i,zoom:n,mousePoint:r}=this._mapInfo,a={M:r,C:t,Z:n,H:e,P:i},o={M:"指针位置",C:"中心点",Z:"级别",H:"旋转角",P:"倾角"},l=this._template.replace(/[MCZHP]/gi,h=>`${o[h]}: ${a[h]} | `).slice(0,-3);this._element.innerText=l}get template(){return this._template}set template(t){this._template=t,this.updateInfoText()}onDispose(){this._engine.event.unbind("mousemove",this.mouseMove),this._engine.rendering.removePrepareRenderListener(this._viewChangedCallback)}}function $c(s,t){return Math.round(s)}class gb extends An{createDom(){this._element=document.createElement("div"),xt(this._element,"drawer");const t=this._drawerBtn=document.createElement("div");xt(t,"drawer-btn");const e=document.createElementNS("http://www.w3.org/2000/svg","svg");e.setAttribute("class","drawer-icon"),e.setAttribute("viewBox","0 0 1024 1024"),e.setAttribute("version","1.1");const i=document.createElementNS("http://www.w3.org/2000/svg","path");i.setAttribute("d","M512 821.504l-416-208-96 48 512 256 512-256-96-48-416 208z m0-181.173333l-416-208-96 48 512 256 512-256-96-48-416 208zM1024 298.666667L512 42.666667 0 298.666667l512 256 512-256zM512 138.058667L833.184 298.666667 512 459.274667 190.816 298.666667 512 138.058667z"),e.appendChild(i),t.addEventListener(vt.DOWN,this.openDrawer),t.appendChild(e);const n=this._drawerList=document.createElement("div");xt(n,"drawer-list"),n.setAttribute("id",`${te}-drawer-list`),n.style.display="none";const r=document.createElement("div");xt(r,"drawer-content");const a=this._controlOptions,o=a&&a.length>0?a.length:0;if(this._drawerCheckboxs=[],o>0){const h=this.addChangeListener.bind(this);for(let c=0;c<o;c++){const u=a[c],p=document.createElement("div");xt(p,"drawer-item");const m=document.createElement("input");xt(m,"drawer-item-check"),h(m,g=>{g.stopPropagation();const _=g.target.checked;u.onChange&&u.onChange(_,u.data,this._engine)}),m.setAttribute("type","checkbox"),u.defaultChecked&&(m.setAttribute("checked",u.defaultChecked),u.onChange&&u.onChange(!0,u.data,this._engine)),this._drawerCheckboxs.push(m);const f=document.createElement("span");xt(f,"drawer-item-name"),f.innerText=u.name,f.onclick=()=>{m.click()},p.appendChild(m),p.appendChild(f),r.appendChild(p)}}const l=document.createElement("div");return xt(l,"drawer-arrow"),n.appendChild(r),n.appendChild(l),this._element.appendChild(t),this._element.appendChild(n),this._element}addChangeListener(t,e){this._eventMap||(this._eventMap=new WeakMap),t.addEventListener("change",e),this._eventMap.set(t,e)}removeChangeListener(t){const e=this._eventMap.get(t);t.removeEventListener("change",e),this._eventMap.delete(t)}openDrawer(){const t=document.getElementById(`${te}-drawer-list`);t.style.display=t.style.display==="none"?"block":"none"}onDispose(){this._drawerBtn.addEventListener(vt.DOWN,this.openDrawer);for(let t=0;t<this._drawerCheckboxs.length;t++)this.removeChangeListener(this._drawerCheckboxs[t])}}class _b extends An{createDom(){this.handleUpBtnClick=this.handleUpBtnClick.bind(this),this.handleDownBtnClick=this.handleDownBtnClick.bind(this),this.handleLeftBtnClick=this.handleLeftBtnClick.bind(this),this.handleRightBtnClick=this.handleRightBtnClick.bind(this),this.handleCenterBtnClick=this.handleCenterBtnClick.bind(this),this._element=document.createElement("div"),xt(this._element,"compass"),this._element.setAttribute("style",`background-image: url(${Jt("assets/images/mapCompass.png")});`),this._up=document.createElementNS("http://www.w3.org/2000/svg","svg"),this._up.setAttribute("class","compass-up"),this._up.setAttribute("viewBox","0 0 1024 1024"),this._up.setAttribute("version","1.1");const t=document.createElementNS("http://www.w3.org/2000/svg","path");t.setAttribute("d","M910.222222 796.444444c-17.066667 0-34.133333-5.688889-45.511111-17.066666L551.822222 409.6c-11.377778-5.688889-17.066667-11.377778-34.133333-11.377778-5.688889 0-22.755556 5.688889-28.444445 11.377778l-329.955555 364.088889c-22.755556 22.755556-56.888889 22.755556-79.644445 5.688889-22.755556-22.755556-22.755556-56.888889-5.688888-79.644445l329.955555-364.088889c28.444444-34.133333 73.955556-51.2 119.466667-51.2s85.333333 22.755556 119.466666 56.888889l312.888889 364.088889c22.755556 22.755556 17.066667 56.888889-5.688889 79.644445-11.377778 5.688889-28.444444 11.377778-39.822222 11.377777z"),this._up.addEventListener(vt.DOWN,this.handleUpBtnClick),this._up.appendChild(t),this._down=document.createElementNS("http://www.w3.org/2000/svg","svg"),this._down.setAttribute("class","compass-down"),this._down.setAttribute("viewBox","0 0 1024 1024"),this._down.setAttribute("version","1.1");const e=document.createElementNS("http://www.w3.org/2000/svg","path");return e.setAttribute("d","M517.688889 796.444444c-45.511111 0-85.333333-17.066667-119.466667-51.2L73.955556 381.155556c-22.755556-22.755556-17.066667-56.888889 5.688888-79.644445 22.755556-22.755556 56.888889-17.066667 79.644445 5.688889l329.955555 364.088889c5.688889 5.688889 17.066667 11.377778 28.444445 11.377778s22.755556-5.688889 34.133333-17.066667l312.888889-364.088889c22.755556-22.755556 56.888889-28.444444 79.644445-5.688889 22.755556 22.755556 28.444444 56.888889 5.688888 79.644445L637.155556 739.555556c-28.444444 39.822222-68.266667 56.888889-119.466667 56.888888 5.688889 0 0 0 0 0z"),this._down.addEventListener(vt.DOWN,this.handleDownBtnClick),this._down.appendChild(e),this._left=document.createElement("div"),xt(this._left,"compass-left"),this._left.setAttribute("style",`background-image: url(${Jt("assets/images/mapCompass.png")});`),this._left.addEventListener(vt.DOWN,this.handleLeftBtnClick),this._right=document.createElement("div"),xt(this._right,"compass-right"),this._right.setAttribute("style",`background-image: url(${Jt("assets/images/mapCompass.png")});`),this._right.addEventListener(vt.DOWN,this.handleRightBtnClick),this._compass=document.createElement("div"),xt(this._compass,"compass-center"),this._compass.setAttribute("style",`background-image: url(${Jt("assets/images/mapCompass.png")});`),this._compass.addEventListener(vt.DOWN,this.handleCenterBtnClick),this._element.appendChild(this._up),this._element.appendChild(this._down),this._element.appendChild(this._left),this._element.appendChild(this._right),this._element.appendChild(this._compass),this._engine.rendering.addPrepareRenderListener(()=>{this._compass.style.transform=`rotate(${this._engine.map.getHeading()}deg)`}),this._element}handleUpBtnClick(){const t=this._engine.map.getPitch();let e=t+2;e=e>89?89:e<0?0:e,t!==e&&this._engine.map.setPitch(e)}handleDownBtnClick(){const t=this._engine.map.getPitch();let e=t-2;e=e>89?89:e<0?0:e,t!==e&&this._engine.map.setPitch(e)}handleLeftBtnClick(){let t=this._engine.map.getHeading()-2;this._engine.map.setHeading((t+360)%360)}handleRightBtnClick(){let t=this._engine.map.getHeading()+2;this._engine.map.setHeading(t%360)}handleCenterBtnClick(){this._engine.map.setHeading(0)}onDispose(){this._up.removeEventListener(vt.DOWN,this.handleUpBtnClick),this._down.removeEventListener(vt.DOWN,this.handleDownBtnClick),this._left.removeEventListener(vt.DOWN,this.handleLeftBtnClick),this._right.removeEventListener(vt.DOWN,this.handleRightBtnClick),this._compass.removeEventListener(vt.DOWN,this.handleCenterBtnClick)}}class vb{constructor(t,e={}){d(this,"_container"),d(this,"_engine"),d(this,"_logo"),d(this,"_zoom"),d(this,"_scale"),d(this,"_fullscreen"),d(this,"_geoLocate"),d(this,"_exportImage"),d(this,"_mapInfo"),d(this,"_compass");const i=t.container,n=i instanceof HTMLElement||i&&typeof i=="object"&&i.nodeType===1&&typeof i.nodeName=="string";this._container=n?i:i.container||i._container;const r=document.createElement("div");r.id=`${te}-controls`,xt(r,`${te}-controls-pane`),this._container.appendChild(r);const a=document.createElement("div");xt(a,"bottom-right-anchor"),this._zoom=new cb(a,e.zoom,t),this._compass=new _b(a,e.compass,t),r.appendChild(a);const o=document.createElement("div");xt(o,"bottom-left-anchor"),r.appendChild(o),this._fullscreen=new db(o,e.fullscreen,t),this._exportImage=new mb(o,e.exportImage,t),this._geoLocate=new pb(o,e.geoLocate,t),this._logo=new hb(r,e.logo,t),this._scale=new ub(r,e.scale,t),this._mapInfo=new fb(r,e.mapInfo,t),this._drawer=new gb(r,e.drawer,t)}dispose(){this._logo.dispose(),this._zoom.dispose(),this._scale.dispose(),this._fullscreen.dispose(),this._geoLocate.dispose(),this._exportImage.dispose(),this._mapInfo.dispose(),this._compass.dispose(),this._drawer.dispose()}get container(){return this._container}get engine(){return this._engine}get compass(){return this._compass}get logo(){return this._logo}get zoom(){return this._zoom}get scale(){return this._scale}get fullscreen(){return this._fullscreen}get geoLocate(){return this._geoLocate}get exportImage(){return this._exportImage}get mapInfo(){return this._mapInfo}get drawer(){return this._drawer}}dt.mvt_uniform_zoomunits_pars=`#define GLSLIFY 1
`,dt.mvt_extra_vertex_utils=`#define GLSLIFY 1
float getPixelSize(vec3 position) {
    return 0.1 * projectionMatrix[1][1] / resolution.y * distance(cameraPosition, position);
}
`,dt.mvt_selective_pars_vertex=`#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
attribute float objectIndex;
uniform float selectedObjectIndex;
varying float isSelected;
#endif`,dt.mvt_selective_vertex=`#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
if (objectIndex == selectedObjectIndex) {
	isSelected = 1.0;
} else {
	isSelected = 0.0;
}
#endif`,dt.mvt_selective_pars_fragment=`#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
varying float isSelected;
uniform vec4 selectedObjectColor;
uniform float selectedObjectColorMode;
#endif`,dt.mvt_selective_fragment=`#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
if (isSelected == 1.0) {
	if (selectedObjectColorMode == 1.) {
		gl_FragColor = selectedObjectColor;
	} else {
		gl_FragColor.rgb = selectedObjectColor.rgb * selectedObjectColor.a + gl_FragColor.rgb * (1.0 - selectedObjectColor.a);
	}
	
}
#endif`,dt.mvt_keepsize_pars_vertex=`#define GLSLIFY 1
uniform bool keepSize;
uniform float pixelRatio;
uniform vec2 resolution;
`,dt.mvt_keepsize_vertex=`#define GLSLIFY 1
vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));
float pixelSize = getPixelSize(worldPosition.xyz);
if (keepSize) {
    transformed *= pixelSize;
}
`,dt.mvt_emissive_pars_fragment=`#define GLSLIFY 1
#define MVT_EMISSIVE_SHADER

uniform vec3 emissive;`,dt.mvt_emissive_fragment=`#define GLSLIFY 1
#ifdef MVT_EMISSIVE_SHADER
    vec4 out_emissive = vec4(emissive.rgb, 1.0);
#endif`,dt.mvt_override_standard_emissivemap_pars_fragment=`#define GLSLIFY 1
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif`,dt.mvt_override_standard_emissivemap_fragment=`#define GLSLIFY 1
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	// emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

    
#endif

if (isEmissive) {
    gl_FragColor = vec4(totalEmissiveRadiance, 1.0);
	#if defined( TONE_MAPPING )
	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
    #endif
    return;
}`,dt.mvt_override_basic_color_pars_fragment=`#define GLSLIFY 1
#ifdef USE_COLOR

	varying vec3 vColor;

#endif`,dt.mvt_override_basic_color_fragment=`#define GLSLIFY 1
if (isEmissive) {
    gl_FragColor = vec4(emissive, 1.0);
    #if defined( TONE_MAPPING )
	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
    #endif
    return;
}
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif`,dt.mvt_animation_pars_vertex=`#define GLSLIFY 1
uniform bool animationPeriodOffset;
#ifdef ENABLE_ANIMATION_ROTATE
uniform float animationRotatePeriod;
#endif

#ifdef ENABLE_ANIMATION_JUMP
uniform float animationJumpPeriod;
uniform float animationJumpHeight;
#endif
`,dt.mvt_animation_vertex=`#define GLSLIFY 1
#ifdef ENABLE_ANIMATION_ROTATE
    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;
    if (animationPeriodOffset) {
        rotateRatio = mod(rotateRatio + instancedRandomFactor, 1.0);
    }
    float rotation = rotateRatio * 6.28;
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * transformed.x - sin( rotation ) * transformed.y;
    rotatedPosition.y = sin( rotation ) * transformed.x + cos( rotation ) * transformed.y;
    transformed.xy = rotatedPosition;
#endif

#ifdef ENABLE_ANIMATION_JUMP
    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;
    if (animationPeriodOffset) {
        jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);
    }
    if (jumpRatio <= 0.5) {
        jumpRatio *= 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    } else {
        jumpRatio = (1.0 - jumpRatio) * 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    }
    #ifdef USE_SIZE3
        transformed.z += jumpRatio * animationJumpHeight / size3.z;
    #else
        transformed.z += jumpRatio * animationJumpHeight / size;
    #endif
    
#endif
`,dt.mvt_mrt_output_pars_fragment=`#define GLSLIFY 1
#ifndef DISABLE_MRT
    layout(location = 1) out highp vec4 pc_fragColor1;
    layout(location = 2) out highp vec4 pc_fragColor2;
    layout(location = 3) out highp vec4 pc_fragColor3;
    // layout(location = 4) out highp vec4 pc_fragColor4;
    // layout(location = 5) out highp vec4 pc_fragColor5;
    // layout(location = 6) out highp vec4 pc_fragColor6;
    // layout(location = 7) out highp vec4 pc_fragColor7;
#endif

#if defined(MVT_EMISSIVE_UNIFORM)
// 发光颜色自定义
    #if defined(MVT_EMISSIVE_COLOR)
        uniform vec3 mvt_emissive;
    #endif  
    uniform float mvt_emissiveIntensity;
#endif`,dt.mvt_mrt_output_fragment=`#define GLSLIFY 1
#ifndef DISABLE_MRT
    // 自定义发光颜色，完全由着色器控制 在着色器中输出 vec4 out_emissive;
    #if defined(MVT_EMISSIVE_SHADER)
        pc_fragColor1 = out_emissive;
    #elif defined(STANDARD)
        pc_fragColor1.rgb = totalEmissiveRadiance;
        pc_fragColor1.a = pc_fragColor.a;
    #elif defined(BASIC)
        pc_fragColor1.rgb = emissive;
        pc_fragColor1.a = pc_fragColor.a;
    // 通过传入的uniform变量颜色自发光
    #elif defined(MVT_EMISSIVE_UNIFORM)
        // 发光颜色自定义
        #if defined(MVT_EMISSIVE_COLOR)
            pc_fragColor1.rgb = mvt_emissive * mvt_emissiveIntensity;
            pc_fragColor1.a = pc_fragColor.a;
        #else  
            pc_fragColor1 = pc_fragColor * mvt_emissiveIntensity;
        #endif
    #else
        pc_fragColor1 = vec4(0.0, 0.0, 0.0, 0.0);
      
    #endif

    #if defined(STANDARD)
        #ifndef FLAT_SHADED
            pc_fragColor2 = vec4(packNormalToRGB(vNormal), gl_FragCoord.z);
        #else
            pc_fragColor2 = vec4(0.0, 0.0, 0.0, 0.0);
        #endif
        pc_fragColor3 = vec4(1.0 - material.roughness, 0.0, 0.0, 1.0);
    #else
        #if defined(MVT_FRAG_NORMAL)
            pc_fragColor2 = vec4(packNormalToRGB(mvt_frag_normal), 1.0);
        #else
            pc_fragColor2 = vec4(0.0, 0.0, 0.0, 0.0);
        #endif
        
        float temp_reflectionFactor = 0.0;
        #if defined(MVT_FRAG_REFLECTION_FACTOR)
            temp_reflectionFactor = mvt_frag_reflectionFactor;
        #endif
        pc_fragColor3 = vec4(temp_reflectionFactor, 0.0, 0.0, 0.0);
    #endif
    
    // pc_fragColor4 = vec4(1.0, 0.0, 1.0, 1.0);
    // pc_fragColor5 = vec4(0.0, 1.0, 0.0, 1.0);
    // pc_fragColor6 = vec4(0.0, 1.0, 0.0, 1.0);
    // pc_fragColor7 = vec4(0.0, 1.0, 0.0, 1.0);
#endif
`,dt.mvt_nmrt_output_pars_fragment=`#define GLSLIFY 1
#if defined(MVT_EMISSIVE_UNIFORM)
    // 发光颜色自定义
    #if defined(MVT_EMISSIVE_COLOR)
        uniform vec3 mvt_emissive;
    #endif  
    uniform float mvt_emissiveIntensity;
#endif
uniform bool isEmissive;`,dt.mvt_nmrt_output_fragment=`#define GLSLIFY 1
if (isEmissive) {
    #if defined(MVT_EMISSIVE_SHADER)
        gl_FragColor = out_emissive;
    #elif defined(STANDARD)
        gl_FragColor.rgb = totalEmissiveRadiance;
    #elif defined(BASIC)
        gl_FragColor.rgb = emissive;
    // 通过传入的uniform变量颜色自发光
    #elif defined(MVT_EMISSIVE_UNIFORM)
        // 发光颜色自定义
        #if defined(MVT_EMISSIVE_COLOR)
            gl_FragColor.rgb = mvt_emissive * mvt_emissiveIntensity;
        #else
            gl_FragColor = gl_FragColor * mvt_emissiveIntensity;
        #endif
    #else
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    #endif
}`,dt.mvt_extra_meshbasic_frag_pars=`#define GLSLIFY 1
#define BASIC
uniform vec3 emissive;`,dt.mvt_clip_pars_vertex=`#define GLSLIFY 1
varying vec3 clip_position;
varying mat4 clip_modelMat4;
#ifdef IS_INSTANCE
    varying mat4 clip_instanceMat4;
#endif`,dt.mvt_clip_vertex=`#define GLSLIFY 1
clip_position = position;
clip_modelMat4 = modelMatrix;
#ifdef IS_INSTANCE
    clip_instanceMat4 = instanceMatrix;
#endif
`,dt.mvt_clip_pars_fragment=`#define GLSLIFY 1
varying vec3 clip_position;
varying mat4 clip_modelMat4;
#ifdef IS_INSTANCE
    varying mat4 clip_instanceMat4;
#endif

uniform vec3 test;

struct ClipParameters {
    vec3 u_polygon[3];
    bool isClip;
    int clip_type;
    vec2 clip_point;
    float clip_radius;
    float clip_width;
    float clip_height;
};

uniform ClipParameters mvt_clipParameters;

bool pointInPolygon(vec3 p, vec3 points[3]) {
   bool inside = false;
   const int length = 3;
   for (int i = 0; i < length; i++) {
       float xi = points[i].x;
       float yi = points[i].y;
       float xj;
       float yj;
       if(i == 0) {
           xj = points[length -1].x;
           yj = points[length -1].y;
       }
       else {
           xj = points[i - 1].x;
           yj = points[i - 1].y;
       }
       bool intersect = ((yi > p.y) != (yj > p.y))
            && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
        if (intersect) {
            inside = !inside;
        }
    }
   return inside;
}

bool pointInCircle(vec2 point, float clip_radius) {
    float distance = length(point - mvt_clipParameters.clip_point);
    return distance < clip_radius;
}

bool pointInRect(vec2 point) {
    return (point.x > mvt_clipParameters.clip_point.x 
        && point.x < mvt_clipParameters.clip_point.x + mvt_clipParameters.clip_width
        && point.y > mvt_clipParameters.clip_point.y 
        && point.y < mvt_clipParameters.clip_point.y + mvt_clipParameters.clip_height);
}`,dt.mvt_clip_fragment=`#define GLSLIFY 1
if (mvt_clipParameters.isClip) {
    vec4 worldCoord;
    #ifdef IS_INSTANCE
        worldCoord = clip_modelMat4 * clip_instanceMat4 * vec4(clip_position, 1.0);
    #else
        worldCoord = clip_modelMat4 * vec4(clip_position, 1.0);
    #endif
    bool isInside = false;
    if (mvt_clipParameters.clip_type == 0) {
        isInside = pointInPolygon(worldCoord.xyz / worldCoord.w, mvt_clipParameters.u_polygon);
    }
    else if (mvt_clipParameters.clip_type == 1) {
        isInside = pointInCircle(worldCoord.xy / worldCoord.w, mvt_clipParameters.clip_radius);
    }
    else if (mvt_clipParameters.clip_type == 2) {
        isInside = pointInRect(worldCoord.xy / worldCoord.w);
    }
    if (!isInside) {
        discard;
    }
}
`,ae.prototype.emissiveIntensity=1,oi.basic.uniforms.emissive={value:new tt(0)},oi.basic.uniforms.isEmissive={value:!1};class Nf extends ny{constructor(t){super(t),this.type=be}parse(t){const e=function(l,h){switch(l){case 1:console.error("THREE.RGBELoader Read Error: "+(h||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(h||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(h||""));break;default:console.error("THREE.RGBELoader: Error: "+(h||""))}return-1},i=function(l,h,c){h=h||1024;let u=l.pos,p=-1,m=0,f="",g=String.fromCharCode.apply(null,new Uint16Array(l.subarray(u,u+128)));for(;0>(p=g.indexOf(`
`))&&m<h&&u<l.byteLength;)f+=g,m+=g.length,u+=128,g+=String.fromCharCode.apply(null,new Uint16Array(l.subarray(u,u+128)));return-1<p&&(l.pos+=m+p+1,f+g.slice(0,p))},n=function(l,h,c,u){const p=l[h+3],m=Math.pow(2,p-128)/255;c[u+0]=l[h+0]*m,c[u+1]=l[h+1]*m,c[u+2]=l[h+2]*m,c[u+3]=1},r=function(l,h,c,u){const p=l[h+3],m=Math.pow(2,p-128)/255;c[u+0]=dl.toHalfFloat(Math.min(l[h+0]*m,65504)),c[u+1]=dl.toHalfFloat(Math.min(l[h+1]*m,65504)),c[u+2]=dl.toHalfFloat(Math.min(l[h+2]*m,65504)),c[u+3]=dl.toHalfFloat(1)},a=new Uint8Array(t);a.pos=0;const o=function(l){const h=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,c=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,u=/^\s*FORMAT=(\S+)\s*$/,p=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,m={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let f,g;if(l.pos>=l.byteLength||!(f=i(l)))return e(1,"no header found");if(!(g=f.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(m.valid|=1,m.programtype=g[1],m.string+=f+`
`;f=i(l),f!==!1;)if(m.string+=f+`
`,f.charAt(0)!=="#"){if((g=f.match(h))&&(m.gamma=parseFloat(g[1])),(g=f.match(c))&&(m.exposure=parseFloat(g[1])),(g=f.match(u))&&(m.valid|=2,m.format=g[1]),(g=f.match(p))&&(m.valid|=4,m.height=parseInt(g[1],10),m.width=parseInt(g[2],10)),2&m.valid&&4&m.valid)break}else m.comments+=f+`
`;return 2&m.valid?4&m.valid?m:e(3,"missing image size specifier"):e(3,"missing format specifier")}(a);if(o!==-1){const l=o.width,h=o.height,c=function(u,p,m){const f=p;if(f<8||f>32767||u[0]!==2||u[1]!==2||128&u[2])return new Uint8Array(u);if(f!==(u[2]<<8|u[3]))return e(3,"wrong scanline width");const g=new Uint8Array(4*p*m);if(!g.length)return e(4,"unable to allocate buffer space");let _=0,v=0;const x=4*f,y=new Uint8Array(4),b=new Uint8Array(x);let S=m;for(;S>0&&v<u.byteLength;){if(v+4>u.byteLength)return e(1);if(y[0]=u[v++],y[1]=u[v++],y[2]=u[v++],y[3]=u[v++],y[0]!=2||y[1]!=2||(y[2]<<8|y[3])!=f)return e(3,"bad rgbe scanline format");let w,C=0;for(;C<x&&v<u.byteLength;){w=u[v++];const T=w>128;if(T&&(w-=128),w===0||C+w>x)return e(3,"bad scanline data");if(T){const E=u[v++];for(let I=0;I<w;I++)b[C++]=E}else b.set(u.subarray(v,v+w),C),C+=w,v+=w}const L=f;for(let T=0;T<L;T++){let E=0;g[_]=b[T+E],E+=f,g[_+1]=b[T+E],E+=f,g[_+2]=b[T+E],E+=f,g[_+3]=b[T+E],_+=4}S--}return g}(a.subarray(a.pos),l,h);if(c!==-1){let u,p,m;switch(this.type){case Ve:m=c.length/4;const f=new Float32Array(4*m);for(let _=0;_<m;_++)n(c,4*_,f,4*_);u=f,p=Ve;break;case be:m=c.length/4;const g=new Uint16Array(4*m);for(let _=0;_<m;_++)r(c,4*_,g,4*_);u=g,p=be;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:l,height:h,data:u,header:o.string,gamma:o.gamma,exposure:o.exposure,type:p}}}return null}setDataType(t){return this.type=t,this}load(t,e,i,n){return super.load(t,function(r,a){switch(r.type){case Ve:case be:r.encoding=un,r.minFilter=Wt,r.magFilter=Wt,r.generateMipmaps=!1,r.flipY=!0}e&&e(r,a)},i,n)}}class xb extends Kn{constructor(t){super(t),this.hdrLoader=new Nf,this.type=be}load(t,e,i,n){Array.isArray(t)||(console.warn("THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead."),this.setDataType(t),t=e,e=i,i=n,n=arguments[4]);const r=new tl;switch(r.type=this.type,r.type){case Ve:case be:r.encoding=un,r.minFilter=Wt,r.magFilter=Wt,r.generateMipmaps=!1}const a=this;let o=0;function l(h,c,u,p){new cl(a.manager).setPath(a.path).setResponseType("arraybuffer").setWithCredentials(a.withCredentials).load(t[h],function(m){o++;const f=a.hdrLoader.parse(m);if(f){if(f.data!==void 0){const g=new Dr(f.data,f.width,f.height);g.type=r.type,g.encoding=r.encoding,g.format=r.format,g.minFilter=r.minFilter,g.magFilter=r.magFilter,g.generateMipmaps=r.generateMipmaps,r.images[h]=g}o===6&&(r.needsUpdate=!0,c&&c(r))}},u,p)}for(let h=0;h<t.length;h++)l(h,e,i,n);return r}setDataType(t){return this.type=t,this.hdrLoader.setDataType(t),this}}const yb={map:{value:null},isEmissive:{value:!1}};class bb extends Zt{constructor(t){super(),this.defines={},this.uniforms=pt.clone(yb),this.side=ce,this.vertexShader=`#define GLSLIFY 1
varying vec2 vUv;

void main()
{
    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);
    vUv = uv;
    gl_Position = projectionMatrix * viewPos;
    gl_Position.z = gl_Position.w;
}
`,this.fragmentShader=`#define GLSLIFY 1
#include <common>
varying vec2 vUv;
uniform sampler2D map;
void main() {

    gl_FragColor = texture2D(map, vUv);

    #include <encodings_fragment>
}
`,this.depthWrite=!1,this.depthTest=!1,this.envMap=null,jt(this,["isEmissive"]),Object.defineProperties(this,{map:{get:function(){return this.uniforms.map.value},set:function(e){this.uniforms.map.value=e,this.needsUpdate=!0}}})}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class Uf extends Fr{constructor(t={}){super(),d(this,"isCustomStaticSky",!0),d(this,"_textureIsCube",!1),d(this,"_textureIsHDR",!1),d(this,"_textureURL",null),d(this,"_textureNames",null),d(this,"_affectWorld",!0),d(this,"_isVerticalTexture",null),d(this,"_mesh",null),d(this,"_material",null),d(this,"_sphereGeometry",null),d(this,"_envTexture",null),d(this,"_engine",null),d(this,"_PMREMGenerator",null),t.texture;const e=this._sphereGeometry=new Os(1,32,32);this.isVerticalTexture=t.isVerticalTexture||!1;const i=this._mesh=new lt(e,this._material);i.frustumCulled=!1,i.collisionDisabled=!0,i.scale.setScalar(1e4),i.rotateX(Math.PI/2),this.add(i)}afterAddToEngine(t){super.afterAddToEngine(t),this._engine=t,this._PMREMGenerator=new La(t.renderer),this._loadSkyTexture()}onBeforeScenePrepareRender(t,e,i){this._mesh.position.copy(i.position),super.onBeforeScenePrepareRender(t)}_loadSkyTexture(){if(!this._engine||!this._textureURL)return;let t=null;t=this._textureIsHDR?this._textureIsCube?new xb:new Nf:this._textureIsCube?new iy:new Ie;const e=this._engine.rendering.scene;let i=null;this._textureIsCube?(t.setPath(this._textureURL),i=this._textureNames?this._textureNames:this._textureIsHDR?["nz.HDR","pz.HDR","px.HDR","nx.HDR","py.HDR","ny.HDR"]:["nz.jpg","pz.jpg","px.jpg","nx.jpg","py.jpg","ny.jpg"]):i=this._textureURL,t.load(i,n=>{this._textureIsCube?(this._envTexture=this._PMREMGenerator.fromCubemap(n).texture,this._affectWorld&&(e.environment=this._envTexture)):(n.encoding=3001,this._material.map=n,this._material.needsUpdate=!0,this._isVerticalTexture?e.environment=null:(this._envTexture=this._PMREMGenerator.fromEquirectangular(n).texture,this._affectWorld&&(e.environment=this._envTexture))),this._engine.requestRender()})}get isVerticalTexture(){return this._verticalTexture}set isVerticalTexture(t){t!==this._isVerticalTexture&&(this._material&&this._material.dispose(),this._material=new bb,this._isVerticalTexture=t,this._mesh&&(this._mesh.material=this._material))}get textureURL(){return this._textureURL}set textureURL(t){this._textureURL=t,this._loadSkyTexture()}get affectWorld(){return this._affectWorld}set affectWorld(t){const e=this._engine.rendering.scene;t?(this._affectWorld=!0,e.environment=this._envTexture):(this._affectWorld=!1,e.environment===this._envTexture&&(e.environment=null))}}class kl extends lt{constructor(){super(kl.Geometry,new ae({opacity:0,transparent:!0})),this.isLensflare=!0,this.type="Lensflare",this.frustumCulled=!1,this.renderOrder=1/0;const t=new M,e=new M,i=new lm(16,16,$t),n=new lm(16,16,$t),r=kl.Geometry,a=new hl({uniforms:{scale:{value:null},screenPosition:{value:null}},vertexShader:`

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,fragmentShader:`

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`,depthTest:!0,depthWrite:!1,transparent:!1}),o=new hl({uniforms:{map:{value:i},scale:{value:null},screenPosition:{value:null}},vertexShader:`

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,fragmentShader:`

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`,depthTest:!1,depthWrite:!1,transparent:!1}),l=new lt(r,a),h=[],c=Ff.Shader,u=new hl({uniforms:{map:{value:null},occlusionMap:{value:n},color:{value:new tt(16777215)},scale:{value:new j},screenPosition:{value:new M}},vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:xa,transparent:!0,depthWrite:!1}),p=new lt(r,u);this.addElement=function(v){h.push(v)};const m=new j,f=new j,g=new Mm,_=new Lt;this.onBeforeRender=function(v,x,y){v.getCurrentViewport(_);const b=_.w/_.z,S=_.z/2,w=_.w/2;let C=16/_.w;if(m.set(C*b,C),g.min.set(_.x,_.y),g.max.set(_.x+(_.z-16),_.y+(_.w-16)),e.setFromMatrixPosition(this.matrixWorld),e.applyMatrix4(y.matrixWorldInverse),!(e.z>0)&&(t.copy(e).applyMatrix4(y.projectionMatrix),f.x=_.x+t.x*S+S-8,f.y=_.y+t.y*w+w-8,g.containsPoint(f))){v.copyFramebufferToTexture(f,i);let L=a.uniforms;L.scale.value=m,L.screenPosition.value=t,v.renderBufferDirect(y,null,r,a,l,null),v.copyFramebufferToTexture(f,n),L=o.uniforms,L.scale.value=m,L.screenPosition.value=t,v.renderBufferDirect(y,null,r,o,l,null);const T=2*-t.x,E=2*-t.y;for(let I=0,z=h.length;I<z;I++){const B=h[I],O=u.uniforms;O.color.value.copy(B.color),O.map.value=B.texture,O.screenPosition.value.x=t.x+T*B.distance,O.screenPosition.value.y=t.y+E*B.distance,C=B.size/_.w;const F=_.w/_.z;O.scale.value.set(C*F,C),u.uniformsNeedUpdate=!0,v.renderBufferDirect(y,null,r,u,p,null)}}},this.dispose=function(){a.dispose(),o.dispose(),u.dispose(),i.dispose(),n.dispose();for(let v=0,x=h.length;v<x;v++)h[v].texture.dispose()}}}class Ff{constructor(t,e=1,i=0,n=new tt(16777215)){this.texture=t,this.size=e,this.distance=i,this.color=n}}Ff.Shader={uniforms:{map:{value:null},occlusionMap:{value:null},color:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:`

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`,fragmentShader:`

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`},kl.Geometry=function(){const s=new Pt,t=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),e=new Wp(t,5);return s.setIndex([0,1,2,0,2,3]),s.setAttribute("position",new za(e,3,0,!1)),s.setAttribute("uv",new za(e,2,3,!1)),s}();const tu=`#define GLSLIFY 1
varying vec2 vUv;
void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`,Nl=`#define GLSLIFY 1
const float PI = 3.14159265358;

// Units are in megameters.
const float groundRadiusMM = 6.371;
const float atmosphereRadiusMM = 6.471;

const vec2 tLUTRes = vec2(256.0, 64.0)*1.;
const vec2 msLUTRes = vec2(32.0, 32.0)*1.;
const vec2 skyLUTRes = vec2(200.0, 200.0)*2.;

const vec3 groundAlbedo = vec3(0.1);

// These are per megameter.
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float rayleighAbsorptionBase = 0.0;

const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;

const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);

// Quality
const float sunTransmittanceSteps = 40.0;
const float mulScattSteps = 20.0;
const int sqrtSamples = 8;

const int numScatteringSteps = 16;

uniform float altitude;
uniform float viewHeight;
/*
 * Animates the sun movement.
 */
float getSunAltitude(float time)
{
    const float periodSec = 10.0;
    return (PI)*time/periodSec - PI/24.;
}
vec3 getSunDir(float time)
{
    // float altitude = getSunAltitude(time);
    // altitude = 2.8;
    return normalize(vec3(cos(altitude), sin(altitude), 0.0));
}

/* Animate camera */
vec3 getViewPos(float time){

    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0002 + viewHeight, 0.0);

    // anything beyond about 7 falls apart because the skyview lut doesn't have enough resolution
    float alt_range = 50.0;

    // viewPos.y += (sin(time/10.0 - PI/2.)*.5+.5) * (atmosphereRadiusMM - groundRadiusMM) * alt_range;

    return viewPos;
}

float getMiePhase(float cosTheta) {
    const float g = 0.8;
    const float scale = 3.0/(8.0*PI);

    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);
    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);

    return scale*num/denom;
}

float getRayleighPhase(float cosTheta) {
    const float k = 3.0/(16.0*PI);
    return k*(1.0+cosTheta*cosTheta);
}

void getScatteringValues(vec3 pos,
                         out vec3 rayleighScattering,
                         out float mieScattering,
                         out vec3 extinction) {
    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;
    // Note: Paper gets these switched up.
    float rayleighDensity = exp(-altitudeKM/8.0);
    float mieDensity = exp(-altitudeKM/1.2);

    rayleighScattering = rayleighScatteringBase*rayleighDensity;
    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;

    mieScattering = mieScatteringBase*mieDensity;
    float mieAbsorption = mieAbsorptionBase*mieDensity;

    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);

    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;
}

float safeacos(const float x) {
    return acos(clamp(x, -1.0, 1.0));
}

// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.
float rayIntersectSphere(vec3 ro, vec3 rd, float rad) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0f && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

// From https://www.shadertoy.com/view/wlBXWK
vec2 rayIntersectSphere2D(
    vec3 start, // starting position of the ray
    vec3 dir, // the direction of the ray
    float radius // and the sphere radius
) {
    // ray-sphere intersection that assumes
    // the sphere is centered at the origin.
    // No intersection when result.x > result.y
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    if (d < 0.0) return vec2(1e5,-1e5);
    return vec2(
        (-b - sqrt(d))/(2.0*a),
        (-b + sqrt(d))/(2.0*a)
    );
}

/*
 * Same parameterization here.
 */
vec3 getValFromTLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 uv = vec2(tLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),
                   tLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));
    uv /= bufferRes;
    // return pos;
    return texture(tex, uv).rgb;
}
vec3 getValFromMultiScattLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 uv = vec2(msLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),
                   msLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));
    uv /= bufferRes;
    return texture(tex, uv).rgb;
}

/* 
 * Do raymarching : builds skyview lut inside atmoshpere, raymarches directly outside atmosphere
*/

vec3 raymarchScattering(sampler2D TLUT, vec2 TLUT_size, sampler2D MSLUT, vec2 MSLUT_size,
                              vec3 viewPos,
                              vec3 rayDir,
                              vec3 sunDir,
                              float numSteps) {
                              
                              
    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);
    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);

    float mindist, maxdist;

    if (atmos_intercept.x < atmos_intercept.y){
        // there is an atmosphere intercept!
        // start at the closest atmosphere intercept
        // trace the distance between the closest and farthest intercept
        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;
		maxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;
    } else {
        // no atmosphere intercept means no atmosphere!
        return vec3(0.0);
    }

    // if in the atmosphere start at the camera
    if (length(viewPos) < atmosphereRadiusMM) mindist=0.0;

    // if there's a terra intercept that's closer than the atmosphere one,
    // use that instead!
    if (terra_intercept > 0.0){ // confirm valid intercepts			
        maxdist = terra_intercept;
    }

    // start marching at the min dist
    vec3 pos = viewPos + mindist * rayDir;
                              
    float cosTheta = dot(rayDir, sunDir);

	float miePhaseValue = getMiePhase(cosTheta);
	float rayleighPhaseValue = getRayleighPhase(-cosTheta);

    vec3 lum = vec3(0.0);
    vec3 transmittance = vec3(1.0);
    float t = 0.0;
    for (float i = 0.0; i < numSteps; i += 1.0) {
        float newT = ((i + 0.3)/numSteps)*(maxdist-mindist);
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t*rayDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        vec3 sampleTransmittance = exp(-dt*extinction);

        vec3 sunTransmittance = getValFromTLUT(TLUT, TLUT_size, newPos, sunDir);
        vec3 psiMS = 0.0*getValFromMultiScattLUT(MSLUT, MSLUT_size, newPos, sunDir);

        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);
        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);
        vec3 inScattering = (rayleighInScattering + mieInScattering);

        // Integrated scattering within path segment.
        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

        lum += scatteringIntegral*transmittance;

        transmittance *= sampleTransmittance;
    }
    return lum;
}
`,eu={uniforms:{altitude:{value:2.8},iChannel0:{value:null},iChannelResolution0:{value:[256,256]},iChannel1:{value:null},iChannelResolution1:{value:[256,256]},iChannel2:{value:null},iChannelResolution2:{value:[256,256]},cameraDirection:{value:new M(0,.27,-1)},viewHeight:{value:.002},upDirection:{value:new M(0,1,0)},tWeather:{value:null},mixGrayFactor:{value:0},isEmissive:{value:!1}},vertexShader:`#define GLSLIFY 1
varying vec3 vWorldPosition;
varying vec2 vUv;
void main() {
    vUv = uv;
    //vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);
    vWorldPosition = normalize(vec3(position.x, position.y, position.z));
    // vWorldPosition = normalize(position);
    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.z = gl_Position.w;
}
`,fragmentShader:Nl+`
#define GLSLIFY 1
/*
 * Modified version of Andrew Helmer's https://www.shadertoy.com/view/slSXRW 
 * implementation of Sebastian Hillare's Unreal engine sky-atmosphere
 * ... still doesn't implement aerial perspective lut, just makes space views possible
* TODO: replace sunflare with something new that works
        allow density profiles, and thicker atmospheres (fails beyond 7.1 right now)
 */

/*
 * Final output basically looks up the value from the skyLUT, and then adds a sun on top,
 * does some tonemapping.
 */
#include <common>
varying vec2 vUv;
varying vec3 vWorldPosition;
uniform sampler2D iChannel0;
uniform vec2 iChannelResolution0;
uniform sampler2D iChannel1;
uniform vec2 iChannelResolution1;
uniform sampler2D iChannel2;
uniform vec2 iChannelResolution2;
uniform vec2 iResolution;
uniform vec3 cameraDirection;
uniform vec3 upDirection;

const vec3 grayColor = vec3(0.5, 0.5, 0.5);

vec3 getValFromSkyLUT(vec3 rayDir, vec3 sunDir) {

    vec3 viewPos = getViewPos(0.);
    float height = length(viewPos);
    vec3 up = viewPos / height;

    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);
    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2
    float azimuthAngle; // Between 0 and 2*PI

    vec3 right = cross(sunDir, up);
    vec3 forward = cross(up, right);

    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));
    float sinTheta = dot(projectedDir, right);
    float cosTheta = dot(projectedDir, forward);
    azimuthAngle = atan(sinTheta, cosTheta) + PI;

    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.
    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);
    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);
    // uv *= skyLUTRes;
    // uv /= iChannelResolution1.xy;

    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);;
    return texture(iChannel1, uv).rgb;
}

vec3 jodieReinhardTonemap(vec3 c){
    // From: https://www.shadertoy.com/view/tdSXzD
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);
    return mix(c / (l + 1.0), tc, tc);
}

vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {
    const float sunSolidAngle = 0.01*PI/180.0;
    const float minSunCosTheta = cos(sunSolidAngle);

    float cosTheta = dot(rayDir, sunDir);
    if (cosTheta >= minSunCosTheta) return vec3(1.0);

    float offset = minSunCosTheta - cosTheta;
    float gaussianBloom = exp(-offset*50000.0)*0.5;
    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;
    return vec3(gaussianBloom+invBloom);
}

vec4 toLinear(vec4 sRGB)
{
	bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
	vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
	vec4 lower = sRGB/vec4(12.92);

	return mix(higher, lower, cutoff);
}

void main() {
    vec3 sunDir = getSunDir(0.);
    vec3 viewPos = getViewPos(0.);

    vec3 camDir = normalize(cameraDirection);
    float camFOVWidth = PI/3.0;
    // vec2 iResolution = vec2(1102, 1246);
    float camWidthScale = 2.0*tan(camFOVWidth/2.0);
    float camHeightScale = camWidthScale*iResolution.y/iResolution.x;

    vec3 camRight = normalize(cross(camDir, upDirection));
    vec3 camUp = normalize(cross(camRight, camDir));

    // camRight = viewMatrix[0].xzy;
    // camUp = viewMatrix[1].xzy;
    // camDir = viewMatrix[2].xzy;
    // vec2 xy = 2.0 * vWorldPosition.xy; // 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;
    vec2 xy = vWorldPosition.xy; // 2.0 * (gl_FragCoord.xy / iResolution.xy / 2.0) - 1.0;
    // vec3 rayDir = normalize(camDir + camRight*xy.x*camWidthScale + camUp*xy.y*camHeightScale);
    vec3 rayDir = normalize(vWorldPosition.xzy);
    vec3 lum;

    if (length(viewPos) < atmosphereRadiusMM * 1.0){
        lum = getValFromSkyLUT(rayDir, sunDir);
    } else {
    
        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere
        lum = raymarchScattering(iChannel0, iChannelResolution0.xy,
                                 iChannel2, iChannelResolution2.xy,
                                 viewPos, rayDir, sunDir, float(numScatteringSteps));
        
        // This little bit of red helps to debug when the rendering switches to pure raymarching
        //lum += vec3(1e-3,0.0,0.0);
    }

    // Tonemapping and gamma. Super ad-hoc, probably a better way to do this.
    lum *= 100.0;
    lum = jodieReinhardTonemap(lum);
    lum = pow(lum, vec3(1.0/2.2));

    // lum += sunWithBloom(rayDir, sunDir);
     // Bloom should be added at the end, but this is subtle and works well.
    vec3 sunLum = sunWithBloom(rayDir, sunDir);
    // Use smoothstep to limit the effect, so it drops off to actual zero.
    sunLum = smoothstep(0.002, 1.0, sunLum);
    if (length(sunLum) > 0.0) {
        if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {
            sunLum *= 0.0;
        } else {
            // If the sun value is applied to this pixel, we need to calculate the transmittance to obscure it.
            sunLum *= getValFromTLUT(iChannel0, iChannelResolution0.xy, viewPos, sunDir);
        }
    }
    lum += sunLum;

    gl_FragColor = vec4(lum,1.0);
    gl_FragColor = toLinear(gl_FragColor);

    // gl_FragColor.rgb = vWorldPosition;
    // float viewDistance = sqrt(length(vec3(rayDir.x * 10., 0.1, rayDir.z * 10.)));
    // vec2 cloudUV = rayDir.xz * viewDistance; //rayDir.xy * length(rayDir);
    // // cloudUV *= mix(1., 10., clamp(sqrt(rayDir.x * rayDir.x + rayDir.y * rayDir.y), 0.0, 1.0));
    // float cloudDensity = texture2D(tWeather, cloudUV * 10.0).x;
    // gl_FragColor.xy = (rayDir.xy + 1.0) * 0.5;
    // gl_FragColor.z += cloudDensity;
    // Peek at the Transmittance LUT
    // if (gl_FragCoord.x < skyLUTRes.x && gl_FragCoord.y < skyLUTRes.y) {
        // gl_FragColor = vec4(8.*texture(iChannel1, gl_FragCoord.xy/skyLUTRes * 0.2).rgb,1.0);
    // }
    // fragColor = vec4(100.*texture(iChannel0, fragCoord.xy/iResolution.xy).rgb,1.0);
       
    // Peek at the Sky View LUT
    // gl_FragColor = vec4(8.*texture(iChannel1, gl_FragCoord.xy/iResolution.xy / 2.).rgb,1.0);

    // Peek at the Multiscattering LUT
    //fragColor = vec4(100.*texture(iChannel2, fragCoord.xy/iResolution.xy).rgb,1.0);
//if (gl_FragCoord.x < msLUTRes.x && gl_FragCoord.y < msLUTRes.y) {
     // gl_FragColor = vec4(100.*texture(iChannel2, gl_FragCoord.xy/iResolution / 2.).rgb,1.0);
// }
    // gl_FragColor = vec4(100.*texture(iChannel0, gl_FragCoord.xy/iChannelResolution0 * 0.1).rgb,1.0);
    #include <tonemapping_fragment>
	#include <encodings_fragment>
}
`},iu={uniforms:{altitude:{value:2.8},viewHeight:{value:2e-4}},vertexShader:tu,fragmentShader:Nl+`
#define GLSLIFY 1
// Buffer A generates the Transmittance LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and
// the value is the transmittance from that point to sun, through the atmosphere.
varying vec2 vUv;
vec3 getSunTransmittance(vec3 pos, vec3 sunDir) {
    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {
        return vec3(0.0);
    }

    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);
    float t = 0.0;

    vec3 transmittance = vec3(1.0);
    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {
        float newT = ((i + 0.3)/sunTransmittanceSteps)*atmoDist;
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t*sunDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        transmittance *= exp(-dt*extinction);
    }
    return transmittance;
}

void main() {
    // if (gl_FragCoord.x >= (tLUTRes.x+1.5) || gl_FragCoord.y >= (tLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(gl_FragCoord.x, 0.0, tLUTRes.x-1.0)/tLUTRes.x;
    float v = vUv.y; // clamp(gl_FragCoord.y, 0.0, tLUTRes.y-1.0)/tLUTRes.y;

    float sunCosTheta = 2.0*u - 1.0;
    float sunTheta = safeacos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);

    vec3 pos = vec3(0.0, height, 0.0);
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));

    gl_FragColor = vec4(getSunTransmittance(pos, sunDir), 1.0);
}
`},nu={uniforms:{altitude:{value:2.8},iChannel0:{value:null},iChannelResolution0:{value:[256,256]},viewHeight:{value:2e-4}},vertexShader:tu,fragmentShader:Nl+`
#define GLSLIFY 1
// Buffer B is the multiple-scattering LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and
// the value is the multiple scattering approximation (Psi_ms from the paper, Eq. 10).
varying vec2 vUv;
uniform sampler2D iChannel0;
uniform vec2 iChannelResolution0;
vec3 getSphericalDir(float theta, float phi) {
     float cosPhi = cos(phi);
     float sinPhi = sin(phi);
     float cosTheta = cos(theta);
     float sinTheta = sin(theta);
     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);
}

// Calculates Equation (5) and (7) from the paper.
void getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) {
    lumTotal = vec3(0.0);
    fms = vec3(0.0);

    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);
    for (int i = 0; i < sqrtSamples; i++) {
        for (int j = 0; j < sqrtSamples; j++) {
            // This integral is symmetric about theta = 0 (or theta = PI), so we
            // only need to integrate from zero to PI, not zero to 2*PI.
            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);
            float phi = safeacos(1.0 - 2.0*(float(j) + 0.5) / float(sqrtSamples));
            vec3 rayDir = getSphericalDir(theta, phi);

            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);
            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);
            float tMax = atmoDist;
            if (groundDist > 0.0) {
                tMax = groundDist;
            }

            float cosTheta = dot(rayDir, sunDir);

            float miePhaseValue = getMiePhase(cosTheta);
            float rayleighPhaseValue = getRayleighPhase(-cosTheta);

            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);
            float t = 0.0;
            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {
                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;
                float dt = newT - t;
                t = newT;

                vec3 newPos = pos + t*rayDir;

                vec3 rayleighScattering, extinction;
                float mieScattering;
                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

                vec3 sampleTransmittance = exp(-dt*extinction);

                // Integrate within each segment.
                vec3 scatteringNoPhase = rayleighScattering + mieScattering;
                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;
                lumFactor += transmittance*scatteringF;

                // This is slightly different from the paper, but I think the paper has a mistake?
                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).
                vec3 sunTransmittance = getValFromTLUT(iChannel0, iChannelResolution0.xy, newPos, sunDir);

                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;
                float mieInScattering = mieScattering*miePhaseValue;
                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;

                // Integrated scattering within path segment.
                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

                lum += scatteringIntegral*transmittance;
                transmittance *= sampleTransmittance;
            }

            if (groundDist > 0.0) {
                vec3 hitPos = pos + groundDist*rayDir;
                if (dot(pos, sunDir) > 0.0) {
                    hitPos = normalize(hitPos)*groundRadiusMM;
                    lum += transmittance*groundAlbedo*getValFromTLUT(iChannel0, iChannelResolution0.xy, hitPos, sunDir);
                }
            }

            fms += lumFactor*invSamples;
            lumTotal += lum*invSamples;
        }
    }
}

void main() {
    // if (fragCoord.x >= (msLUTRes.x+1.5) || fragCoord.y >= (msLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(fragCoord.x, 0.0, msLUTRes.x-1.0)/msLUTRes.x;
    float v = vUv.y; // clamp(fragCoord.y, 0.0, msLUTRes.y-1.0)/msLUTRes.y;

    float sunCosTheta = 2.0*u - 1.0;
    float sunTheta = safeacos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);

    vec3 pos = vec3(0.0, height, 0.0);
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));

    vec3 lum, f_ms;
    getMulScattValues(pos, sunDir, lum, f_ms);

    // Equation 10 from the paper.
    vec3 psi = lum  / (1.0 - f_ms);
    gl_FragColor = vec4(1. * psi, 1.0);
    // gl_FragColor = vec4(vUv/ 1., 0.0, 1.0);
}
`},su={uniforms:{altitude:{value:2.8},iChannel0:{value:null},iChannelResolution0:{value:[256,256]},iChannel1:{value:null},iChannelResolution1:{value:[256,256]},viewHeight:{value:2e-4},mixGrayFactor:{value:0}},vertexShader:tu,fragmentShader:Nl+`
#define GLSLIFY 1
// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),
// but the latitude/altitude is non-linear to get more resolution near the horizon.
varying vec2 vUv;
uniform sampler2D iChannel0;
uniform vec2 iChannelResolution0;
uniform sampler2D iChannel1;
uniform vec2 iChannelResolution1;
uniform float mixGrayFactor;

void main() {
    // if (fragCoord.x >= (skyLUTRes.x+1.5) || fragCoord.y >= (skyLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(fragCoord.x, 0.0, skyLUTRes.x-1.0)/skyLUTRes.x;
    float v = vUv.y; // clamp(fragCoord.y, 0.0, skyLUTRes.y-1.0)/skyLUTRes.y;

    float azimuthAngle = (u - 0.5)*2.0*PI;

    // Non-linear mapping of altitude. See Section 5.3 of the paper.

    float adjV;
    if (v < 0.5) {
		float coord = 1.0 - 2.0*v;
		adjV = -coord*coord;
	} else {
		float coord = v*2.0 - 1.0;
		adjV = coord*coord;
	}

    vec3 viewPos = getViewPos(0.);

    float height = length(viewPos); vec3 up = viewPos / height;
    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5*PI;
    float altitudeAngle = adjV*0.5*PI - horizonAngle;

    float cosAltitude = cos(altitudeAngle);
    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));

    float sunAltitude = (0.5*PI) - acos(dot(getSunDir(0.), up));
    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));

    vec3 lum = raymarchScattering(iChannel0, iChannelResolution0.xy,
                                  iChannel1, iChannelResolution1.xy,
                                  viewPos, rayDir, sunDir, float(numScatteringSteps));
    gl_FragColor = vec4(lum, 1.0);

    if (mixGrayFactor > 0.0) {
        lum = gl_FragColor.xyz;
        vec3 gray = vec3((lum.x + lum.y + lum.z) / 3.0);
        lum = mix(lum, gray, mixGrayFactor);
        gl_FragColor = vec4(lum, 1.0);
    }
}
`};class Mb extends lt{constructor(){super(),d(this,"_fsQuad"),d(this,"_hasPaintedScatterBuffer"),d(this,"_scatteringMaterial"),d(this,"_scatteringRenderTarget"),d(this,"_transmittanceMaterial"),d(this,"_transmittanceRenderTarget"),d(this,"_viewMaterial"),d(this,"_viewRenderTarget"),this.geometry=new Os(1,32,32),this.frustumCulled=!1;const t=[256,64],e=[32,32],i=[400,400],n=this._transmittanceRenderTarget=new de(t[0],t[1],{type:be,depthBuffer:!1});n.texture.name="SkyAtomsphere.transmittance",this._transmittanceMaterial=new Zt({uniforms:pt.clone(iu.uniforms),vertexShader:iu.vertexShader,fragmentShader:iu.fragmentShader});const r=this._scatteringRenderTarget=new de(e[0],e[1],{type:be,depthBuffer:!1});r.texture.name="SkyAtomsphere.scattering",this._scatteringMaterial=new Zt({uniforms:pt.clone(nu.uniforms),vertexShader:nu.vertexShader,fragmentShader:nu.fragmentShader}),this._scatteringMaterial.uniforms.iChannel0.value=n.texture,this._scatteringMaterial.uniforms.iChannelResolution0.value=[t[0],t[1]],this._fsQuad=new Vr(null);const a=this._viewRenderTarget=new de(i[0],i[1],{type:be,depthBuffer:!1});a.texture.name="SkyAtomsphere.view";const o=this._viewMaterial=new Zt({uniforms:pt.clone(su.uniforms),vertexShader:su.vertexShader,fragmentShader:su.fragmentShader});o.uniforms.iChannel0.value=n.texture,o.uniforms.iChannelResolution0.value=[t[0],t[1]],o.uniforms.iChannel1.value=r.texture,o.uniforms.iChannelResolution1.value=[e[0],e[1]];const l=this.material=new Zt({uniforms:pt.clone(eu.uniforms),vertexShader:eu.vertexShader,fragmentShader:eu.fragmentShader,side:ce});l.uniforms.iChannel0.value=n.texture,l.uniforms.iChannelResolution0.value=[t[0],t[1]],l.uniforms.iChannel2.value=r.texture,l.uniforms.iChannelResolution2.value=[e[0],e[1]],l.uniforms.iChannel1.value=a.texture,l.uniforms.iChannelResolution1.value=[i[0],i[1]],Object.defineProperties(this.material,{isEmissive:{get:function(){return this.uniforms.isEmissive.value},set:function(h){this.uniforms.isEmissive.value=h}}}),this._fsQuad=new Vr(null),this.scale.multiplyScalar(1e4),this.altitude=0}onBeforeRender(t,e,i){}updateRenderTargets(t,e){const i=this._fsQuad;this._hasPaintedScatterBuffer||(i.material=this._transmittanceMaterial,t.setRenderTarget(this._transmittanceRenderTarget),t.clear(),i.render(t),i.material=this._scatteringMaterial,t.setRenderTarget(this._scatteringRenderTarget),t.clear(),i.render(t),this._hasPaintedScatterBuffer=!0),i.material=this._viewMaterial,t.setRenderTarget(this._viewRenderTarget),t.clear(),i.render(t),t.setRenderTarget(null)}dispose(){this.geometry.dispose(),this._transmittanceRenderTarget.dispose(),this._scatteringRenderTarget.dispose(),this._viewRenderTarget.dispose(),this._transmittanceMaterial.dispose(),this._scatteringMaterial.dispose(),this._viewMaterial.dispose(),this.material.dispose(),this._fsQuad.dispose()}get altitude(){return this.material.uniforms.altitude.value}set altitude(t){this._transmittanceMaterial.uniforms.altitude.value=t,this._scatteringMaterial.uniforms.altitude.value=t,this._viewMaterial.uniforms.altitude.value=t,this.material.uniforms.altitude.value=t}get mixGrayFactor(){return this._viewMaterial.uniforms.mixGrayFactor.value}set mixGrayFactor(t){this._viewMaterial.uniforms.mixGrayFactor.value=t}}const wb={weatherMap:{value:null},noiseMap:{value:null},blueNoiseMap:{value:null},shapeNoiseMap:{value:null},coverage:{value:.8},density:{value:6},time:{value:0},speed:{value:1},sizeScale:{value:.5},skyMap:{value:null},sunLightMap:{value:null},skyAltitude:{value:2.8},thicknessBias:{value:0},thicknessScale:{value:1},mixGrayFactor:{value:0},sunColor:{value:[1,.95,.85]},isEmissive:{value:!1}},Sb=`#define GLSLIFY 1
varying vec3 vWorldPosition;
varying vec2 vUv;
void main() {
    vUv = uv;
    // vWorldPosition = normalize(position);
    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);
    float skyZ = mix(0.1, 0.002, clamp(length(position.xy) * 1.0, 0.0, 1.0));
    // float skyZ = mix(0.1, 0.002, length(position.xy));
    vWorldPosition = (modelMatrix * vec4(position.x, position.y, skyZ, 1.0)).xyz - vec3(cameraPosition.xy, cameraPosition.z);
    vWorldPosition = normalize(vWorldPosition);
    
    vec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
    worldPosition -= cameraPosition;
    float disToCenter = length(worldPosition.xy);
    float c = sqrt(pow(6300000.0, 2.0) + pow(disToCenter, 2.0));
    worldPosition.z = clamp(6300400.0 - c, 0.0, 400.0);
    vWorldPosition = worldPosition / 1000.0;
    // float radiusZ = clamp(sqrt(0.5 * 0.5 - pow(length(position.xy), 2.0)), 0.0, 0.5);
    // vWorldPosition.z = clamp(sqrt(1.0 - pow(length(vWorldPosition.xy), 2.0)), 0.0, 1.0);
    // vWorldPosition = normalize(vec3(position.x, position.y, skyZ * 1.));
    // gl_Position = projectionMatrix * modelViewMatrix * vec4(vec3(position.x, position.y, skyZ), 1.0);
    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition + vec3(cameraPosition.xyz), 1.0);
    // gl_Position.z = gl_Position.w;
}
`,Tb=`#define GLSLIFY 1
#include <common>
varying vec2 vUv;
varying vec3 vWorldPosition;

uniform sampler2D weatherMap;
uniform sampler2D noiseMap;
uniform sampler2D blueNoiseMap;
uniform sampler2D shapeNoiseMap;
uniform sampler2D skyMap;
uniform sampler2D sunLightMap;
uniform float coverage;
uniform float time;
uniform float speed;
uniform float sizeScale;
// uniform float thinkness;
uniform float thicknessBias;
uniform float thicknessScale;
uniform float density;
uniform vec3 sunColor;

uniform float skyAltitude;
uniform float mixGrayFactor;
const float groundRadiusMM = 6.371;

const float cloud_inscatter = 0.2;
const float cloud_silver_intensity = 2.5;
const float cloud_silver_exponent = 2.0;
const float cloud_outscatter = 0.1;
const float cloud_in_vs_outscatter = 0.5;
const float cloud_beer = 1.0;
const float cloud_attuention_clampval = 0.2;
const float cloud_outscatter_ambient = 0.9;
const float cloud_ambient_minimum = 0.2;

float safeacos(const float x) {
    return acos(clamp(x, -1.0, 1.0));
}

vec3 getSunDir() {
    return normalize(vec3(cos(skyAltitude), sin(skyAltitude), 0.0));
}

vec3 getValFromSkyLUT(vec3 rayDir, vec3 sunDir) {

    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0004, 0.0);
    float height = length(viewPos);
    vec3 up = viewPos / height;

    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);
    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2
    float azimuthAngle; // Between 0 and 2*PI

    vec3 right = cross(sunDir, up);
    vec3 forward = cross(up, right);

    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));
    float sinTheta = dot(projectedDir, right);
    float cosTheta = dot(projectedDir, forward);
    azimuthAngle = atan(sinTheta, cosTheta) + PI;

    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.
    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);
    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);

    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);
    return texture(skyMap, uv).rgb;
}

vec3 jodieReinhardTonemap(vec3 c){
    // From: https://www.shadertoy.com/view/tdSXzD
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);
    return mix(c / (l + 1.0), tc, tc);
}

vec4 toLinear(vec4 sRGB)
{
	bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
	vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
	vec4 lower = sRGB/vec4(12.92);

	return mix(higher, lower, cutoff);
}

float remap(float v, float l0, float h0, float ln, float hn) {
    return ln + (v - l0) * (hn - ln) / (h0 - l0);
}

const float slice = 1.0 / 128.0;
vec4 texture3DNoise(sampler2D noiseTexture, vec2 uv, float z_percent) {
    uv = mod(uv, 1.0);
    uv.x *= slice;
    float num = float(int(z_percent / slice));
    float alpha = mod(z_percent, slice) / slice;
    vec4 val1 = texture2D(noiseTexture, vec2(uv.x + num * slice, uv.y));
    vec4 val2 = texture2D(noiseTexture, vec2(uv.x + (num + 1.0) * slice, uv.y));
    return mix(val1, val2, alpha);
}

float getCloud(vec3 pos) {
    vec2 cloudUV = pos.xy * 0.1;
    float uvOffset = time / 1000000.0 * speed;
    vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);
    float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);
    float ph = clamp((pos.z - 0.4) / 0.6, 0.0, 1.0);
    float srb = saturate(remap(ph, 0.0, 0.007, 0.0, 1.0));
    float wh = 1.0; // weatherColor.z;
    float srt = saturate(remap(ph, wh * 0.2, wh, 1.0, 0.0));
    float sa = srb * srt;
    float drb = ph * saturate(remap(ph, 0.0, 0.15, 0.0, 1.0));
    float drt = saturate(remap(ph, 0.9, 1.0, 1.0, 0.0));
    float da = density * drb * drt /** weatherColor.w*/ * 2.0;
    vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);
    float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);
    // vec4 texture3DNoise = texture3DNoise(shapeNoiseMap, cloudUV, ph);
    // float sn_sample = texture3DNoise.x;
    float sn = saturate(remap(sn_sample * sa, 1.0 - coverage * wmc, 1.0, 0.0, 1.0)) * da;
    return sn;
}

float HG(float cos_angle, float g) {
    float g2 = g * g;
    float val = ((1.0 - g2) / pow( 1.0 + g2 - 2.0 * g * cos_angle, 1.5)) / 4.0 * 3.1415;
    return val; 
}
float InOutScatter(float cos_angle) {
    float first_hg = HG(cos_angle, cloud_inscatter);
    float second_hg = cloud_silver_intensity * pow(saturate(cos_angle), cloud_silver_exponent);
    float in_scatter_hg = max(first_hg, second_hg); 
    float out_scatter_hg = HG(cos_angle, -cloud_outscatter);
    return mix(in_scatter_hg, out_scatter_hg, cloud_in_vs_outscatter);
}
float Attenuation(float density_to_sun, float cos_angle){
    float prim = exp(-cloud_beer * density_to_sun);
    float scnd = exp(-cloud_beer * cloud_attuention_clampval) * 0.7;
    // reduce clamping while facing the sun
    float checkval = remap(cos_angle, 0.0, 1.0, scnd, scnd * 0.5); 
    return max(checkval, prim);
}
float OutScatterAmbient(float density,float percent_height){
    float depth = cloud_outscatter_ambient * pow(density ,remap(percent_height, 0.3, 0.9, 0.5, 1.0));
    float vertical = pow(saturate(remap(percent_height, 0.0, 0.3, 0.8, 1.0)), 0.8);
    float out_scatter = depth * vertical;
    out_scatter = 1.0 - saturate(out_scatter);
    return out_scatter; 
}

vec3 CalculateLight(vec3 sunLightColor, float density, float density_to_sun, float
    cos_angle , float percent_height, float bluenoise, float dist_along_ray ){
    float attenuation_prob = Attenuation(density_to_sun, cos_angle);
    float ambient_out_scatter = OutScatterAmbient(density,percent_height);
    // be calculated once for each march but gave no/tiny perf improvements.
    float sun_highlight = InOutScatter(cos_angle);
    float attenuation = attenuation_prob * sun_highlight * ambient_out_scatter;
    //Ambient min (dist_along_ray used so that far away regions (huge steps ) arent calculated (wrongly))
    attenuation = max(density * cloud_ambient_minimum * (1.0 - pow(saturate(dist_along_ray/4000.0), 2.0)), attenuation);
    // combat banding a bit more
    attenuation += bluenoise * 0.003;
    vec3 ret_color = attenuation * sunLightColor;
    return ret_color; 
}

#ifndef MVT_CLOUD_VOLUMETRIC
vec4 computePlanarCloud() {
    vec2 cloudUV = vWorldPosition.xy * 0.1;
    float uvOffset = time / 1000000.0 * speed;
    vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);
    float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);
    // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);
    // SNsample = R(snr, (sng ×0.625+snb ×0.25+sna ×0.125)−1, 1, 0, 1)
    vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);
    float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);
    float sn = saturate(remap(sn_sample, 1.0 - coverage * wmc, 1.0, 0.0, 1.0));
 
    float thickness = clamp(sn * thicknessScale + thicknessBias, 0.0, 1.0);
    float cloudAlpha = clamp(thickness, 0.0, 1.0); // remap(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);
    vec3 cloudColor = vec3(remap(clamp(cloudAlpha, 0.0, 1.0), 0.0, 1.0, 1.0, 0.6));

    // 太阳散射，根据厚度发生变化
    vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;
    if (mixGrayFactor > 0.0) {
        vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);
        sunLightColor = mix(sunLightColor, gray, mixGrayFactor);
    }
    cloudColor = sunLightColor;
    cloudColor = sunLightColor * (remap(thickness, 0.0, 1.0, 1.5, 0.5));
    
    // 天空大气颜色
    vec3 sunDir = getSunDir();
    vec3 rayDir = normalize(vWorldPosition.xzy);

    cloudColor *= clamp(remap(dot(rayDir, sunDir), -1.0, 1.0, 0.75, 2.0), 0.75, 2.0);

    vec3 atmosphereColor = getValFromSkyLUT(rayDir, sunDir);
    atmosphereColor *= 100.0;
    atmosphereColor = jodieReinhardTonemap(atmosphereColor);
    atmosphereColor = pow(atmosphereColor, vec3(1.0/2.2));
    atmosphereColor = toLinear(vec4(atmosphereColor, 1.0)).xyz;

    float atmosphereColorFactor = remap(clamp(thickness, 0.5, 1.0), 0.5, 1.0, 0.0, 1.0);
    atmosphereColorFactor = 0.5 - abs(0.5 - atmosphereColorFactor);
    cloudColor = mix(cloudColor, atmosphereColor, atmosphereColorFactor);

    // 和天空大气混合
    cloudColor = mix(cloudColor, atmosphereColor, 1.0 - clamp((vWorldPosition.z + 0.02) * 10.0, 0.0, 1.0));

    // cloudColor = atmosphereColor; // lum;
    // vec3 cloudColor = texture2D(skyMap, cloudUV * 2.0).xyz * 10.0;
    return vec4(cloudColor, cloudAlpha);
}
#endif

#ifdef MVT_CLOUD_VOLUMETRIC
vec4 computeVolumetricCloud() {
    // vec2 cloudUV = vUv * 1.0;
    // vec2 cloudUV = vWorldPosition.xy * 0.1;
    // float uvOffset = time / 1000000.0 * speed;
    // vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);
    // float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);
    // // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);
    // // SNsample = R(snr, (sng ×0.625+snb ×0.25+sna ×0.125)−1, 1, 0, 1)
    // vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);
    // float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);
    // float sn = saturate(remap(sn_sample, 1.0 - coverage * wmc, 1.0, 0.0, 1.0));

    vec3 sunDir = getSunDir();
    vec3 direction = normalize(vWorldPosition);
    vec3 samplePos = vec3(vWorldPosition.xy, 0.4);
    float directDensity = 0.0;
    float sunDensity = 0.0;
    vec3 cloudColor = vec3(0.0);

    vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;
    if (mixGrayFactor > 0.0) {
        vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);
        sunLightColor = mix(sunLightColor, gray, mixGrayFactor);
    }
    float step = 0.6 / float(MVT_NUM_SAMPLE_STEPS);
    vec2 cloudUV = samplePos.xy * 0.1;
    for (int i = 0; i < MVT_NUM_SAMPLE_STEPS; i += 1) {
        float blueNoise = (texture2D(blueNoiseMap, cloudUV) - 0.5).x * 0.1;
        samplePos += direction * step * (1.0 + blueNoise);
        float directSampleInfo = getCloud(samplePos);
        directDensity += directSampleInfo;
        vec3 sunPos = samplePos + sunDir * 0.05;
        float sunSampleInfo = getCloud(sunPos);
        sunDensity += directSampleInfo;
        sunDensity += sunSampleInfo;

        float ph = clamp((samplePos.z - 0.4) / 0.6, 0.0, 1.0);
        cloudColor += CalculateLight(sunLightColor, (1.0 - directDensity) * 1.0, sunDensity * 0.5, dot(direction, sunDir.xzy), ph, 0.1, 10.0);
    
        // cloudColor += sunColor * clamp(1.0 - directSampleInfo - sunSampleInfo, 0.0, 1.0);
        // cloudColor += CalculateLight(sunLightColor, 1.0 - directSampleInfo, sunSampleInfo, dot(direction, sunDir.xzy), ph, 0.1, float(i));
        if (directDensity > 1.0) {
            directDensity = 1.0;
            break;
        }
    }
    // float densityScale = 1.0 / sampleSteps * 20.0;
    // float thickness = clamp(sn * thicknessScale + thicknessBias, 0.0, 1.0);
    // directDensity /= float(MVT_NUM_SAMPLE_STEPS);
    sunDensity /= float(MVT_NUM_SAMPLE_STEPS);
    // cloudColor += CalculateLight(sunLightColor, directDensity, sunDensity, dot(direction, sunDir.xzy), 0.2, 0.1, 10.0);
    float cloudAlpha = clamp(directDensity, 0.0, 1.0); // remap(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);
    // cloudColor = sunColor * dot(direction, sunDir) * exp(-0.3 * clamp(sunDensity, 0.0, 1.0));
    // cloudColor = jodieReinhardTonemap(cloudColor);

   
    return vec4(cloudColor, cloudAlpha);
}
#endif

void main() {
    #ifdef MVT_CLOUD_VOLUMETRIC
        gl_FragColor = computeVolumetricCloud();
    #else
        gl_FragColor = computePlanarCloud();
    #endif
    #include <tonemapping_fragment>
	#include <encodings_fragment>
}
`;class Cb extends lt{constructor(){super(),this.geometry=new Os(2,12,12,0,2*Math.PI,0,Math.PI),this.frustumCulled=!1,(this.material=new Zt({uniforms:pt.clone(wb),vertexShader:Sb,fragmentShader:Tb,side:ce,transparent:!0,defines:{MVT_NUM_SAMPLE_STEPS:4}})).uniforms.sunLightMap.value=this.createGradientMap(),Object.defineProperties(this.material,{isEmissive:{get:function(){return this.uniforms.isEmissive.value},set:function(t){this.uniforms.isEmissive.value=t}}}),this.rotateX(Math.PI/2),this.scale.multiplyScalar(7e4)}createGradientMap(){let t=document.createElement("canvas");t.width=64,t.height=2;let e=t.getContext("2d"),i=e.createLinearGradient(0,0,64,0);return i.addColorStop(0,"rgb(0,0,0)"),i.addColorStop(.45,"rgb(0,0,0)"),i.addColorStop(.5,"rgb(200,30,10)"),i.addColorStop(.52,"rgb(220,80,20)"),i.addColorStop(.58,"rgb(255,255,255)"),i.addColorStop(1,"rgb(255,255,255)"),e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap=new Le(t),this._cachedGradientMap}dispose(){this._cachedGradientMap.dispose()}get speed(){return this.material.uniforms.speed.value}set speed(t){this.material.uniforms.speed.value=t}get coverage(){return this.material.uniforms.coverage.value}set coverage(t){this.material.uniforms.coverage.value=t}get density(){return this.material.uniforms.density.value}set density(t){this.material.uniforms.density.value=t}get sizeScale(){return this.material.uniforms.sizeScale.value}set sizeScale(t){this.material.uniforms.sizeScale.value=t}get skyAltitude(){return this.material.uniforms.skyAltitude.value}set skyAltitude(t){this.material.uniforms.skyAltitude.value=t}get thicknessBias(){return this.material.uniforms.thicknessBias.value}set thicknessBias(t){this.material.uniforms.thicknessBias.value=t}get thicknessScale(){return this.material.uniforms.thicknessScale.value}set thicknessScale(t){this.material.uniforms.thicknessScale.value=t}get mixGrayFactor(){return this.material.uniforms.mixGrayFactor.value}set mixGrayFactor(t){this.material.uniforms.mixGrayFactor.value=t}get sampleSteps(){return this.material.defines.MVT_NUM_SAMPLE_STEPS}set sampleSteps(t){t!==this.material.defines.MVT_NUM_SAMPLE_STEPS&&(this.material.defines.MVT_NUM_SAMPLE_STEPS=parseInt(t,10),this.material.needsUpdate=!0)}get volumetric(){return this.material.defines.MVT_CLOUD_VOLUMETRIC!==void 0}set volumetric(t){t?this.material.defines.MVT_CLOUD_VOLUMETRIC="":delete this.material.defines.MVT_CLOUD_VOLUMETRIC,this.material.needsUpdate=!0}}new tt(16777215);class ea extends Kn{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new Db(e)}),this.register(function(e){return new Ub(e)}),this.register(function(e){return new Fb(e)}),this.register(function(e){return new Ib(e)}),this.register(function(e){return new Ob(e)}),this.register(function(e){return new zb(e)}),this.register(function(e){return new kb(e)}),this.register(function(e){return new Rb(e)}),this.register(function(e){return new Nb(e)}),this.register(function(e){return new Lb(e)}),this.register(function(e){return new Ab(e)}),this.register(function(e){return new Bb(e)})}load(t,e,i,n){const r=this;let a;a=this.resourcePath!==""?this.resourcePath:this.path!==""?this.path:Ns.extractUrlBase(t),this.manager.itemStart(t);const o=function(h){n?n(h):console.error(h),r.manager.itemError(t),r.manager.itemEnd(t)},l=new cl(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(t,function(h){try{r.parse(h,a,function(c){e(c),r.manager.itemEnd(t)},o)}catch(c){o(c)}},i,o)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,i,n){let r;const a={},o={};if(typeof t=="string")r=t;else if(Ns.decodeText(new Uint8Array(t,0,4))===Bf){try{a[Nt.KHR_BINARY_GLTF]=new jb(t)}catch(c){return void(n&&n(c))}r=a[Nt.KHR_BINARY_GLTF].content}else r=Ns.decodeText(new Uint8Array(t));const l=JSON.parse(r);if(l.asset===void 0||l.asset.version[0]<2)return void(n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const h=new oM(l,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});h.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const u=this.pluginCallbacks[c](h);o[u.name]=u,a[u.name]=!0}if(l.extensionsUsed)for(let c=0;c<l.extensionsUsed.length;++c){const u=l.extensionsUsed[c],p=l.extensionsRequired||[];switch(u){case Nt.KHR_MATERIALS_UNLIT:a[u]=new Pb;break;case Nt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:a[u]=new Xb;break;case Nt.KHR_DRACO_MESH_COMPRESSION:a[u]=new Gb(l,this.dracoLoader);break;case Nt.KHR_TEXTURE_TRANSFORM:a[u]=new Wb;break;case Nt.KHR_MESH_QUANTIZATION:a[u]=new qb;break;default:p.indexOf(u)>=0&&o[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}h.setExtensions(a),h.setPlugins(o),h.parse(i,n)}parseAsync(t,e){const i=this;return new Promise(function(n,r){i.parse(t,e,n,r)})}}function Eb(){let s={};return{get:function(t){return s[t]},add:function(t,e){s[t]=e},remove:function(t){delete s[t]},removeAll:function(){s={}}}}const Nt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class Ab{constructor(t){this.parser=t,this.name=Nt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let i=0,n=e.length;i<n;i++){const r=e[i];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(t){const e=this.parser,i="light:"+t;let n=e.cache.get(i);if(n)return n;const r=e.json,a=((r.extensions&&r.extensions[this.name]||{}).lights||[])[t];let o;const l=new tt(16777215);a.color!==void 0&&l.fromArray(a.color);const h=a.range!==void 0?a.range:0;switch(a.type){case"directional":o=new _m(l),o.target.position.set(0,0,-1),o.add(o.target);break;case"point":o=new ly(l),o.distance=h;break;case"spot":o=new ay(l),o.distance=h,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,o.angle=a.spot.outerConeAngle,o.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,o.target.position.set(0,0,-1),o.add(o.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return o.position.set(0,0,0),o.decay=2,a.intensity!==void 0&&(o.intensity=a.intensity),o.name=e.createUniqueName(a.name||"light_"+t),n=Promise.resolve(o),e.cache.add(i,n),n}createNodeAttachment(t){const e=this,i=this.parser,n=i.json.nodes[t],r=(n.extensions&&n.extensions[this.name]||{}).light;return r===void 0?null:this._loadLight(r).then(function(a){return i._getNodeRef(e.cache,r,a)})}}class Pb{constructor(){this.name=Nt.KHR_MATERIALS_UNLIT}getMaterialType(){return ae}extendParams(t,e,i){const n=[];t.color=new tt(1,1,1),t.opacity=1;const r=e.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const a=r.baseColorFactor;t.color.fromArray(a),t.opacity=a[3]}r.baseColorTexture!==void 0&&n.push(i.assignTexture(t,"map",r.baseColorTexture,Bt))}return Promise.all(n)}}class Rb{constructor(t){this.parser=t,this.name=Nt.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,e){const i=this.parser.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name].emissiveStrength;return n!==void 0&&(e.emissiveIntensity=n),Promise.resolve()}}class Db{constructor(t){this.parser=t,this.name=Nt.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Jn:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],a=n.extensions[this.name];if(a.clearcoatFactor!==void 0&&(e.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&r.push(i.assignTexture(e,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(e.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&r.push(i.assignTexture(e,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(r.push(i.assignTexture(e,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new j(o,o)}return Promise.all(r)}}class Lb{constructor(t){this.parser=t,this.name=Nt.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Jn:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],a=n.extensions[this.name];return a.iridescenceFactor!==void 0&&(e.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&r.push(i.assignTexture(e,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(e.iridescenceIOR=a.iridescenceIor),e.iridescenceThicknessRange===void 0&&(e.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(e.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(e.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&r.push(i.assignTexture(e,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(r)}}class Ib{constructor(t){this.parser=t,this.name=Nt.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Jn:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];e.sheenColor=new tt(0,0,0),e.sheenRoughness=0,e.sheen=1;const a=n.extensions[this.name];return a.sheenColorFactor!==void 0&&e.sheenColor.fromArray(a.sheenColorFactor),a.sheenRoughnessFactor!==void 0&&(e.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&r.push(i.assignTexture(e,"sheenColorMap",a.sheenColorTexture,Bt)),a.sheenRoughnessTexture!==void 0&&r.push(i.assignTexture(e,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(r)}}class Ob{constructor(t){this.parser=t,this.name=Nt.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Jn:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],a=n.extensions[this.name];return a.transmissionFactor!==void 0&&(e.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&r.push(i.assignTexture(e,"transmissionMap",a.transmissionTexture)),Promise.all(r)}}class zb{constructor(t){this.parser=t,this.name=Nt.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Jn:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],a=n.extensions[this.name];e.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&r.push(i.assignTexture(e,"thicknessMap",a.thicknessTexture)),e.attenuationDistance=a.attenuationDistance||0;const o=a.attenuationColor||[1,1,1];return e.attenuationColor=new tt(o[0],o[1],o[2]),Promise.all(r)}}class kb{constructor(t){this.parser=t,this.name=Nt.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Jn:null}extendMaterialParams(t,e){const i=this.parser.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name];return e.ior=n.ior!==void 0?n.ior:1.5,Promise.resolve()}}class Nb{constructor(t){this.parser=t,this.name=Nt.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Jn:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],a=n.extensions[this.name];e.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&r.push(i.assignTexture(e,"specularIntensityMap",a.specularTexture));const o=a.specularColorFactor||[1,1,1];return e.specularColor=new tt(o[0],o[1],o[2]),a.specularColorTexture!==void 0&&r.push(i.assignTexture(e,"specularColorMap",a.specularColorTexture,Bt)),Promise.all(r)}}class Ub{constructor(t){this.parser=t,this.name=Nt.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,i=e.json,n=i.textures[t];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],a=e.options.ktx2Loader;if(!a){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,r.source,a)}}class Fb{constructor(t){this.parser=t,this.name=Nt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,i=this.parser,n=i.json,r=n.textures[t];if(!r.extensions||!r.extensions[e])return null;const a=r.extensions[e],o=n.images[a.source];let l=i.textureLoader;if(o.uri){const h=i.options.manager.getHandler(o.uri);h!==null&&(l=h)}return this.detectSupport().then(function(h){if(h)return i.loadTextureImage(t,a.source,l);if(n.extensionsRequired&&n.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(e.height===1)}})),this.isSupported}}class Bb{constructor(t){this.name=Nt.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,i=e.bufferViews[t];if(i.extensions&&i.extensions[this.name]){const n=i.extensions[this.name],r=this.parser.getDependency("buffer",n.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([r,a.ready]).then(function(o){const l=n.byteOffset||0,h=n.byteLength||0,c=n.count,u=n.byteStride,p=new ArrayBuffer(c*u),m=new Uint8Array(o[0],l,h);return a.decodeGltfBuffer(new Uint8Array(p),c,u,m,n.mode,n.filter),p})}return null}}const Bf="glTF",Vb=1313821514,Hb=5130562;class jb{constructor(t){this.name=Nt.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,12);if(this.header={magic:Ns.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==Bf)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-12,n=new DataView(t,12);let r=0;for(;r<i;){const a=n.getUint32(r,!0);r+=4;const o=n.getUint32(r,!0);if(r+=4,o===Vb){const l=new Uint8Array(t,12+r,a);this.content=Ns.decodeText(l)}else if(o===Hb){const l=12+r;this.body=t.slice(l,l+a)}r+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Gb{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Nt.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const i=this.json,n=this.dracoLoader,r=t.extensions[this.name].bufferView,a=t.extensions[this.name].attributes,o={},l={},h={};for(const c in a){const u=ou[c]||c.toLowerCase();o[u]=a[c]}for(const c in t.attributes){const u=ou[c]||c.toLowerCase();if(a[c]!==void 0){const p=i.accessors[t.attributes[c]],m=eo[p.componentType];h[u]=m,l[u]=p.normalized===!0}}return e.getDependency("bufferView",r).then(function(c){return new Promise(function(u){n.decodeDracoFile(c,function(p){for(const m in p.attributes){const f=p.attributes[m],g=l[m];g!==void 0&&(f.normalized=g)}u(p)},o,h)})})}}class Wb{constructor(){this.name=Nt.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return e.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),e.offset===void 0&&e.rotation===void 0&&e.scale===void 0||(t=t.clone(),e.offset!==void 0&&t.offset.fromArray(e.offset),e.rotation!==void 0&&(t.rotation=e.rotation),e.scale!==void 0&&t.repeat.fromArray(e.scale),t.needsUpdate=!0),t}}class ru extends yn{constructor(t){super(),this.isGLTFSpecularGlossinessMaterial=!0;const e=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),i=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),n=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),r=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),a=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),o={specular:{value:new tt().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=o,this.onBeforeCompile=function(l){for(const h in o)l.uniforms[h]=o[h];l.fragmentShader=l.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",e).replace("#include <metalnessmap_pars_fragment>",i).replace("#include <roughnessmap_fragment>",n).replace("#include <metalnessmap_fragment>",r).replace("#include <lights_physical_fragment>",a)},Object.defineProperties(this,{specular:{get:function(){return o.specular.value},set:function(l){o.specular.value=l}},specularMap:{get:function(){return o.specularMap.value},set:function(l){o.specularMap.value=l,l?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return o.glossiness.value},set:function(l){o.glossiness.value=l}},glossinessMap:{get:function(){return o.glossinessMap.value},set:function(l){o.glossinessMap.value=l,l?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(t)}copy(t){return super.copy(t),this.specularMap=t.specularMap,this.specular.copy(t.specular),this.glossinessMap=t.glossinessMap,this.glossiness=t.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class Xb{constructor(){this.name=Nt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return ru}extendParams(t,e,i){const n=e.extensions[this.name];t.color=new tt(1,1,1),t.opacity=1;const r=[];if(Array.isArray(n.diffuseFactor)){const a=n.diffuseFactor;t.color.fromArray(a),t.opacity=a[3]}if(n.diffuseTexture!==void 0&&r.push(i.assignTexture(t,"map",n.diffuseTexture,Bt)),t.emissive=new tt(0,0,0),t.glossiness=n.glossinessFactor!==void 0?n.glossinessFactor:1,t.specular=new tt(1,1,1),Array.isArray(n.specularFactor)&&t.specular.fromArray(n.specularFactor),n.specularGlossinessTexture!==void 0){const a=n.specularGlossinessTexture;r.push(i.assignTexture(t,"glossinessMap",a)),r.push(i.assignTexture(t,"specularMap",a,Bt))}return Promise.all(r)}createMaterial(t){const e=new ru(t);return e.fog=!0,e.color=t.color,e.map=t.map===void 0?null:t.map,e.lightMap=null,e.lightMapIntensity=1,e.aoMap=t.aoMap===void 0?null:t.aoMap,e.aoMapIntensity=1,e.emissive=t.emissive,e.emissiveIntensity=t.emissiveIntensity===void 0?1:t.emissiveIntensity,e.emissiveMap=t.emissiveMap===void 0?null:t.emissiveMap,e.bumpMap=t.bumpMap===void 0?null:t.bumpMap,e.bumpScale=1,e.normalMap=t.normalMap===void 0?null:t.normalMap,e.normalMapType=Hn,t.normalScale&&(e.normalScale=t.normalScale),e.displacementMap=null,e.displacementScale=1,e.displacementBias=0,e.specularMap=t.specularMap===void 0?null:t.specularMap,e.specular=t.specular,e.glossinessMap=t.glossinessMap===void 0?null:t.glossinessMap,e.glossiness=t.glossiness,e.alphaMap=null,e.envMap=t.envMap===void 0?null:t.envMap,e.envMapIntensity=1,e}}class qb{constructor(){this.name=Nt.KHR_MESH_QUANTIZATION}}class au extends Ir{constructor(t,e,i,n){super(t,e,i,n)}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=t*n*3+n;for(let a=0;a!==n;a++)e[a]=i[r+a];return e}}au.prototype.interpolate_=function(s,t,e,i){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=2*a,l=3*a,h=i-t,c=(e-t)/h,u=c*c,p=u*c,m=s*l,f=m-l,g=-2*p+3*u,_=p-u,v=1-g,x=_-u+c;for(let y=0;y!==a;y++){const b=r[f+y+a],S=r[f+y+o]*h,w=r[m+y+a],C=r[m+y]*h;n[y]=v*b+x*S+g*w+_*C}return n};const Yb=new Ht;class Zb extends au{interpolate_(t,e,i,n){const r=super.interpolate_(t,e,i,n);return Yb.fromArray(r).normalize().toArray(r),r}}const Jb=0,Kb=1,Qb=2,$b=3,tM=4,Vf=5,Hf=6,eo={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},jf={9728:Ft,9729:Wt,9984:wh,9985:bd,9986:Sh,9987:ys},Gf={33071:ue,33648:Lo,10497:ze},Wf={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ou={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},ia={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},eM={CUBICSPLINE:void 0,LINEAR:cr,STEP:ya},iM="OPAQUE",nM="MASK",sM="BLEND";function io(s,t,e){for(const i in e.extensions)s[i]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[i]=e.extensions[i])}function qs(s,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(s.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function rM(s,t){if(s.updateMorphTargets(),t.weights!==void 0)for(let e=0,i=t.weights.length;e<i;e++)s.morphTargetInfluences[e]=t.weights[e];if(t.extras&&Array.isArray(t.extras.targetNames)){const e=t.extras.targetNames;if(s.morphTargetInfluences.length===e.length){s.morphTargetDictionary={};for(let i=0,n=e.length;i<n;i++)s.morphTargetDictionary[e[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function aM(s){const t=s.extensions&&s.extensions[Nt.KHR_DRACO_MESH_COMPRESSION];let e;return e=t?"draco:"+t.bufferView+":"+t.indices+":"+Xf(t.attributes):s.indices+":"+Xf(s.attributes)+":"+s.mode,e}function Xf(s){let t="";const e=Object.keys(s).sort();for(let i=0,n=e.length;i<n;i++)t+=e[i]+":"+s[e[i]]+";";return t}function lu(s){switch(s){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class oM{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new Eb,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,r=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;typeof createImageBitmap>"u"||i||n&&r<98?this.textureLoader=new Ie(this.options.manager):this.textureLoader=new cy(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new cl(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const i=this,n=this.json,r=this.extensions;this.cache.removeAll(),this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(a){const o={scene:a[0][n.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:n.asset,parser:i,userData:{}};io(r,o,n),qs(o,n),Promise.all(i._invokeAll(function(l){return l.afterRoot&&l.afterRoot(o)})).then(function(){t(o)})}).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],i=this.json.meshes||[];for(let n=0,r=e.length;n<r;n++){const a=e[n].joints;for(let o=0,l=a.length;o<l;o++)t[a[o]].isBone=!0}for(let n=0,r=t.length;n<r;n++){const a=t[n];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(i[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(t,e){e!==void 0&&(t.refs[e]===void 0&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,i){if(t.refs[e]<=1)return i;const n=i.clone(),r=(a,o)=>{const l=this.associations.get(a);l!=null&&this.associations.set(o,l);for(const[h,c]of a.children.entries())r(c,o.children[h])};return r(i,n),n.name+="_instance_"+t.uses[e]++,n}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let i=0;i<e.length;i++){const n=t(e[i]);if(n)return n}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const i=[];for(let n=0;n<e.length;n++){const r=t(e[n]);r&&i.push(r)}return i}getDependency(t,e){const i=t+":"+e;let n=this.cache.get(i);if(!n){switch(t){case"scene":n=this.loadScene(e);break;case"node":n=this.loadNode(e);break;case"mesh":n=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(e)});break;case"accessor":n=this.loadAccessor(e);break;case"bufferView":n=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(e)});break;case"buffer":n=this.loadBuffer(e);break;case"material":n=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(e)});break;case"texture":n=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(e)});break;case"skin":n=this.loadSkin(e);break;case"animation":n=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(e)});break;case"camera":n=this.loadCamera(e);break;default:throw new Error("Unknown type: "+t)}this.cache.add(i,n)}return n}getDependencies(t){let e=this.cache.get(t);if(!e){const i=this,n=this.json[t+(t==="mesh"?"es":"s")]||[];e=Promise.all(n.map(function(r,a){return i.getDependency(t,a)})),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],i=this.fileLoader;if(e.type&&e.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(e.uri===void 0&&t===0)return Promise.resolve(this.extensions[Nt.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(r,a){i.load(Ns.resolveURL(e.uri,n.path),r,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))})})}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then(function(i){const n=e.byteLength||0,r=e.byteOffset||0;return i.slice(r,r+n)})}loadAccessor(t){const e=this,i=this.json,n=this.json.accessors[t];if(n.bufferView===void 0&&n.sparse===void 0)return Promise.resolve(null);const r=[];return n.bufferView!==void 0?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),n.sparse!==void 0&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then(function(a){const o=a[0],l=Wf[n.type],h=eo[n.componentType],c=h.BYTES_PER_ELEMENT,u=c*l,p=n.byteOffset||0,m=n.bufferView!==void 0?i.bufferViews[n.bufferView].byteStride:void 0,f=n.normalized===!0;let g,_;if(m&&m!==u){const v=Math.floor(p/m),x="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+v+":"+n.count;let y=e.cache.get(x);y||(g=new h(o,v*m,n.count*m/c),y=new Wp(g,m/c),e.cache.add(x,y)),_=new za(y,l,p%m/c,f)}else g=o===null?new h(n.count*l):new h(o,p,n.count*l),_=new se(g,l,f);if(n.sparse!==void 0){const v=Wf.SCALAR,x=eo[n.sparse.indices.componentType],y=n.sparse.indices.byteOffset||0,b=n.sparse.values.byteOffset||0,S=new x(a[1],y,n.sparse.count*v),w=new h(a[2],b,n.sparse.count*l);o!==null&&(_=new se(_.array.slice(),_.itemSize,_.normalized));for(let C=0,L=S.length;C<L;C++){const T=S[C];if(_.setX(T,w[C*l]),l>=2&&_.setY(T,w[C*l+1]),l>=3&&_.setZ(T,w[C*l+2]),l>=4&&_.setW(T,w[C*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return _})}loadTexture(t){const e=this.json,i=this.options,n=e.textures[t].source,r=e.images[n];let a=this.textureLoader;if(r.uri){const o=i.manager.getHandler(r.uri);o!==null&&(a=o)}return this.loadTextureImage(t,n,a)}loadTextureImage(t,e,i){const n=this,r=this.json,a=r.textures[t],o=r.images[e],l=(o.uri||o.bufferView)+":"+a.sampler;if(this.textureCache[l])return this.textureCache[l];const h=this.loadImageSource(e,i).then(function(c){c.flipY=!1,a.name&&(c.name=a.name);const u=(r.samplers||{})[a.sampler]||{};return c.magFilter=jf[u.magFilter]||Wt,c.minFilter=jf[u.minFilter]||ys,c.wrapS=Gf[u.wrapS]||ze,c.wrapT=Gf[u.wrapT]||ze,n.associations.set(c,{textures:t}),c}).catch(function(){return null});return this.textureCache[l]=h,h}loadImageSource(t,e){const i=this,n=this.json,r=this.options;if(this.sourceCache[t]!==void 0)return this.sourceCache[t].then(u=>u.clone());const a=n.images[t],o=self.URL||self.webkitURL;let l=a.uri||"",h=!1;if(a.bufferView!==void 0)l=i.getDependency("bufferView",a.bufferView).then(function(u){h=!0;const p=new Blob([u],{type:a.mimeType});return l=o.createObjectURL(p),l});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const c=Promise.resolve(l).then(function(u){return new Promise(function(p,m){let f=p;e.isImageBitmapLoader===!0&&(f=function(g){const _=new ne(g);_.needsUpdate=!0,p(_)}),e.load(Ns.resolveURL(u,r.path),f,void 0,m)})}).then(function(u){var p;return h===!0&&o.revokeObjectURL(l),u.userData.mimeType=a.mimeType||((p=a.uri).search(/\.jpe?g($|\?)/i)>0||p.search(/^data\:image\/jpeg/)===0?"image/jpeg":p.search(/\.webp($|\?)/i)>0||p.search(/^data\:image\/webp/)===0?"image/webp":"image/png"),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),u});return this.sourceCache[t]=c,c}assignTexture(t,e,i,n){const r=this;return this.getDependency("texture",i.index).then(function(a){if(i.texCoord===void 0||i.texCoord==0||e==="aoMap"&&i.texCoord==1||console.warn("THREE.GLTFLoader: Custom UV set "+i.texCoord+" for texture "+e+" not yet supported."),r.extensions[Nt.KHR_TEXTURE_TRANSFORM]){const o=i.extensions!==void 0?i.extensions[Nt.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const l=r.associations.get(a);a=r.extensions[Nt.KHR_TEXTURE_TRANSFORM].extendTexture(a,o),r.associations.set(a,l)}}return n!==void 0&&(a.encoding=n),t[e]=a,a})}assignFinalMaterial(t){const e=t.geometry;let i=t.material;const n=e.attributes.tangent===void 0,r=e.attributes.color!==void 0,a=e.attributes.normal===void 0;if(t.isPoints){const o="PointsMaterial:"+i.uuid;let l=this.cache.get(o);l||(l=new Na,ve.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,l.sizeAttenuation=!1,this.cache.add(o,l)),i=l}else if(t.isLine){const o="LineBasicMaterial:"+i.uuid;let l=this.cache.get(o);l||(l=new Is,ve.prototype.copy.call(l,i),l.color.copy(i.color),this.cache.add(o,l)),i=l}if(n||r||a){let o="ClonedMaterial:"+i.uuid+":";i.isGLTFSpecularGlossinessMaterial&&(o+="specular-glossiness:"),n&&(o+="derivative-tangents:"),r&&(o+="vertex-colors:"),a&&(o+="flat-shading:");let l=this.cache.get(o);l||(l=i.clone(),r&&(l.vertexColors=!0),a&&(l.flatShading=!0),n&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(o,l),this.associations.set(l,this.associations.get(i))),i=l}i.aoMap&&e.attributes.uv2===void 0&&e.attributes.uv!==void 0&&e.setAttribute("uv2",e.attributes.uv),t.material=i}getMaterialType(){return yn}loadMaterial(t){const e=this,i=this.json,n=this.extensions,r=i.materials[t];let a;const o={},l=r.extensions||{},h=[];if(l[Nt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const u=n[Nt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];a=u.getMaterialType(),h.push(u.extendParams(o,r,e))}else if(l[Nt.KHR_MATERIALS_UNLIT]){const u=n[Nt.KHR_MATERIALS_UNLIT];a=u.getMaterialType(),h.push(u.extendParams(o,r,e))}else{const u=r.pbrMetallicRoughness||{};if(o.color=new tt(1,1,1),o.opacity=1,Array.isArray(u.baseColorFactor)){const p=u.baseColorFactor;o.color.fromArray(p),o.opacity=p[3]}u.baseColorTexture!==void 0&&h.push(e.assignTexture(o,"map",u.baseColorTexture,Bt)),o.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,o.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(h.push(e.assignTexture(o,"metalnessMap",u.metallicRoughnessTexture)),h.push(e.assignTexture(o,"roughnessMap",u.metallicRoughnessTexture))),a=this._invokeOne(function(p){return p.getMaterialType&&p.getMaterialType(t)}),h.push(Promise.all(this._invokeAll(function(p){return p.extendMaterialParams&&p.extendMaterialParams(t,o)})))}r.doubleSided===!0&&(o.side=ce);const c=r.alphaMode||iM;if(c===sM?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,c===nM&&(o.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&a!==ae&&(h.push(e.assignTexture(o,"normalMap",r.normalTexture)),o.normalScale=new j(1,1),r.normalTexture.scale!==void 0)){const u=r.normalTexture.scale;o.normalScale.set(u,u)}return r.occlusionTexture!==void 0&&a!==ae&&(h.push(e.assignTexture(o,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&a!==ae&&(o.emissive=new tt().fromArray(r.emissiveFactor)),r.emissiveTexture!==void 0&&a!==ae&&h.push(e.assignTexture(o,"emissiveMap",r.emissiveTexture,Bt)),Promise.all(h).then(function(){let u;return u=a===ru?n[Nt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o):new a(o),r.name&&(u.name=r.name),qs(u,r),e.associations.set(u,{materials:t}),r.extensions&&io(n,u,r),u})}createUniqueName(t){const e=Xt.sanitizeNodeName(t||"");let i=e;for(let n=1;this.nodeNamesUsed[i];++n)i=e+"_"+n;return this.nodeNamesUsed[i]=!0,i}loadGeometries(t){const e=this,i=this.extensions,n=this.primitiveCache;function r(o){return i[Nt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,e).then(function(l){return Yf(l,o,e)})}const a=[];for(let o=0,l=t.length;o<l;o++){const h=t[o],c=aM(h),u=n[c];if(u)a.push(u.promise);else{let p;p=h.extensions&&h.extensions[Nt.KHR_DRACO_MESH_COMPRESSION]?r(h):Yf(new Pt,h,e),n[c]={primitive:h,promise:p},a.push(p)}}return Promise.all(a)}loadMesh(t){const e=this,i=this.json,n=this.extensions,r=i.meshes[t],a=r.primitives,o=[];for(let h=0,c=a.length;h<c;h++){const u=a[h].material===void 0?((l=this.cache).DefaultMaterial===void 0&&(l.DefaultMaterial=new yn({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Fn})),l.DefaultMaterial):this.getDependency("material",a[h].material);o.push(u)}var l;return o.push(e.loadGeometries(a)),Promise.all(o).then(function(h){const c=h.slice(0,h.length-1),u=h[h.length-1],p=[];for(let f=0,g=u.length;f<g;f++){const _=u[f],v=a[f];let x;const y=c[f];if(v.mode===tM||v.mode===Vf||v.mode===Hf||v.mode===void 0)x=r.isSkinnedMesh===!0?new Yx(_,y):new lt(_,y),x.isSkinnedMesh!==!0||x.geometry.attributes.skinWeight.normalized||x.normalizeSkinWeights(),v.mode===Vf?x.geometry=Zf(x.geometry,1):v.mode===Hf&&(x.geometry=Zf(x.geometry,Gd));else if(v.mode===Kb)x=new dc(_,y);else if(v.mode===$b)x=new Li(_,y);else if(v.mode===Qb)x=new Jx(_,y);else{if(v.mode!==Jb)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);x=new ll(_,y)}Object.keys(x.geometry.morphAttributes).length>0&&rM(x,r),x.name=e.createUniqueName(r.name||"mesh_"+t),qs(x,r),v.extensions&&io(n,x,v),e.assignFinalMaterial(x),p.push(x)}for(let f=0,g=p.length;f<g;f++)e.associations.set(p[f],{meshes:t,primitives:f});if(p.length===1)return p[0];const m=new De;e.associations.set(m,{meshes:t});for(let f=0,g=p.length;f<g;f++)m.add(p[f]);return m})}loadCamera(t){let e;const i=this.json.cameras[t],n=i[i.type];if(n)return i.type==="perspective"?e=new ye(re.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):i.type==="orthographic"&&(e=new Ra(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),i.name&&(e.name=this.createUniqueName(i.name)),qs(e,i),Promise.resolve(e);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(t){const e=this.json.skins[t],i={joints:e.joints};return e.inverseBindMatrices===void 0?Promise.resolve(i):this.getDependency("accessor",e.inverseBindMatrices).then(function(n){return i.inverseBindMatrices=n,i})}loadAnimation(t){const e=this.json.animations[t],i=[],n=[],r=[],a=[],o=[];for(let l=0,h=e.channels.length;l<h;l++){const c=e.channels[l],u=e.samplers[c.sampler],p=c.target,m=p.node!==void 0?p.node:p.id,f=e.parameters!==void 0?e.parameters[u.input]:u.input,g=e.parameters!==void 0?e.parameters[u.output]:u.output;i.push(this.getDependency("node",m)),n.push(this.getDependency("accessor",f)),r.push(this.getDependency("accessor",g)),a.push(u),o.push(p)}return Promise.all([Promise.all(i),Promise.all(n),Promise.all(r),Promise.all(a),Promise.all(o)]).then(function(l){const h=l[0],c=l[1],u=l[2],p=l[3],m=l[4],f=[];for(let _=0,v=h.length;_<v;_++){const x=h[_],y=c[_],b=u[_],S=p[_],w=m[_];if(x===void 0)continue;let C;switch(x.updateMatrix(),x.matrixAutoUpdate=!0,ia[w.path]){case ia.weights:C=Ua;break;case ia.rotation:C=ks;break;default:C=Fa}const L=x.name?x.name:x.uuid,T=S.interpolation!==void 0?eM[S.interpolation]:cr,E=[];ia[w.path]===ia.weights?x.traverse(function(z){z.morphTargetInfluences&&E.push(z.name?z.name:z.uuid)}):E.push(L);let I=b.array;if(b.normalized){const z=lu(I.constructor),B=new Float32Array(I.length);for(let O=0,F=I.length;O<F;O++)B[O]=I[O]*z;I=B}for(let z=0,B=E.length;z<B;z++){const O=new C(E[z]+"."+ia[w.path],y.array,I,T);S.interpolation==="CUBICSPLINE"&&(O.createInterpolant=function(F){return new(this instanceof ks?Zb:au)(this.times,this.values,this.getValueSize()/3,F)},O.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),f.push(O)}}const g=e.name?e.name:"animation_"+t;return new gc(g,void 0,f)})}createNodeMesh(t){const e=this.json,i=this,n=e.nodes[t];return n.mesh===void 0?null:i.getDependency("mesh",n.mesh).then(function(r){const a=i._getNodeRef(i.meshCache,n.mesh,r);return n.weights!==void 0&&a.traverse(function(o){if(o.isMesh)for(let l=0,h=n.weights.length;l<h;l++)o.morphTargetInfluences[l]=n.weights[l]}),a})}loadNode(t){const e=this.json,i=this.extensions,n=this,r=e.nodes[t],a=r.name?n.createUniqueName(r.name):"";return function(){const o=[],l=n._invokeOne(function(h){return h.createNodeMesh&&h.createNodeMesh(t)});return l&&o.push(l),r.camera!==void 0&&o.push(n.getDependency("camera",r.camera).then(function(h){return n._getNodeRef(n.cameraCache,r.camera,h)})),n._invokeAll(function(h){return h.createNodeAttachment&&h.createNodeAttachment(t)}).forEach(function(h){o.push(h)}),Promise.all(o)}().then(function(o){let l;if(l=r.isBone===!0?new Jp:o.length>1?new De:o.length===1?o[0]:new St,l!==o[0])for(let h=0,c=o.length;h<c;h++)l.add(o[h]);if(r.name&&(l.userData.name=r.name,l.name=a),qs(l,r),r.extensions&&io(i,l,r),r.matrix!==void 0){const h=new rt;h.fromArray(r.matrix),l.applyMatrix4(h)}else r.translation!==void 0&&l.position.fromArray(r.translation),r.rotation!==void 0&&l.quaternion.fromArray(r.rotation),r.scale!==void 0&&l.scale.fromArray(r.scale);return n.associations.has(l)||n.associations.set(l,{}),n.associations.get(l).nodes=t,l})}loadScene(t){const e=this.json,i=this.extensions,n=this.json.scenes[t],r=this,a=new De;n.name&&(a.name=r.createUniqueName(n.name)),qs(a,n),n.extensions&&io(i,a,n);const o=n.nodes||[],l=[];for(let h=0,c=o.length;h<c;h++)l.push(qf(o[h],a,e,r));return Promise.all(l).then(function(){return r.associations=(h=>{const c=new Map;for(const[u,p]of r.associations)(u instanceof ve||u instanceof ne)&&c.set(u,p);return h.traverse(u=>{const p=r.associations.get(u);p!=null&&c.set(u,p)}),c})(a),a})}}function qf(s,t,e,i){const n=e.nodes[s];return i.getDependency("node",s).then(function(r){if(n.skin===void 0)return r;let a;return i.getDependency("skin",n.skin).then(function(o){a=o;const l=[];for(let h=0,c=a.joints.length;h<c;h++)l.push(i.getDependency("node",a.joints[h]));return Promise.all(l)}).then(function(o){return r.traverse(function(l){if(!l.isMesh)return;const h=[],c=[];for(let u=0,p=o.length;u<p;u++){const m=o[u];if(m){h.push(m);const f=new rt;a.inverseBindMatrices!==void 0&&f.fromArray(a.inverseBindMatrices.array,16*u),c.push(f)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',a.joints[u])}l.bind(new cc(h,c),l.matrixWorld)}),r})}).then(function(r){t.add(r);const a=[];if(n.children){const o=n.children;for(let l=0,h=o.length;l<h;l++){const c=o[l];a.push(qf(c,r,e,i))}}return Promise.all(a)})}function Yf(s,t,e){const i=t.attributes,n=[];function r(a,o){return e.getDependency("accessor",a).then(function(l){s.setAttribute(o,l)})}for(const a in i){const o=ou[a]||a.toLowerCase();o in s.attributes||n.push(r(i[a],o))}if(t.indices!==void 0&&!s.index){const a=e.getDependency("accessor",t.indices).then(function(o){s.setIndex(o)});n.push(a)}return qs(s,t),function(a,o,l){const h=o.attributes,c=new He;if(h.POSITION===void 0)return;{const m=l.json.accessors[h.POSITION],f=m.min,g=m.max;if(f===void 0||g===void 0)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(c.set(new M(f[0],f[1],f[2]),new M(g[0],g[1],g[2])),m.normalized){const _=lu(eo[m.componentType]);c.min.multiplyScalar(_),c.max.multiplyScalar(_)}}const u=o.targets;if(u!==void 0){const m=new M,f=new M;for(let g=0,_=u.length;g<_;g++){const v=u[g];if(v.POSITION!==void 0){const x=l.json.accessors[v.POSITION],y=x.min,b=x.max;if(y!==void 0&&b!==void 0){if(f.setX(Math.max(Math.abs(y[0]),Math.abs(b[0]))),f.setY(Math.max(Math.abs(y[1]),Math.abs(b[1]))),f.setZ(Math.max(Math.abs(y[2]),Math.abs(b[2]))),x.normalized){const S=lu(eo[x.componentType]);f.multiplyScalar(S)}m.max(f)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}c.expandByVector(m)}a.boundingBox=c;const p=new mi;c.getCenter(p.center),p.radius=c.min.distanceTo(c.max)/2,a.boundingSphere=p}(s,t,e),Promise.all(n).then(function(){return t.targets!==void 0?function(a,o,l){let h=!1,c=!1,u=!1;for(let g=0,_=o.length;g<_;g++){const v=o[g];if(v.POSITION!==void 0&&(h=!0),v.NORMAL!==void 0&&(c=!0),v.COLOR_0!==void 0&&(u=!0),h&&c&&u)break}if(!h&&!c&&!u)return Promise.resolve(a);const p=[],m=[],f=[];for(let g=0,_=o.length;g<_;g++){const v=o[g];if(h){const x=v.POSITION!==void 0?l.getDependency("accessor",v.POSITION):a.attributes.position;p.push(x)}if(c){const x=v.NORMAL!==void 0?l.getDependency("accessor",v.NORMAL):a.attributes.normal;m.push(x)}if(u){const x=v.COLOR_0!==void 0?l.getDependency("accessor",v.COLOR_0):a.attributes.color;f.push(x)}}return Promise.all([Promise.all(p),Promise.all(m),Promise.all(f)]).then(function(g){const _=g[0],v=g[1],x=g[2];return h&&(a.morphAttributes.position=_),c&&(a.morphAttributes.normal=v),u&&(a.morphAttributes.color=x),a.morphTargetsRelative=!0,a})}(s,t.targets,e):s})}function Zf(s,t){let e=s.getIndex();if(e===null){const a=[],o=s.getAttribute("position");if(o===void 0)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),s;for(let l=0;l<o.count;l++)a.push(l);s.setIndex(a),e=s.getIndex()}const i=e.count-2,n=[];if(t===Gd)for(let a=1;a<=i;a++)n.push(e.getX(0)),n.push(e.getX(a)),n.push(e.getX(a+1));else for(let a=0;a<i;a++)a%2==0?(n.push(e.getX(a)),n.push(e.getX(a+1)),n.push(e.getX(a+2))):(n.push(e.getX(a+2)),n.push(e.getX(a+1)),n.push(e.getX(a)));n.length/3!==i&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=s.clone();return r.setIndex(n),r}class Jf extends Fr{constructor(){super(),d(this,"isUltraDynamicSky",!0),d(this,"_rtFlipCount",0),d(this,"_skyNeedsUpdate",!0),d(this,"_staticEnvMapNeedsUpdate",!0),d(this,"_realtimeCapture",!0),d(this,"_envMapType",2),d(this,"_PMREMGenerator",null),d(this,"_cloud",null),d(this,"_envRenderTarget1",null),d(this,"_envRenderTarget2",null),d(this,"_skyAtomsphere",null),d(this,"name","UltraDynamicSky"),d(this,"dynamicCloud",!1),d(this,"updateRealtimeEnvironment",()=>{const t=this.engine;if(!this._envRenderTarget1){this.disposeEnvRenderTarget(1),this._PMREMGenerator=new La(t.renderer);const e=this._envRenderTarget1=new de(1,1,{type:be,format:$t,encoding:Bt,depthBuffer:!1});e.texture.mapping=xs,e.texture.name="PMREM.cubeUv1",e.scissorTest=!0;const i=this._envRenderTarget2=new de(1,1,{type:be,format:$t,encoding:Bt,depthBuffer:!1});i.texture.mapping=xs,i.texture.name="PMREM.cubeUv2",i.scissorTest=!0,this._PMREMGenerator.prepareForRenderTarget(this._envRenderTarget1,this._envRenderTarget2,128)}t.rendering.objectsScene.visible=!1,this._rtFlipCount%2==0?(this._PMREMGenerator.fromSceneToRenderTarget(t.scene,this._envRenderTarget1,this._envRenderTarget2,0,.1,1e4),t.rendering.scene.environment=this._envRenderTarget1.texture):(this._PMREMGenerator.fromSceneToRenderTarget(t.scene,this._envRenderTarget2,this._envRenderTarget1,0,.1,1e4),t.rendering.scene.environment=this._envRenderTarget2.texture),t.rendering.objectsScene.visible=!0}),d(this,"disposeEnvRenderTarget",t=>{this._envRenderTarget1&&(this._envRenderTarget1.dispose(),this._envRenderTarget1=null),this._envRenderTarget2&&(this._envRenderTarget2.dispose(),this._envRenderTarget2=null)})}afterAddToEngine(t){super.afterAddToEngine(t),this.engine=t,this.initEnv()}initEnv(){const t=this.engine,e=this._skyAtomsphere=new Mb;e.collisionDisabled=!0,e.__isEnvironment=!0,e.renderOrder=-100,t.add(e);const i=this._cloud=new Cb,n=new Ie,r=n.load(Jt("assets/textures/cloud/weather_1.png"),h=>{r.wrapS=r.wrapT=ze,i.material.uniforms.weatherMap.value=r}),a=n.load(Jt("assets/textures/cloud/shape_1.png"),h=>{a.wrapS=a.wrapT=ze,i.material.uniforms.noiseMap.value=a}),o=n.load(Jt("assets/textures/cloud/blue_noise.png"),h=>{o.wrapS=o.wrapT=ze,i.material.uniforms.blueNoiseMap.value=o}),l=n.load(Jt("assets/textures/cloud/3d_noise_128.png"),h=>{l.wrapS=l.wrapT=ze,i.material.uniforms.shapeNoiseMap.value=l});i.material.uniforms.skyMap.value=e.material.uniforms.iChannel1.value,i.__isEnvironment=!0,i.renderOrder=-99,t.add(i)}onBeforeScenePrepareRender(){super.onBeforeScenePrepareRender();const t=this.engine,e=this._skyAtomsphere,i=this._cloud;this._skyNeedsUpdate&&(e.updateRenderTargets(t.rendering.renderer,t.rendering.camera),i.material.uniforms.skyAltitude.value=e.altitude),this.dynamicCloud&&(i.material.uniforms.time.value=t.rendering.uniforms.elapsedTime.value),(this._skyNeedsUpdate||this.dynamicCloud)&&(e.position.set(0,0,0),e.updateMatrixWorld(),i.position.set(0,0,0),i.updateMatrixWorld(),this.updateRealtimeEnvironment()),e.position.copy(t.rendering.camera.position),e.position.z-=0,i.position.copy(t.rendering.camera.position),this._skyNeedsUpdate=!1}updateLight(){if(super.updateLight(),this._lensflare){const t=this._sunDirection.z,e=this._sunDirection.x;let i=10*this.engine.map.getCameraDistance();if(t>.01&&this.sunLight.intensity>.1&&i<1e6){this._lensflare.visible=!0;const[n,r]=this.engine.map.getProjectionCenter();this._lensflare.position.set(n+e*i,r,t*i)}else this._lensflare.visible=!1}}onTimeChanged(t){this._skyAtomsphere.altitude=(t/86400-.25)*Math.PI*2,this._skyNeedsUpdate=!0}getTextures(){return this._envMapType===2?[this._envRenderTarget1.texture,this._envRenderTarget2.texture]:[]}get cloudIntensity(){return this._cloud.coverage}set cloudIntensity(t){this._cloud.coverage=t,this._skyNeedsUpdate=!0}get mixGrayFactor(){return this._skyAtomsphere.mixGrayFactor}set mixGrayFactor(t){this._skyAtomsphere.mixGrayFactor=t,this._cloud.mixGrayFactor=t,this._skyNeedsUpdate=!0}get realtimeCapture(){return this._realtimeCapture}set realtimeCapture(t){t!==this._realtimeCapture&&(console.warn("has not been supported"),this._skyNeedsUpdate=!0,this._realtimeCapture=t)}get clipUnderground(){return!1}set clipUnderground(t){console.warn("has not been supported")}beforeRemoveFromEngine(t){this.disposeEnvRenderTarget(this._realtimeCapture)}dispose(){super.dispose()}}class lM extends Fr{constructor(t={}){super(),d(this,"isSphereSky",!0),d(this,"_textureIsCube",!1),d(this,"_textureIsHDR",!1),d(this,"_textureURL",null),d(this,"_textureNames",null),d(this,"_affectWorld",!0),d(this,"_isVerticalTexture",null),d(this,"_mesh",null),d(this,"_material",null),d(this,"_sphereGeometry",null),d(this,"_engine",null),t.texture}afterAddToEngine(t){this._engine=t,super.afterAddToEngine(t);const e=this._sphereGeometry=new Os(1,32,32),i=this._material=this.createMaterial(),n=this._mesh=new lt(e,i);n.frustumCulled=!1,n.scale.setScalar(1e4),n.rotateX(Math.PI/2),n.renderOrder=-1e4,this.add(n)}createMaterial(){return new ae}onBeforeScenePrepareRender(t,e,i){this._mesh.position.copy(i.position),super.onBeforeScenePrepareRender(t)}}const hM={gradients:{value:[{stop:0,color:new tt(1/255,1/255,1/255)},{stop:.01,color:new tt(41/255/4,53/255/4,93/255/4)},{stop:.03,color:new tt(41/255/8,53/255/8,93/255/8)},{stop:.09,color:new tt(41/255/32,53/255/32,93/255/32)},{stop:.15,color:new tt(1/255,1/255,1/255)}]},isEmissive:{value:!1}};class cM extends Zt{constructor(t){super(),this.defines={NUM_COLORS:5},this.uniforms=pt.clone(hM),this.side=ce,this.vertexShader=`#define GLSLIFY 1
varying vec2 vUv;
varying float vZ;

void main()
{
    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);
    vUv = uv;
    vZ = position.y;
    gl_Position = projectionMatrix * viewPos;
    gl_Position.z = gl_Position.w;
}
`,this.fragmentShader=`#define GLSLIFY 1
#include <common>
varying vec2 vUv;
varying float vZ;
uniform float zBottom;
uniform float zTop;
struct ColorStop {
    float stop;
    vec3 color;
};
uniform ColorStop gradients[NUM_COLORS];

void main() {

    // float v = 0.01;
    // if (vZ >= zTop) {
    //     v = 0.98;
    // }
    // else if (vZ > zBottom) {
    //     v = (vZ - zBottom) / (zTop - zBottom);
    // }
    // gl_FragColor = texture2D(map, vec2(0.5, vZ > 0. ? vZ * 2.0 : 0.));

    vec3 outColor;
    int last = NUM_COLORS - 1;
    if (vZ <= gradients[0].stop) {
        outColor = gradients[0].color;
    }
    else if (vZ >= gradients[last].stop) {
        outColor = gradients[last].color;
    }
    else {
        float startRatio;
        float endRatio;
        for (int i = 1; i < NUM_COLORS; i++) {
            endRatio = gradients[i].stop;
            if (vZ < endRatio) {
                startRatio = gradients[i - 1].stop;
                outColor = mix(gradients[i - 1].color, gradients[i].color, (vZ - startRatio) / (endRatio - startRatio));
                break;
            }
        }
    }
   
    gl_FragColor = vec4(outColor, 1.0);
    #include <encodings_fragment>
}
`,this.depthWrite=!1,this.depthTest=!1,this.envMap=null,jt(this,["isEmissive"])}get gradients(){return this.uniforms.gradients.value}set gradients(t){(!Array.isArray(t)||t.length<2)&&console.warn("gradient must be an array and the length of gradients must be greater than 1"),this.defines.NUM_COLORS=t.length,t.sort((e,i)=>e.stop<i.stop),this.uniforms.gradients.value=t}}class Ul{constructor(){this.name="",this.minZoom=0,this.maxZoom=20,this.bounds=[],this.center=[]}fetchTile(t,e,i){return null}getMetaData(){}}class uM extends Ul{constructor(t="https://a.tile.openstreetmap.org/"){super(),this.address=t,this.format="png"}fetchTile(t,e,i){return new Promise((n,r)=>{const a=document.createElement("img");a.onload=function(){n(a)},a.onerror=function(){r()},a.crossOrigin="Anonymous",a.src=this.address+t+"/"+e+"/"+i+"."+this.format})}}class Qi extends Pt{constructor(t=1,e=1,i=1,n=1,r=!1,a=10){super();const o=[],l=[],h=[],c=[];Qi.buildPlane(t,e,i,n,o,l,h,c),r&&Qi.buildSkirt(t,e,i,n,a,o,l,h,c),this.setIndex(o),this.setAttribute("position",new et(l,3)),this.setAttribute("normal",new et(h,3)),this.setAttribute("uv",new et(c,2))}static buildPlane(t=1,e=1,i=1,n=1,r,a,o,l){const h=t/2,c=e/2,u=i+1,p=n+1,m=t/i,f=e/n;for(let g=0;g<p;g++){const _=g*f-c;for(let v=0;v<u;v++){const x=v*m-h;a.push(x,0,_),o.push(0,1,0),l.push(v/i,1-g/n)}}for(let g=0;g<n;g++)for(let _=0;_<i;_++){const v=_+u*g,x=_+u*(g+1),y=_+1+u*(g+1),b=_+1+u*g;r.push(v,x,b,x,y,b)}}static buildSkirt(t=1,e=1,i=1,n=1,r,a,o,l,h){const c=t/2,u=e/2,p=i+1,m=n+1,f=t/i,g=e/n;let _=o.length/3;for(let x=0;x<p;x++){const y=x*f-c,b=-u;o.push(y,-r,b),l.push(0,1,0),h.push(x/i,1)}for(let x=0;x<i;x++){const y=x,b=x+1,S=x+_,w=x+_+1;a.push(b,S,y,b,w,S)}_=o.length/3;for(let x=0;x<p;x++){const y=x*f-c,b=n*g-u;o.push(y,-r,b),l.push(0,1,0),h.push(x/i,0)}let v=p*m-i-1;for(let x=0;x<i;x++){const y=v+x,b=v+x+1,S=x+_,w=x+_+1;a.push(y,S,b,S,w,b)}_=o.length/3;for(let x=0;x<m;x++){const y=x*g-u,b=-c;o.push(b,-r,y),l.push(0,1,0),h.push(0,1-x/n)}for(let x=0;x<n;x++){const y=x*m,b=(x+1)*m,S=x+_,w=x+_+1;a.push(y,S,b,S,w,b)}_=o.length/3;for(let x=0;x<m;x++){const y=x*g-u,b=i*f-c;o.push(b,-r,y),l.push(0,1,0),h.push(1,1-x/n)}for(let x=0;x<n;x++){const y=x*m+n,b=(x+1)*m+n,S=x+_,w=x+_+1;a.push(b,S,y,b,w,S)}}}class hu{static createOffscreenCanvas(t,e){if(OffscreenCanvas)return new OffscreenCanvas(t,e);{let i=document.createElement("canvas");return i.width=t,i.height=e,i}}}class zt extends lt{constructor(t=null,e=null,i=zt.root,n=0,r=0,a=0,o=null,l=null){super(o,l),this.mapView=null,this.parentNode=null,this.nodesLoaded=0,this.subdivided=!1,this.childrenCache=null,this.cacheChild=!1,this.isMesh=!0,this.mapView=e,this.parentNode=t,this.location=i,this.level=n,this.x=r,this.y=a,e.overrideMaterial&&(this.material=e.overrideMaterial,this.textureLoaded=!0),this.initialize()}initialize(){this.mapView.onNodeCreated&&this.mapView.onNodeCreated(this)}createChildNodes(){}subdivide(){const t=Math.min(this.mapView.provider.maxZoom,this.mapView.heightProvider.maxZoom);this.children.length>0||this.level+1>t||this.parentNode!==null&&this.parentNode.nodesLoaded<zt.childrens||(this.subdivided=!0,this.cacheChild&&this.childrenCache!==null?(this.isMesh=!1,this.children=this.childrenCache):this.createChildNodes(),this.mapView.onNodeSubdivided&&this.mapView.onNodeSubdivided())}simplify(){this.cacheChild&&this.children.length>0&&(this.childrenCache=this.children),this.subdivided=!1,this.isMesh=!0,this.children=[]}loadTexture(){this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new ne(t);e.generateMipmaps=!1,e.format=$t,e.magFilter=Wt,e.minFilter=Wt,e.needsUpdate=!0,this.material.map=e,this.nodeReady()}).catch(()=>{const t=hu.createOffscreenCanvas(1,1),e=t.getContext("2d");e.fillStyle="#FF0000",e.fillRect(0,0,1,1);const i=new ne(t);i.generateMipmaps=!1,i.needsUpdate=!0,this.material.map=i,this.nodeReady()})}nodeReady(){if(this.parentNode!==null){if(this.parentNode.nodesLoaded++,this.parentNode.nodesLoaded>=zt.childrens){this.parentNode.subdivided===!0&&(this.parentNode.isMesh=!1);for(let t=0;t<this.parentNode.children.length;t++)this.parentNode.children[t].visible=!0}}else this.visible=!0;this.mapView.onNodeReady&&this.mapView.onNodeReady()}getNeighborsDirection(t){return null}getNeighbors(){return[]}}zt.baseGeometry=null,zt.baseScale=null,zt.childrens=4,zt.root=-1,zt.topLeft=0,zt.topRight=1,zt.bottomLeft=2,zt.bottomRight=3;class fe{static get(t,e){navigator.geolocation.getCurrentPosition(function(i){t(i.coords,i.timestamp)},e)}static datumsToSpherical(t,e){const i=e*fe.EARTH_ORIGIN/180;let n=Math.log(Math.tan((90+t)*Math.PI/360))/(Math.PI/180);return n=n*fe.EARTH_ORIGIN/180,new j(i,n)}static sphericalToDatums(t,e){const i=t/fe.EARTH_ORIGIN*180;let n=e/fe.EARTH_ORIGIN*180;return n=180/Math.PI*(2*Math.atan(Math.exp(n*Math.PI/180))-Math.PI/2),{latitude:n,longitude:i}}static quadtreeToDatums(t,e,i){const n=Math.pow(2,t),r=e/n*360-180;return{latitude:Math.atan(Math.sinh(Math.PI*(1-2*i/n)))/Math.PI*180,longitude:r}}}fe.EARTH_RADIUS=6378137,fe.EARTH_PERIMETER=2*Math.PI*fe.EARTH_RADIUS,fe.EARTH_ORIGIN=fe.EARTH_PERIMETER/2;class Fi extends zt{constructor(t=null,e=null,i=zt.root,n=0,r=0,a=0){super(t,e,i,n,r,a,Fi.geometry,new ae({wireframe:!1})),this.matrixAutoUpdate=!1,this.isMesh=!0,this.visible=!1}initialize(){super.initialize(),this.loadTexture()}createChildNodes(){const t=this.level+1,e=2*this.x,i=2*this.y,n=Object.getPrototypeOf(this).constructor;let r=new n(this,this.mapView,zt.topLeft,t,e,i);r.scale.set(.5,1,.5),r.position.set(-.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new n(this,this.mapView,zt.topRight,t,e+1,i),r.scale.set(.5,1,.5),r.position.set(.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new n(this,this.mapView,zt.bottomLeft,t,e,i+1),r.scale.set(.5,1,.5),r.position.set(-.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new n(this,this.mapView,zt.bottomRight,t,e+1,i+1),r.scale.set(.5,1,.5),r.position.set(.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0)}raycast(t,e){return this.isMesh===!0&&super.raycast(t,e)}}Fi.geometry=new Qi(1,1,1,1,!1),Fi.baseGeometry=Fi.geometry,Fi.baseScale=new M(fe.EARTH_PERIMETER,1,fe.EARTH_PERIMETER);class Kf extends Pt{constructor(t=1,e=1,i=1,n=1,r=!1,a=10,o=null,l=!0){super();const h=[],c=[],u=[],p=[];Qi.buildPlane(t,e,i,n,h,c,u,p);const m=o.data;for(let f=0,g=0;f<m.length&&g<c.length;f+=4,g+=3){const _=m[f],v=m[f+1],x=m[f+2];if(_===0&&v===0&&x===0)c[g+1]=0;else{const y=.1*(65536*_+256*v+x)-1e4;c[g+1]=y}}r&&Qi.buildSkirt(t,e,i,n,a,h,c,u,p),this.setIndex(h),this.setAttribute("position",new et(c,3)),this.setAttribute("normal",new et(u,3)),this.setAttribute("uv",new et(p,2)),l&&this.computeNormals(i,n)}computeNormals(t,e){const i=this.getAttribute("position");if(i!==void 0){let n=this.getAttribute("normal");const r=e*t;for(let g=0;g<r;g++)n.setXYZ(g,0,0,0);const a=new M,o=new M,l=new M,h=new M,c=new M,u=new M,p=new M,m=new M,f=e*t*6;for(let g=0;g<f;g+=3){const _=this.index.getX(g+0),v=this.index.getX(g+1),x=this.index.getX(g+2);a.fromBufferAttribute(i,_),o.fromBufferAttribute(i,v),l.fromBufferAttribute(i,x),p.subVectors(l,o),m.subVectors(a,o),p.cross(m),h.fromBufferAttribute(n,_),c.fromBufferAttribute(n,v),u.fromBufferAttribute(n,x),h.add(p),c.add(p),u.add(p),n.setXYZ(_,h.x,h.y,h.z),n.setXYZ(v,c.x,c.y,c.z),n.setXYZ(x,u.x,u.y,u.z)}this.normalizeNormals(),n.needsUpdate=!0}}}class Bi extends zt{constructor(t=null,e=null,i=zt.root,n=0,r=0,a=0,o=Bi.geometry,l=new yn({wireframe:!1,color:16777215})){super(t,e,i,n,r,a,o,l),this.heightLoaded=!1,this.geometrySize=16,this.geometryNormals=!1,l.alphaTest=.1,this.isMesh=!0,this.visible=!1,this.matrixAutoUpdate=!1}initialize(){super.initialize(),this.textureLoaded?setTimeout(()=>{this.textureLoaded=!0},0):this.loadTexture(),this.loadHeightGeometry()}loadTexture(){this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new ne(t);e.generateMipmaps=!1,e.format=$t,e.magFilter=Wt,e.minFilter=Wt,e.needsUpdate=!0,this.material.map=e}).catch(()=>{console.log("texture error")}).finally(()=>{this.textureLoaded=!0,this.nodeReady()})}nodeReady(){this.heightLoaded&&this.textureLoaded&&(this.visible=!0,super.nodeReady())}createChildNodes(){const t=this.level+1,e=Object.getPrototypeOf(this).constructor,i=2*this.x,n=2*this.y;let r=new e(this,this.mapView,zt.topLeft,t,i,n);r.scale.set(.5,1,.5),r.position.set(-.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,zt.topRight,t,i+1,n),r.scale.set(.5,1,.5),r.position.set(.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,zt.bottomLeft,t,i,n+1),r.scale.set(.5,1,.5),r.position.set(-.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,zt.bottomRight,t,i+1,n+1),r.scale.set(.5,1,.5),r.position.set(.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0)}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(t=>{const e=hu.createOffscreenCanvas(this.geometrySize+1,this.geometrySize+1),i=e.getContext("2d");i.imageSmoothingEnabled=!1,i.drawImage(t,0,0,Bi.tileSize,Bi.tileSize,0,0,e.width,e.height);const n=i.getImageData(0,0,e.width,e.height),r=new Kf(1,1,this.geometrySize,this.geometrySize,!0,10,n,!0);this.geometry=r}).catch(()=>{}).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}raycast(t,e){return this.isMesh===!0&&super.raycast(t,e)}}Bi.tileSize=256,Bi.geometry=new Qi(1,1,1,1),Bi.baseGeometry=Fi.geometry,Bi.baseScale=new M(fe.EARTH_PERIMETER,1,fe.EARTH_PERIMETER);class Qf extends Pt{constructor(t,e,i,n,r,a,o){super();const l=a+o;let h=0;const c=[],u=new M,p=new M,m=[],f=[],g=[],_=[];for(let v=0;v<=i;v++){const x=[],y=v/i;for(let b=0;b<=e;b++){const S=b/e;u.x=-t*Math.cos(n+S*r)*Math.sin(a+y*o),u.y=t*Math.cos(a+y*o),u.z=t*Math.sin(n+S*r)*Math.sin(a+y*o),f.push(u.x,u.y,u.z),p.set(u.x,u.y,u.z).normalize(),g.push(p.x,p.y,p.z),_.push(S,1-y),x.push(h++)}c.push(x)}for(let v=0;v<i;v++)for(let x=0;x<e;x++){const y=c[v][x+1],b=c[v][x],S=c[v+1][x],w=c[v+1][x+1];(v!==0||a>0)&&m.push(y,b,w),(v!==i-1||l<Math.PI)&&m.push(b,S,w)}this.setIndex(m),this.setAttribute("position",new et(f,3)),this.setAttribute("normal",new et(g,3)),this.setAttribute("uv",new et(_,2))}}class Ys extends zt{constructor(t=null,e=null,i=zt.root,n=0,r=0,a=0){super(t,e,i,n,r,a,Ys.createGeometry(n,r,a),new ae({wireframe:!1})),this.applyScaleNode(),this.matrixAutoUpdate=!1,this.isMesh=!0,this.visible=!1}initialize(){super.initialize(),this.loadTexture()}static createGeometry(t,e,i){const n=Math.pow(2,t),r=Math.floor(Ys.segments*(40/(t+1))/40),a=1/n*2*Math.PI,o=e*a,l=1/n*Math.PI;return new Qf(1,r,r,o,a,i*l,l)}applyScaleNode(){this.geometry.computeBoundingBox();const t=this.geometry.boundingBox.clone().getCenter(new M),e=new rt;e.compose(new M(-t.x,-t.y,-t.z),new Ht,new M(fe.EARTH_RADIUS,fe.EARTH_RADIUS,fe.EARTH_RADIUS)),this.geometry.applyMatrix4(e),this.position.copy(t),this.updateMatrix(),this.updateMatrixWorld()}updateMatrix(){this.matrix.setPosition(this.position),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t=!1){(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1)}createChildNodes(){const t=this.level+1,e=2*this.x,i=2*this.y,n=Object.getPrototypeOf(this).constructor;let r=new n(this,this.mapView,zt.topLeft,t,e,i);this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new n(this,this.mapView,zt.topRight,t,e+1,i),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new n(this,this.mapView,zt.bottomLeft,t,e,i+1),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new n(this,this.mapView,zt.bottomRight,t,e+1,i+1),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0)}raycast(t,e){return this.isMesh===!0&&super.raycast(t,e)}}Ys.baseGeometry=new Qf(fe.EARTH_RADIUS,64,64,0,2*Math.PI,0,Math.PI),Ys.baseScale=new M(1,1,1),Ys.segments=80;class ei extends Bi{constructor(t=null,e=null,i=zt.root,n=0,r=0,a=0){const o=ei.prepareMaterial(new fc({map:ei.emptyTexture,color:16777215}));super(t,e,i,n,r,a,ei.geometry,o),this.frustumCulled=!1}static prepareMaterial(t){return t.userData={heightMap:{value:ei.emptyTexture}},t.onBeforeCompile=e=>{for(const i in t.userData)e.uniforms[i]=t.userData[i];e.vertexShader=`
			uniform sampler2D heightMap;
			`+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <fog_vertex>",`
			#include <fog_vertex>
	
			// Calculate height of the title
			vec4 _theight = texture2D(heightMap, vUv);
			float _height = ((_theight.r * 255.0 * 65536.0 + _theight.g * 255.0 * 256.0 + _theight.b * 255.0) * 0.1) - 10000.0;
			vec3 _transformed = position + _height * normal;
	
			// Vertex position based on height
			gl_Position = projectionMatrix * modelViewMatrix * vec4(_transformed, 1.0);
			`)},t}loadTexture(){this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new ne(t);e.generateMipmaps=!1,e.format=$t,e.magFilter=Wt,e.minFilter=Wt,e.needsUpdate=!0,this.material.map=e,this.textureLoaded=!0,this.nodeReady()}).catch(t=>{console.error("GeoThree: Failed to load color node data.",t)}).finally(()=>{this.textureLoaded=!0,this.nodeReady()}),this.loadHeightGeometry()}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new ne(t);e.generateMipmaps=!1,e.format=$t,e.magFilter=Ft,e.minFilter=Ft,e.needsUpdate=!0,this.material.userData.heightMap.value=e}).catch(t=>{console.error("GeoThree: Failed to load height node data.",t)}).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}raycast(t,e){if(this.isMesh===!0){this.geometry=Fi.geometry;const i=super.raycast(t,e);return this.geometry=ei.geometry,i}return!1}}ei.emptyTexture=new ne,ei.geometrySize=256,ei.geometry=new Qi(1,1,ei.geometrySize,ei.geometrySize,!0),ei.baseGeometry=Fi.geometry,ei.baseScale=new M(fe.EARTH_PERIMETER,1,fe.EARTH_PERIMETER);const $f=new M,tg=new M;class dM{constructor(){this.subdivideDistance=50,this.simplifyDistance=300}updateLOD(t,e,i,n){e.getWorldPosition($f),t.children[0].traverse(r=>{r.getWorldPosition(tg);let a=$f.distanceTo(tg);a/=Math.pow(2,t.provider.maxZoom-r.level),a<this.subdivideDistance?r.subdivide():a>this.simplifyDistance&&r.parentNode&&r.parentNode.simplify()})}}const eg=new rt,ig=new M,cu=new Pa,uu=new M;class pM extends dM{constructor(){super(...arguments),this.subdivideDistance=120,this.simplifyDistance=400,this.testCenter=!0,this.pointOnly=!1,this.lodOffset=0}updateLOD(t,e,i,n){eg.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),cu.setFromProjectionMatrix(eg),e.getWorldPosition(ig),t.children[0].traverse(r=>{r.getWorldPosition(uu);let a=ig.distanceTo(uu);a/=Math.pow(2,t.provider.maxZoom-r.level+this.lodOffset);const o=this.pointOnly?cu.containsPoint(uu):cu.intersectsObject(r);a<this.subdivideDistance&&o?r.subdivide():a>this.simplifyDistance&&r.parentNode&&r.parentNode.simplify()})}}/*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */function ng(s,t,e,i){return new(e||(e=Promise))(function(n,r){function a(h){try{l(i.next(h))}catch(c){r(c)}}function o(h){try{l(i.throw(h))}catch(c){r(c)}}function l(h){var c;h.done?n(h.value):(c=h.value,c instanceof e?c:new e(function(u){u(c)})).then(a,o)}l((i=i.apply(s,[])).next())})}class mM{constructor(t=257){this.gridSize=t;const e=t-1;if(e&e-1)throw new Error(`Expected grid size to be 2^n+1, got ${t}.`);this.numTriangles=e*e*2-2,this.numParentTriangles=this.numTriangles-e*e,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let i=0;i<this.numTriangles;i++){let n=i+2,r=0,a=0,o=0,l=0,h=0,c=0;for(1&n?o=l=h=e:r=a=c=e;(n>>=1)>1;){const p=r+o>>1,m=a+l>>1;1&n?(o=r,l=a,r=h,a=c):(r=o,a=l,o=h,l=c),h=p,c=m}const u=4*i;this.coords[u+0]=r,this.coords[u+1]=a,this.coords[u+2]=o,this.coords[u+3]=l}}createTile(t){return new fM(t,this)}}class fM{constructor(t,e){const i=e.gridSize;if(t.length!==i*i)throw new Error(`Expected terrain data of length ${i*i} (${i} x ${i}), got ${t.length}.`);this.terrain=t,this.martini=e,this.errors=new Float32Array(t.length),this.update()}update(){const{numTriangles:t,numParentTriangles:e,coords:i,gridSize:n}=this.martini,{terrain:r,errors:a}=this;for(let o=t-1;o>=0;o--){const l=4*o,h=i[l+0],c=i[l+1],u=i[l+2],p=i[l+3],m=h+u>>1,f=c+p>>1,g=m+f-c,_=f+h-m,v=(r[c*n+h]+r[p*n+u])/2,x=f*n+m,y=Math.abs(v-r[x]);if(a[x]=Math.max(a[x],y),o<e){const b=(c+_>>1)*n+(h+g>>1),S=(p+_>>1)*n+(u+g>>1);a[x]=Math.max(a[x],a[b],a[S])}}}getMesh(t=0,e=!1){const{gridSize:i,indices:n}=this.martini,{errors:r}=this;let a=0,o=0;const l=i-1;let h,c,u=0;const p=[],m=[],f=[],g=[];function _(C,L,T,E,I,z){const B=C+T>>1,O=L+E>>1;Math.abs(C-I)+Math.abs(L-z)>1&&r[O*i+B]>t?(_(I,z,C,L,B,O),_(T,E,I,z,B,O)):(h=L*i+C,c=E*i+T,u=z*i+I,n[h]===0&&(e&&(C===0?p.push(a):C===l&&m.push(a),L===0?f.push(a):L===l&&g.push(a)),n[h]=++a),n[c]===0&&(e&&(T===0?p.push(a):T===l&&m.push(a),E===0?f.push(a):E===l&&g.push(a)),n[c]=++a),n[u]===0&&(e&&(I===0?p.push(a):I===l&&m.push(a),z===0?f.push(a):z===l&&g.push(a)),n[u]=++a),o++)}n.fill(0),_(0,0,l,l,l,0),_(l,l,0,0,0,l);let v=2*a,x=3*o;e&&(v+=2*(p.length+m.length+f.length+g.length),x+=3*(2*(p.length-1)+2*(m.length-1)+2*(f.length-1)+2*(g.length-1)));const y=new Uint16Array(v),b=new Uint32Array(x);let S=0;function w(C,L,T,E,I,z){const B=C+T>>1,O=L+E>>1;if(Math.abs(C-I)+Math.abs(L-z)>1&&r[O*i+B]>t)w(I,z,C,L,B,O),w(T,E,I,z,B,O);else{const F=n[L*i+C]-1,Q=n[E*i+T]-1,k=n[z*i+I]-1;y[2*F]=C,y[2*F+1]=L,y[2*Q]=T,y[2*Q+1]=E,y[2*k]=I,y[2*k+1]=z,b[S++]=F,b[S++]=Q,b[S++]=k}}if(w(0,0,l,l,l,0),w(l,l,0,0,0,l),e){let C=function(T){const E=T.length;for(let I=0;I<E-1;I++){const z=T[I],B=T[I+1],O=L/2,F=(L+2)/2;y[L++]=y[2*z],y[L++]=y[2*z+1],b[S++]=z,b[S++]=O,b[S++]=B,b[S++]=O,b[S++]=F,b[S++]=B}y[L++]=y[2*T[E-1]],y[L++]=y[2*T[E-1]+1]};p.sort((T,E)=>y[2*T+1]-y[2*E+1]),m.sort((T,E)=>y[2*E+1]-y[2*T+1]),f.sort((T,E)=>y[2*E]-y[2*T]),g.sort((T,E)=>y[2*T]-y[2*E]);let L=2*a;C(p),C(m),C(f),C(g)}return{vertices:y,triangles:b,numVerticesWithoutSkirts:a}}}class yi extends Bi{constructor(t=null,e=null,i=zt.root,n=0,r=0,a=0,{elevationDecoder:o=null,meshMaxError:l=10,exageration:h=1}={}){super(t,e,i,n,r,a,yi.geometry,yi.prepareMaterial(new fc({map:yi.emptyTexture,color:16777215,side:ce}),n,h)),this.elevationDecoder={rScaler:256,gScaler:1,bScaler:1/256,offset:-32768},this.exageration=1,this.meshMaxError=10,o&&(this.elevationDecoder=o),this.meshMaxError=l,this.exageration=h,this.frustumCulled=!1}static prepareMaterial(t,e,i=1){return t.userData={heightMap:{value:yi.emptyTexture},drawNormals:{value:0},drawBlack:{value:0},zoomlevel:{value:e},computeNormals:{value:1},drawTexture:{value:1}},t.onBeforeCompile=n=>{for(let r in t.userData)n.uniforms[r]=t.userData[r];n.vertexShader=`
				uniform bool computeNormals;
				uniform float zoomlevel;
				uniform sampler2D heightMap;
				`+n.vertexShader,n.fragmentShader=`
				uniform bool drawNormals;
				uniform bool drawTexture;
				uniform bool drawBlack;
				`+n.fragmentShader,n.fragmentShader=n.fragmentShader.replace("#include <dithering_fragment>",`
				if(drawBlack) {
					gl_FragColor = vec4( 0.0,0.0,0.0, 1.0 );
				} else if(drawNormals) {
					gl_FragColor = vec4( ( 0.5 * vNormal + 0.5 ), 1.0 );
				} else if (!drawTexture) {
					gl_FragColor = vec4( 0.0,0.0,0.0, 0.0 );
				}`),n.vertexShader=n.vertexShader.replace("#include <fog_vertex>",`
				#include <fog_vertex>

				// queried pixels:
				// +-----------+
				// |   |   |   |
				// | a | b | c |
				// |   |   |   |
				// +-----------+
				// |   |   |   |
				// | d | e | f |
				// |   |   |   |
				// +-----------+
				// |   |   |   |
				// | g | h | i |
				// |   |   |   |
				// +-----------+

				if (computeNormals) {
					float e = getElevation(vUv, 0.0);
					ivec2 size = textureSize(heightMap, 0);
					float offset = 1.0 / float(size.x);
					float a = getElevation(vUv + vec2(-offset, -offset), 0.0);
					float b = getElevation(vUv + vec2(0, -offset), 0.0);
					float c = getElevation(vUv + vec2(offset, -offset), 0.0);
					float d = getElevation(vUv + vec2(-offset, 0), 0.0);
					float f = getElevation(vUv + vec2(offset, 0), 0.0);
					float g = getElevation(vUv + vec2(-offset, offset), 0.0);
					float h = getElevation(vUv + vec2(0, offset), 0.0);
					float i = getElevation(vUv + vec2(offset,offset), 0.0);


					float normalLength = 500.0 / zoomlevel;

					vec3 v0 = vec3(0.0, 0.0, 0.0);
					vec3 v1 = vec3(0.0, normalLength, 0.0);
					vec3 v2 = vec3(normalLength, 0.0, 0.0);
					v0.z = (e + d + g + h) / 4.0;
					v1.z = (e+ b + a + d) / 4.0;
					v2.z = (e+ h + i + f) / 4.0;
					vNormal = (normalize(cross(v2 - v0, v1 - v0))).rbg;
				}
				`)},t}static getTerrain(t,e,i){const{rScaler:n,bScaler:r,gScaler:a,offset:o}=i,l=e+1,h=new Float32Array(l*l);for(let c=0,u=0;u<e;u++)for(let p=0;p<e;p++,c++){const m=4*c,f=t[m+0],g=t[m+1],_=t[m+2];h[c+u]=f*n+g*a+_*r+o}for(let c=l*(l-1),u=0;u<l-1;u++,c++)h[c]=h[c-l];for(let c=l-1,u=0;u<l;u++,c+=l)h[c]=h[c-1];return h}static getMeshAttributes(t,e,i,n,r){const a=i+1,o=t.length/2,l=new Float32Array(3*o),h=new Float32Array(2*o),[c,u,p,m]=n||[0,0,i,i],f=(p-c)/i,g=(m-u)/i;for(let _=0;_<o;_++){const v=t[2*_],x=t[2*_+1],y=x*a+v;l[3*_+0]=v*f+c,l[3*_+1]=-e[y]*r,l[3*_+2]=-x*g+m,h[2*_+0]=v/i,h[2*_+1]=x/i}return{position:{value:l,size:3},uv:{value:h,size:2}}}onHeightImage(t){return ng(this,void 0,void 0,function*(){const e=t.width,i=e+1;var n=hu.createOffscreenCanvas(e,e),r=n.getContext("2d");r.imageSmoothingEnabled=!1,r.drawImage(t,0,0,e,e,0,0,n.width,n.height);var a=r.getImageData(0,0,n.width,n.height).data;const o=yi.getTerrain(a,e,this.elevationDecoder),l=new mM(i).createTile(o),{vertices:h,triangles:c}=l.getMesh(typeof this.meshMaxError=="function"?this.meshMaxError(this.level):this.meshMaxError),u=yi.getMeshAttributes(h,o,e,[-.5,-.5,.5,.5],this.exageration);this.geometry=new Pt,this.geometry.setIndex(new Zh(c,1)),this.geometry.setAttribute("position",new et(u.position.value,u.position.size)),this.geometry.setAttribute("uv",new et(u.uv.value,u.uv.size)),this.geometry.rotateX(Math.PI);var p=new ne(t);p.generateMipmaps=!1,p.format=$t,p.magFilter=Ft,p.minFilter=Ft,p.needsUpdate=!0,this.material.userData.heightMap.value=p})}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(t=>ng(this,void 0,void 0,function*(){this.onHeightImage(t)})).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}}yi.geometrySize=16,yi.emptyTexture=new ne,yi.geometry=new Qi(1,1,1,1),yi.tileSize=256;class Zs extends zt{constructor(t=null,e=null,i=zt.root,n=0,r=0,a=0,o=Zs.geometry,l=new yn({wireframe:!1,color:16777215})){super(t,e,i,n,r,a,o,l),this.heightLoaded=!1,this.textureLoaded=!1,this.geometrySize=16,this.geometryNormals=!1,this.isMesh=!0,this.visible=!1,this.matrixAutoUpdate=!1}initialize(){super.initialize(),this.loadTexture(),this.loadHeightGeometry()}loadTexture(){this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new ne(t);e.generateMipmaps=!1,e.format=$t,e.magFilter=Wt,e.minFilter=Wt,e.needsUpdate=!0,this.material.map=e}).finally(()=>{this.textureLoaded=!0,this.nodeReady()})}nodeReady(){this.heightLoaded&&this.textureLoaded&&(this.visible=!0,super.nodeReady())}createChildNodes(){const t=this.level+1,e=Object.getPrototypeOf(this).constructor,i=2*this.x,n=2*this.y;let r=new e(this,this.mapView,zt.topLeft,t,i,n);r.scale.set(.5,1,.5),r.position.set(-.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,zt.topRight,t,i+1,n),r.scale.set(.5,1,.5),r.position.set(.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,zt.bottomLeft,t,i,n+1),r.scale.set(.5,1,.5),r.position.set(-.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,zt.bottomRight,t,i+1,n+1),r.scale.set(.5,1,.5),r.position.set(.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0)}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new Kf(1,1,this.geometrySize,this.geometrySize,!0,10,imageData,!0);this.geometry=e}).catch(()=>{console.error("GeoThree: Failed to load height node data.",this)}).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}raycast(t,e){return this.isMesh===!0&&super.raycast(t,e)}}Zs.tileSize=256,Zs.geometry=new Qi(1,1,1,1),Zs.baseGeometry=Fi.geometry,Zs.baseScale=new M(fe.EARTH_PERIMETER,1,fe.EARTH_PERIMETER);class Se extends lt{constructor(t=Se.PLANAR,e=new uM,i=null,n=null){super(void 0,new ae({transparent:!0,opacity:0})),this.lod=null,this.onNodeReady=null,this.provider=null,this.heightProvider=null,this.root=null,this.overrideMaterial=n,this.lod=new pM,this.provider=e,this.heightProvider=i,this.setRoot(t)}update(t,e,i){this.lod.updateLOD(this,t,e,i)}setRoot(t){if(typeof t=="number"){if(!Se.mapModes.has(t))throw new Error("Map mode "+t+" does is not registered.");t=new(Se.mapModes.get(t))(null,this)}this.root!==null&&(this.remove(this.root),this.root=null),this.root=t,this.root!==null&&(this.geometry=this.root.constructor.baseGeometry,this.scale.copy(this.root.constructor.baseScale),this.root.mapView=this,this.add(this.root))}setProvider(t){t!==this.provider&&(this.provider=t,this.clear())}setHeightProvider(t){t!==this.heightProvider&&(this.heightProvider=t,this.clear())}clear(){return this.traverse(function(t){t.childrenCache&&(t.childrenCache=null),t.initialize&&t.initialize()}),this}getMetaData(){this.provider.getMetaData()}raycast(t,e){return!1}}Se.PLANAR=200,Se.SPHERICAL=201,Se.HEIGHT=202,Se.HEIGHT_SHADER=203,Se.MARTINI=204,Se.TERRAIN=205,Se.mapModes=new Map([[Se.PLANAR,Fi],[Se.SPHERICAL,Ys],[Se.HEIGHT,Bi],[Se.HEIGHT_SHADER,ei],[Se.MARTINI,yi],[Se.TERRAIN,Zs]]);class sg{static get(t,e,i){const n=new XMLHttpRequest;return n.overrideMimeType("text/plain"),n.open("GET",t,!0),e!==void 0&&(n.onload=function(){e(n.response)}),i!==void 0&&(n.onerror=i),n.send(null),n}static getRaw(t,e,i){var n=new XMLHttpRequest;return n.responseType="arraybuffer",n.open("GET",t,!0),e!==void 0&&(n.onload=function(){e(n.response)}),i!==void 0&&(n.onerror=i),n.send(null),n}static request(t,e,i,n,r,a,o){const l=new XMLHttpRequest;if(l.overrideMimeType("text/plain"),l.open(e,t,!0),i!=null)for(const h in i)l.setRequestHeader(h,i[h]);return r!==void 0&&(l.onload=function(h){r(function(c){try{return JSON.parse(c)}catch{return c}}(l.response),l)}),a!==void 0&&(l.onerror=a),o!==void 0&&(l.onprogress=o),n!==void 0?l.send(n):l.send(null),l}}class Pn extends Ul{constructor(t="",e=Pn.AERIAL){super(),this.maxZoom=19,this.format="jpeg",this.mapSize=512,this.subdomain="t1",this.apiKey=t,this.type=e}getMetaData(){const t="http://dev.virtualearth.net/REST/V1/Imagery/Metadata/RoadOnDemand?output=json&include=ImageryProviders&key="+this.apiKey;sg.get(t,function(e){JSON.parse(e)})}static quadKey(t,e,i){let n="";for(let r=t;r>0;r--){const a=1<<r-1;let o=0;e&a&&o++,i&a&&(o+=2),n+=o}return n}fetchTile(t,e,i){return new Promise((n,r)=>{const a=document.createElement("img");if(a.onload=function(){n(a)},a.onerror=function(){r()},a.crossOrigin="Anonymous",this.getUrl){const o=this.getUrl(t,e,i);if(o!==!1)return void(a.src=o)}a.src="http://ecn."+this.subdomain+".tiles.virtualearth.net/tiles/"+this.type+Pn.quadKey(t,e,i)+".jpeg?g=1173"})}}Pn.AERIAL="a",Pn.ROAD="r",Pn.AERIAL_LABELS="h",Pn.OBLIQUE="o",Pn.OBLIQUE_LABELS="b",(class extends Ul{constructor(s,t,e,i,n,r){super(),this.appId=s!==void 0?s:"",this.appCode=t!==void 0?t:"",this.style=e!==void 0?e:"base",this.scheme=i!==void 0?i:"normal.day",this.format=n!==void 0?n:"png",this.size=r!==void 0?r:512,this.version="newest",this.server=1}nextServer(){this.server=this.server%4==0?1:this.server+1}getMetaData(){}fetchTile(s,t,e){return this.nextServer(),new Promise((i,n)=>{const r=document.createElement("img");r.onload=function(){i(r)},r.onerror=function(){n()},r.crossOrigin="Anonymous",r.src="https://"+this.server+"."+this.style+".maps.api.here.com/maptile/2.1/maptile/"+this.version+"/"+this.scheme+"/"+s+"/"+t+"/"+e+"/"+this.size+"/"+this.format+"?app_id="+this.appId+"&app_code="+this.appCode})}}).PATH="/maptile/2.1/";class $i extends Ul{constructor(t="",e="",i=$i.STYLE,n="png",r=!1,a="v4"){super(),this.apiToken=t,this.format=n,this.useHDPI=r,this.mode=i,this.mapId=e,this.style=e,this.version=a}getMetaData(){const t=$i.ADDRESS+this.version+"/"+this.mapId+".json?access_token="+this.apiToken;sg.get(t,e=>{const i=JSON.parse(e);this.name=i.name,this.minZoom=i.minZoom,this.maxZoom=i.maxZoom,this.bounds=i.bounds,this.center=i.center})}fetchTile(t,e,i){return new Promise((n,r)=>{const a=document.createElement("img");if(a.onload=function(){n(a)},a.onerror=function(){r()},a.crossOrigin="Anonymous",this.getUrl){const o=this.getUrl(t,e,i);if(o!==!1)return void(a.src=o)}this.mode===$i.STYLE?a.src=$i.ADDRESS+"styles/v1/"+this.style+"/tiles/"+t+"/"+e+"/"+i+(this.useHDPI?"@2x?access_token=":"?access_token=")+this.apiToken:a.src=$i.ADDRESS+"v4/"+this.mapId+"/"+t+"/"+e+"/"+i+(this.useHDPI?"@2x.":".")+this.format+"?access_token="+this.apiToken})}}$i.ADDRESS="https://api.mapbox.com/",$i.STYLE=100,$i.MAP_ID=101;class gM{constructor(){d(this,"_retryTimes",3),d(this,"_queued",{}),d(this,"_cached",{})}async generate(t){return{}}async get(t){if(this._cached[t])return this._cached[t];let e=!1;this._queued[t]||(this._queued[t]=[],e=!0);const i=new Promise((r,a)=>{this._queued[t].push([r,a])}),n=this._queued[t];if(e){for(let r=0;r<this._retryTimes;r++)try{const a=await this.generate(t);this._cached[t]=a;for(const o of n)o[0](a);break}catch(a){console.warn(a)}for(const r of n)r[1]()}return i}get keys(){return Object.keys(this._cached)}}const _M=new ea,du={};function tn(s){if(typeof s!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(s))}function rg(s,t){for(var e,i="",n=0,r=-1,a=0,o=0;o<=s.length;++o){if(o<s.length)e=s.charCodeAt(o);else{if(e===47)break;e=47}if(e===47){if(!(r===o-1||a===1))if(r!==o-1&&a===2){if(i.length<2||n!==2||i.charCodeAt(i.length-1)!==46||i.charCodeAt(i.length-2)!==46){if(i.length>2){var l=i.lastIndexOf("/");if(l!==i.length-1){l===-1?(i="",n=0):n=(i=i.slice(0,l)).length-1-i.lastIndexOf("/"),r=o,a=0;continue}}else if(i.length===2||i.length===1){i="",n=0,r=o,a=0;continue}}t&&(i.length>0?i+="/..":i="..",n=2)}else i.length>0?i+="/"+s.slice(r+1,o):i=s.slice(r+1,o),n=o-r-1;r=o,a=0}else e===46&&a!==-1?++a:a=-1}return i}var na={resolve:function(){for(var s,t="",e=!1,i=arguments.length-1;i>=-1&&!e;i--){var n;i>=0?n=arguments[i]:(s===void 0&&(s=process.cwd()),n=s),tn(n),n.length!==0&&(t=n+"/"+t,e=n.charCodeAt(0)===47)}return t=rg(t,!e),e?t.length>0?"/"+t:"/":t.length>0?t:"."},normalize:function(s){if(tn(s),s.length===0)return".";var t=s.charCodeAt(0)===47,e=s.charCodeAt(s.length-1)===47;return(s=rg(s,!t)).length!==0||t||(s="."),s.length>0&&e&&(s+="/"),t?"/"+s:s},isAbsolute:function(s){return tn(s),s.length>0&&s.charCodeAt(0)===47},join:function(){if(arguments.length===0)return".";for(var s,t=0;t<arguments.length;++t){var e=arguments[t];tn(e),e.length>0&&(s===void 0?s=e:s+="/"+e)}return s===void 0?".":na.normalize(s)},relative:function(s,t){if(tn(s),tn(t),s===t||(s=na.resolve(s))===(t=na.resolve(t)))return"";for(var e=1;e<s.length&&s.charCodeAt(e)===47;++e);for(var i=s.length,n=i-e,r=1;r<t.length&&t.charCodeAt(r)===47;++r);for(var a=t.length-r,o=n<a?n:a,l=-1,h=0;h<=o;++h){if(h===o){if(a>o){if(t.charCodeAt(r+h)===47)return t.slice(r+h+1);if(h===0)return t.slice(r+h)}else n>o&&(s.charCodeAt(e+h)===47?l=h:h===0&&(l=0));break}var c=s.charCodeAt(e+h);if(c!==t.charCodeAt(r+h))break;c===47&&(l=h)}var u="";for(h=e+l+1;h<=i;++h)h!==i&&s.charCodeAt(h)!==47||(u.length===0?u+="..":u+="/..");return u.length>0?u+t.slice(r+l):(r+=l,t.charCodeAt(r)===47&&++r,t.slice(r))},_makeLong:function(s){return s},dirname:function(s){if(tn(s),s.length===0)return".";for(var t=s.charCodeAt(0),e=t===47,i=-1,n=!0,r=s.length-1;r>=1;--r)if((t=s.charCodeAt(r))===47){if(!n){i=r;break}}else n=!1;return i===-1?e?"/":".":e&&i===1?"//":s.slice(0,i)},basename:function(s,t){if(t!==void 0&&typeof t!="string")throw new TypeError('"ext" argument must be a string');tn(s);var e,i=0,n=-1,r=!0;if(t!==void 0&&t.length>0&&t.length<=s.length){if(t.length===s.length&&t===s)return"";var a=t.length-1,o=-1;for(e=s.length-1;e>=0;--e){var l=s.charCodeAt(e);if(l===47){if(!r){i=e+1;break}}else o===-1&&(r=!1,o=e+1),a>=0&&(l===t.charCodeAt(a)?--a==-1&&(n=e):(a=-1,n=o))}return i===n?n=o:n===-1&&(n=s.length),s.slice(i,n)}for(e=s.length-1;e>=0;--e)if(s.charCodeAt(e)===47){if(!r){i=e+1;break}}else n===-1&&(r=!1,n=e+1);return n===-1?"":s.slice(i,n)},extname:function(s){tn(s);for(var t=-1,e=0,i=-1,n=!0,r=0,a=s.length-1;a>=0;--a){var o=s.charCodeAt(a);if(o!==47)i===-1&&(n=!1,i=a+1),o===46?t===-1?t=a:r!==1&&(r=1):t!==-1&&(r=-1);else if(!n){e=a+1;break}}return t===-1||i===-1||r===0||r===1&&t===i-1&&t===e+1?"":s.slice(t,i)},format:function(s){if(s===null||typeof s!="object")throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof s);return function(t,e){var i=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return i?i===e.root?i+n:i+t+n:n}("/",s)},parse:function(s){tn(s);var t={root:"",dir:"",base:"",ext:"",name:""};if(s.length===0)return t;var e,i=s.charCodeAt(0),n=i===47;n?(t.root="/",e=1):e=0;for(var r=-1,a=0,o=-1,l=!0,h=s.length-1,c=0;h>=e;--h)if((i=s.charCodeAt(h))!==47)o===-1&&(l=!1,o=h+1),i===46?r===-1?r=h:c!==1&&(c=1):r!==-1&&(c=-1);else if(!l){a=h+1;break}return r===-1||o===-1||c===0||c===1&&r===o-1&&r===a+1?o!==-1&&(t.base=t.name=a===0&&n?s.slice(1,o):s.slice(a,o)):(a===0&&n?(t.name=s.slice(1,r),t.base=s.slice(1,o)):(t.name=s.slice(a,r),t.base=s.slice(a,o)),t.ext=s.slice(r,o)),a>0?t.dir=s.slice(0,a-1):n&&(t.dir="/"),t},sep:"/",delimiter:":",win32:null,posix:null};na.posix=na;var pu=na;function ag(s){let t;try{t=new URL(s,"http://fakehost.com/")}catch{return null}const e=t.pathname.split("/").pop(),i=e.lastIndexOf(".");return i===-1||i===e.length-1?null:e.substring(i+1)}class vM{constructor(){this.maxSize=800,this.minSize=600,this.unloadPercent=.05,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadPriorityCallback=null;const t=this.itemSet;this.defaultPriorityCallback=e=>t.get(e)}isFull(){return this.itemSet.size>=this.maxSize}add(t,e){const i=this.itemSet;if(i.has(t)||this.isFull())return!1;const n=this.usedSet,r=this.itemList,a=this.callbacks;return r.push(t),n.add(t),i.set(t,Date.now()),a.set(t,e),!0}remove(t){const e=this.usedSet,i=this.itemSet,n=this.itemList,r=this.callbacks;if(i.has(t)){r.get(t)(t);const a=n.indexOf(t);return n.splice(a,1),e.delete(t),i.delete(t),r.delete(t),!0}return!1}markUsed(t){const e=this.itemSet,i=this.usedSet;e.has(t)&&!i.has(t)&&(e.set(t,Date.now()),i.add(t))}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const t=this.unloadPercent,e=this.minSize,i=this.itemList,n=this.itemSet,r=this.usedSet,a=this.callbacks,o=i.length-r.size,l=i.length-e,h=this.unloadPriorityCallback||this.defaultPriorityCallback;if(l>0&&o>0){i.sort((f,g)=>{const _=r.has(f),v=r.has(g);return _&&v?0:_||v?_?1:-1:h(g)-h(f)});const c=Math.min(l,o),u=Math.max(e*t,c*t);let p=Math.min(u,o);p=Math.ceil(p);const m=i.splice(0,p);for(let f=0,g=m.length;f<g;f++){const _=m[f];a.get(_)(_),n.delete(_),a.delete(_)}}}scheduleUnload(t=!0){var e;this.scheduled||(this.scheduled=!0,e=()=>{this.scheduled=!1,this.unloadUnusedContent(),t&&this.markAllUnused()},Promise.resolve().then(e))}}class og{constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=()=>{throw new Error("PriorityQueue: PriorityCallback function not defined.")},this.schedulingCallback=t=>{requestAnimationFrame(t)},this._runjobs=()=>{this.tryRunJobs(),this.scheduled=!1}}sort(){const t=this.priorityCallback;this.items.sort(t)}add(t,e){return new Promise((i,n)=>{const r=this.items,a=this.callbacks;r.push(t),a.set(t,(...o)=>e(...o).then(i).catch(n)),this.autoUpdate&&this.scheduleJobRun()})}remove(t){const e=this.items,i=this.callbacks,n=e.indexOf(t);n!==-1&&(e.splice(n,1),i.delete(t))}tryRunJobs(){this.sort();const t=this.items,e=this.callbacks,i=this.maxJobs;let n=this.currJobs;for(;i>n&&t.length>0;){n++;const r=t.pop(),a=e.get(r);e.delete(r),a(r).then(()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()}).catch(()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()})}this.currJobs=n}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}}const no=3,mu=4;function fu(s){return s===no||s===mu}function Js(s,t){return s.__lastFrameVisited===t&&s.__used}function lg(s,t){s.__lastFrameVisited!==t&&(s.__lastFrameVisited=t,s.__used=!1,s.__inFrustum=!1,s.__isLeaf=!1,s.__visible=!1,s.__active=!1,s.__error=1/0,s.__distanceFromCamera=1/0,s.__childrenWereVisible=!1,s.__allChildrenLoaded=!1)}function hg(s,t,e){if(lg(s,t),s.__used=!0,e.markUsed(s),s.__contentEmpty){const i=s.children;for(let n=0,r=i.length;n<r;n++)hg(i[n],t,e)}}function cg(s,t,e){if(s.__contentEmpty&&(!s.__externalTileSet||fu(s.__loadingState))){const i=s.children;for(let n=0,r=i.length;n<r;n++){const a=i[n];a.__depthFromRenderedParent=t,cg(a,t,e)}}else e.requestTileContents(s)}function gu(s,t=null,e=null,i=null,n=0){if(t&&t(s,i,n))return void(e&&e(s,i,n));const r=s.children;for(let a=0,o=r.length;a<o;a++)gu(r[a],t,e,s,n+1);e&&e(s,i,n)}function ug(s,t){const e=t.stats,i=t.frameCount,n=t.errorTarget,r=t.maxDepth,a=t.loadSiblings,o=t.lruCache,l=t.stopAtEmptyTiles;if(lg(s,i),t.tileInView(s)===!1)return!1;if(s.__used=!0,o.markUsed(s),s.__inFrustum=!0,e.inFrustum++,(l||!s.__contentEmpty)&&!s.__externalTileSet&&(t.calculateError(s),s.__error<=n||t.maxDepth>0&&s.__depth+1>=r))return!0;let h=!1;const c=s.children;for(let u=0,p=c.length;u<p;u++){const m=ug(c[u],t);h=h||m}if(h&&a)for(let u=0,p=c.length;u<p;u++)hg(c[u],i,o);return!0}function dg(s,t){const e=t.stats,i=t.frameCount;if(!Js(s,i))return;e.used++;const n=s.children;let r=!1;for(let a=0,o=n.length;a<o;a++){const l=n[a];r=r||Js(l,i)}if(r){let a=!1,o=!0;for(let l=0,h=n.length;l<h;l++){const c=n[l];if(dg(c,t),a=a||c.__wasSetVisible||c.__childrenWereVisible,Js(c,i)){const u=c.__allChildrenLoaded||!c.__contentEmpty&&fu(c.__loadingState)||c.__externalTileSet&&c.__loadingState===mu;o=o&&u}}s.__childrenWereVisible=a,s.__allChildrenLoaded=o}else s.__isLeaf=!0}function pg(s,t){const e=t.stats,i=t.frameCount;if(!Js(s,i))return;const n=s.parent,r=n?n.__depthFromRenderedParent:-1;s.__depthFromRenderedParent=r;const a=t.lruCache;if(s.__isLeaf)return s.__depthFromRenderedParent++,void(s.__loadingState===no?(s.__inFrustum&&(s.__visible=!0,e.visible++),s.__active=!0,e.active++):a.isFull()||s.__contentEmpty&&!s.__externalTileSet||t.requestTileContents(s));const o=(t.errorTarget+1)*t.errorThreshold,l=s.__error<=o,h=l||s.refine==="ADD",c=!s.__contentEmpty,u=c||s.__externalTileSet,p=fu(s.__loadingState)&&u,m=s.__childrenWereVisible,f=s.children;let g=s.__allChildrenLoaded;if(h&&c&&s.__depthFromRenderedParent++,h&&!p&&!a.isFull()&&u&&t.requestTileContents(s),(l&&!g&&!m&&p||s.refine==="ADD"&&p)&&(s.__inFrustum&&(s.__visible=!0,e.visible++),s.__active=!0,e.active++),s.refine!=="ADD"&&l&&!g&&p)for(let _=0,v=f.length;_<v;_++){const x=f[_];Js(x,i)&&!a.isFull()&&(x.__depthFromRenderedParent=s.__depthFromRenderedParent+1,cg(x,x.__depthFromRenderedParent,t))}else for(let _=0,v=f.length;_<v;_++){const x=f[_];Js(x,i)&&pg(x,t)}}function mg(s,t){const e=Js(s,t.frameCount);if(e||s.__usedLastFrame){let i=!1,n=!1;e&&(i=s.__active,n=t.displayActiveTiles&&s.__active||s.__visible),s.__contentEmpty||s.__loadingState!==no||(s.__wasSetActive!==i&&t.setTileActive(s,i),s.__wasSetVisible!==n&&t.setTileVisible(s,n)),s.__wasSetActive=i,s.__wasSetVisible=n,s.__usedLastFrame=e;const r=s.children;for(let a=0,o=r.length;a<o;a++)mg(r[a],t)}}const fg=(s,t)=>s.__depth!==t.__depth?s.__depth>t.__depth?-1:1:s.__inFrustum!==t.__inFrustum?s.__inFrustum?1:-1:s.__used!==t.__used?s.__used?1:-1:s.__error!==t.__error?s.__error>t.__error?1:-1:s.__distanceFromCamera!==t.__distanceFromCamera?s.__distanceFromCamera>t.__distanceFromCamera?-1:1:0,xM=s=>1/(s.__depthFromRenderedParent+1);class yM{get rootTileSet(){const t=this.tileSets[this.rootURL];return!t||t instanceof Promise?null:t}get root(){const t=this.rootTileSet;return t?t.root:null}constructor(t){this.tileSets={},this.rootURL=t,this.fetchOptions={},this.preprocessURL=null;const e=new vM;e.unloadPriorityCallback=xM;const i=new og;i.maxJobs=4,i.priorityCallback=fg;const n=new og;n.maxJobs=1,n.priorityCallback=fg,this.lruCache=e,this.downloadQueue=i,this.parseQueue=n,this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this.errorTarget=6,this.errorThreshold=1/0,this.loadSiblings=!0,this.displayActiveTiles=!1,this.maxDepth=1/0,this.stopAtEmptyTiles=!0}traverse(t,e){const i=this.tileSets[this.rootURL];i&&i.root&&gu(i.root,t,e)}update(){const t=this.stats,e=this.lruCache,i=this.tileSets,n=i[this.rootURL];if(!(this.rootURL in i))return void this.loadRootTileSet(this.rootURL);if(!n||!n.root)return;const r=n.root;t.inFrustum=0,t.used=0,t.active=0,t.visible=0,this.frameCount++,ug(r,this),dg(r,this),pg(r,this),mg(r,this),e.scheduleUnload()}parseTile(t,e,i){return null}disposeTile(t){}preprocessNode(t,e,i){if(t.content&&(!("uri"in t.content)&&"url"in t.content&&(t.content.uri=t.content.url,delete t.content.url),t.content.uri&&(t.content.uri=function(...n){const r=/^[a-zA-Z]+:\/\//;let a=-1;for(let o=0,l=n.length;o<l;o++)r.test(n[o])&&(a=o);if(a===-1)return pu.join(...n).replace(/\\/g,"/");{const o=a<=0?n:n.slice(a),l=o[0].match(r)[0];return o[0]=o[0].substring(l.length),(l+pu.join(...o)).replace(/\\/g,"/")}}(i,t.content.uri)),t.content.boundingVolume&&!("box"in t.content.boundingVolume||"sphere"in t.content.boundingVolume||"region"in t.content.boundingVolume)&&delete t.content.boundingVolume),t.parent=e,t.children=t.children||[],t.content&&t.content.uri){const n=ag(t.content.uri),r=!!(n&&n.toLowerCase()==="json");t.__externalTileSet=r,t.__contentEmpty=r}else t.__externalTileSet=!1,t.__contentEmpty=!0;t.__distanceFromCamera=1/0,t.__error=1/0,t.__inFrustum=!1,t.__isLeaf=!1,t.__usedLastFrame=!1,t.__used=!1,t.__wasSetVisible=!1,t.__visible=!1,t.__childrenWereVisible=!1,t.__allChildrenLoaded=!1,t.__wasSetActive=!1,t.__active=!1,t.__loadingState=0,t.__loadIndex=0,t.__loadAbort=null,t.__depthFromRenderedParent=-1,e===null?(t.__depth=0,t.refine=t.refine||"REPLACE"):(t.__depth=e.__depth+1,t.refine=t.refine||e.refine)}setTileActive(t,e){}setTileVisible(t,e){}calculateError(t){return 0}tileInView(t){return!0}fetchTileSet(t,e,i=null){return fetch(t,e).then(n=>{if(n.ok)return n.json();throw new Error(`TilesRenderer: Failed to load tileset "${t}" with status ${n.status} : ${n.statusText}`)}).then(n=>{const r=n.asset.version;console.assert(r==="1.0"||r==="0.0",'asset.version is expected to be a string of "1.0" or "0.0"');const a=pu.dirname(t);return gu(n.root,(o,l)=>this.preprocessNode(o,l,a),null,i,i?i.__depth:0),n})}loadRootTileSet(t){const e=this.tileSets;if(t in e)return e[t]instanceof Error?Promise.reject(e[t]):Promise.resolve(e[t]);{const i=this.fetchTileSet(this.preprocessURL?this.preprocessURL(t):t,this.fetchOptions).then(n=>{e[t]=n});return i.catch(n=>{console.error(n),e[t]=n}),e[t]=i,i}}requestTileContents(t){if(t.__loadingState!==0)return;const e=this.stats,i=this.lruCache,n=this.downloadQueue,r=this.parseQueue,a=t.__externalTileSet;i.add(t,u=>{u.__loadingState===1?(u.__loadAbort.abort(),u.__loadAbort=null):a?u.children.length=0:this.disposeTile(u),u.__loadingState===1?e.downloading--:u.__loadingState===2&&e.parsing--,u.__loadingState=0,u.__loadIndex++,r.remove(u),n.remove(u)}),t.__loadIndex++;const o=t.__loadIndex,l=new AbortController,h=l.signal;e.downloading++,t.__loadAbort=l,t.__loadingState=1;const c=u=>{t.__loadIndex===o&&(u.name!=="AbortError"?(r.remove(t),n.remove(t),t.__loadingState===2?e.parsing--:t.__loadingState===1&&e.downloading--,e.failed++,console.error(`TilesRenderer : Failed to load tile at url "${t.content.uri}".`),console.error(u),t.__loadingState=mu):i.remove(t))};a?n.add(t,u=>{if(u.__loadIndex!==o)return Promise.resolve();const p=this.preprocessURL?this.preprocessURL(u.content.uri):u.content.uri;return this.fetchTileSet(p,Object.assign({signal:h},this.fetchOptions),u)}).then(u=>{t.__loadIndex===o&&(e.downloading--,t.__loadAbort=null,t.__loadingState=no,t.children.push(u.root))}).catch(c):n.add(t,u=>{if(u.__loadIndex!==o)return Promise.resolve();const p=this.preprocessURL?this.preprocessURL(u.content.uri):u.content.uri;return fetch(p,Object.assign({signal:h},this.fetchOptions))}).then(u=>{if(t.__loadIndex===o){if(u.ok)return u.arrayBuffer();throw new Error(`Failed to load model with error code ${u.status}`)}}).then(u=>{if(t.__loadIndex===o)return e.downloading--,e.parsing++,t.__loadAbort=null,t.__loadingState=2,r.add(t,p=>{if(p.__loadIndex!==o)return Promise.resolve();const m=ag(p.content.uri);return this.parseTile(u,p,m)})}).then(()=>{t.__loadIndex===o&&(e.parsing--,t.__loadingState=no,t.__wasSetVisible&&this.setTileVisible(t,!0),t.__wasSetActive&&this.setTileActive(t,!0))}).catch(c)}dispose(){const t=this.lruCache;this.traverse(e=>{t.remove(e)})}}function gg(s){return new TextDecoder().decode(s)}class Fl{constructor(t,e,i,n){this.buffer=t,this.binOffset=e+i,this.binLength=n;let r=null;if(i!==0){const a=new Uint8Array(t,e,i);r=JSON.parse(gg(a))}else r={};this.header=r}getKeys(){return Object.keys(this.header)}getData(t,e,i=null,n=null){const r=this.header;if(!(t in r))return null;const a=r[t];if(a instanceof Object){if(Array.isArray(a))return a;{const{buffer:o,binOffset:l,binLength:h}=this,c=a.byteOffset||0,u=a.type||n,p=a.componentType||i;if("type"in a&&n&&a.type!==n)throw new Error("FeatureTable: Specified type does not match expected type.");let m,f;switch(u){case"SCALAR":m=1;break;case"VEC2":m=2;break;case"VEC3":m=3;break;case"VEC4":m=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${t}".`)}const g=l+c,_=e*m;switch(p){case"BYTE":f=new Int8Array(o,g,_);break;case"UNSIGNED_BYTE":f=new Uint8Array(o,g,_);break;case"SHORT":f=new Int16Array(o,g,_);break;case"UNSIGNED_SHORT":f=new Uint16Array(o,g,_);break;case"INT":f=new Int32Array(o,g,_);break;case"UNSIGNED_INT":f=new Uint32Array(o,g,_);break;case"FLOAT":f=new Float32Array(o,g,_);break;case"DOUBLE":f=new Float64Array(o,g,_);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${t}".`)}if(g+_*f.BYTES_PER_ELEMENT>l+h)throw new Error("FeatureTable: Feature data read outside binary body length.");return f}}return a}}class _u extends Fl{constructor(t,e,i,n,r){super(t,i,n,r),this.batchSize=e}getData(t,e=null,i=null){return super.getData(t,this.batchSize,e,i)}}class so{constructor(){this.fetchOptions={},this.workingPath=""}load(t){return fetch(t,this.fetchOptions).then(e=>{if(!e.ok)throw new Error(`Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);return e.arrayBuffer()}).then(e=>(this.workingPath===""&&(this.workingPath=this.workingPathForURL(t)),this.parse(e)))}resolveExternalURL(t){return/^[^\\/]/.test(t)?this.workingPath+"/"+t:t}workingPathForURL(t){const e=t.split(/[\\/]/g);return e.pop(),e.join("/")+"/"}parse(t){throw new Error("LoaderBase: Parse not implemented.")}}class bM extends so{parse(t){const e=new DataView(t),i=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert(i==="b3dm");const n=e.getUint32(4,!0);console.assert(n===1);const r=e.getUint32(8,!0);console.assert(r===t.byteLength);const a=e.getUint32(12,!0),o=e.getUint32(16,!0),l=e.getUint32(20,!0),h=e.getUint32(24,!0),c=t.slice(28,28+a+o),u=new Fl(c,0,a,o),p=28+a+o,m=t.slice(p,p+l+h),f=new _u(m,u.getData("BATCH_LENGTH"),0,l,h),g=p+l+h;return{version:n,featureTable:u,batchTable:f,glbBytes:new Uint8Array(t,g,r-g)}}}class _g extends bM{constructor(t=Nr){super(),this.manager=t}parse(t){const e=super.parse(t),i=e.glbBytes.slice().buffer;return new Promise((n,r)=>{const a=this.manager,o=this.fetchOptions,l=a.getHandler("path.gltf")||new ea(a);o.credentials==="include"&&o.mode==="cors"&&l.setCrossOrigin("use-credentials"),"credentials"in o&&l.setWithCredentials(o.credentials==="include"),o.headers&&l.setRequestHeader(o.headers);let h=this.workingPath;!/[\\/]$/.test(h)&&h.length&&(h+="/"),l.parse(i,h,c=>{const{batchTable:u,featureTable:p}=e,{scene:m}=c,f=p.getData("RTC_CENTER");f&&(m.position.x+=f[0],m.position.y+=f[1],m.position.z+=f[2]),c.batchTable=u,c.featureTable=p,m.batchTable=u,m.featureTable=p,n(c)},r)})}}class MM extends so{parse(t){const e=new DataView(t),i=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert(i==="pnts");const n=e.getUint32(4,!0);console.assert(n===1);const r=e.getUint32(8,!0);console.assert(r===t.byteLength);const a=e.getUint32(12,!0),o=e.getUint32(16,!0),l=e.getUint32(20,!0),h=e.getUint32(24,!0),c=t.slice(28,28+a+o),u=new Fl(c,0,a,o),p=28+a+o,m=t.slice(p,p+l+h),f=new _u(m,u.getData("BATCH_LENGTH")||u.getData("POINTS_LENGTH"),0,l,h);return Promise.resolve({version:n,featureTable:u,batchTable:f})}}class vg extends MM{constructor(t=Nr){super(),this.manager=t}parse(t){return super.parse(t).then(e=>{const{featureTable:i}=e,n=i.getData("POINTS_LENGTH"),r=i.getData("POSITION",n,"FLOAT","VEC3"),a=i.getData("RGB",n,"UNSIGNED_BYTE","VEC3");["RTC_CENTER","QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","CONSTANT_RGBA","BATCH_LENGTH","POSITION_QUANTIZED","RGBA","RGB565","NORMAL","NORMAL_OCT16P"].forEach(u=>{u in i.header&&console.warn(`PNTSLoader: Unsupported FeatureTable feature "${u}" detected.`)});const o=new Pt;o.setAttribute("position",new se(r,3,!1));const l=new Na;l.size=2,l.sizeAttenuation=!1,a!==null&&(o.setAttribute("color",new se(a,3,!0)),l.vertexColors=!0);const h=new ll(o,l);e.scene=h,e.scene.featureTable=i;const c=i.getData("RTC_CENTER");return c&&(e.scene.position.x+=c[0],e.scene.position.y+=c[1],e.scene.position.z+=c[2]),e})}}class wM extends so{parse(t){const e=new DataView(t),i=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert(i==="i3dm");const n=e.getUint32(4,!0);console.assert(n===1);const r=e.getUint32(8,!0);console.assert(r===t.byteLength);const a=e.getUint32(12,!0),o=e.getUint32(16,!0),l=e.getUint32(20,!0),h=e.getUint32(24,!0),c=e.getUint32(28,!0),u=t.slice(32,32+a+o),p=new Fl(u,0,a,o),m=32+a+o,f=t.slice(m,m+l+h),g=new _u(f,p.getData("INSTANCES_LENGTH"),0,l,h),_=m+l+h,v=new Uint8Array(t,_,r-_);let x=null,y=null;if(c)x=v,y=Promise.resolve();else{const b=this.resolveExternalURL(gg(v));y=fetch(b,this.fetchOptions).then(S=>{if(!S.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${b}" with status ${S.status} : ${S.statusText}`);return S.arrayBuffer()}).then(S=>{x=new Uint8Array(S)})}return y.then(()=>({version:n,featureTable:p,batchTable:g,glbBytes:x}))}}const xg=new M,vu=new M,xu=new M,yg=new M,yu=new Ht,Bl=new M,Vl=new rt;class bg extends wM{constructor(t=Nr){super(),this.manager=t}resolveExternalURL(t){return this.manager.resolveURL(super.resolveExternalURL(t))}parse(t){return super.parse(t).then(e=>{const{featureTable:i,batchTable:n}=e,r=e.glbBytes.slice().buffer;return new Promise((a,o)=>{const l=this.fetchOptions,h=this.manager,c=h.getHandler("path.gltf")||new ea(h);l.credentials==="include"&&l.mode==="cors"&&c.setCrossOrigin("use-credentials"),"credentials"in l&&c.setWithCredentials(l.credentials==="include"),l.headers&&c.setRequestHeader(l.headers);let u=this.workingPath;/[\\/]$/.test(u)||(u+="/"),c.parse(r,u,p=>{const m=i.getData("INSTANCES_LENGTH"),f=i.getData("POSITION",m,"FLOAT","VEC3"),g=i.getData("NORMAL_UP",m,"FLOAT","VEC3"),_=i.getData("NORMAL_RIGHT",m,"FLOAT","VEC3"),v=i.getData("SCALE_NON_UNIFORM",m,"FLOAT","VEC3"),x=i.getData("SCALE",m,"FLOAT","SCALAR");["RTC_CENTER","QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","EAST_NORTH_UP","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(w=>{w in i.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${w}" detected.`)});const y=new Map,b=[];p.scene.traverse(w=>{if(w.isMesh){const{geometry:C,material:L}=w,T=new tm(C,L,m);T.position.copy(w.position),T.rotation.copy(w.rotation),T.scale.copy(w.scale),b.push(T),y.set(w,T)}});const S=new M;for(let w=0;w<m;w++)S.x+=f[3*w+0]/m,S.y+=f[3*w+1]/m,S.z+=f[3*w+2]/m;y.forEach((w,C)=>{const L=C.parent;L&&(L.remove(C),L.add(w),w.updateMatrixWorld(),w.position.copy(S).applyMatrix4(w.matrixWorld))});for(let w=0;w<m;w++){yg.set(f[3*w+0]-S.x,f[3*w+1]-S.y,f[3*w+2]-S.z),g?(vu.set(g[3*w+0],g[3*w+1],g[3*w+2]),xu.set(_[3*w+0],_[3*w+1],_[3*w+2]),xg.crossVectors(xu,vu).normalize(),Vl.makeBasis(xu,vu,xg),yu.setFromRotationMatrix(Vl)):yu.set(0,0,0,1),x?Bl.setScalar(x[w]):v?Bl.set(v[3*w+0],v[3*w+1],v[3*w+2]):Bl.set(1,1,1),Vl.compose(yg,yu,Bl);for(let C=0,L=b.length;C<L;C++)b[C].setMatrixAt(w,Vl)}p.batchTable=n,p.featureTable=i,p.scene.batchTable=n,p.scene.featureTable=i,a(p)},o)})})}}class SM extends so{parse(t){const e=new DataView(t),i=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert(i==="cmpt",'CMPTLoader: The magic bytes equal "cmpt".');const n=e.getUint32(4,!0);console.assert(n===1,'CMPTLoader: The version listed in the header is "1".');const r=e.getUint32(8,!0);console.assert(r===t.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const a=e.getUint32(12,!0),o=[];let l=16;for(let h=0;h<a;h++){const c=new DataView(t,l,12),u=String.fromCharCode(c.getUint8(0))+String.fromCharCode(c.getUint8(1))+String.fromCharCode(c.getUint8(2))+String.fromCharCode(c.getUint8(3)),p=c.getUint32(4,!0),m=c.getUint32(8,!0),f=new Uint8Array(t,l,m);o.push({type:u,buffer:f,version:p}),l+=m}return{version:n,tiles:o}}}class TM extends SM{constructor(t=Nr){super(),this.manager=t}parse(t){const e=super.parse(t),i=this.manager,n=[];for(const r in e.tiles){const{type:a,buffer:o}=e.tiles[r];switch(a){case"b3dm":{const l=o.slice(),h=new _g(i);h.workingPath=this.workingPath,h.fetchOptions=this.fetchOptions;const c=h.parse(l.buffer);n.push(c);break}case"pnts":{const l=o.slice(),h=new vg(i);h.workingPath=this.workingPath,h.fetchOptions=this.fetchOptions;const c=h.parse(l.buffer);n.push(c);break}case"i3dm":{const l=o.slice(),h=new bg(i);h.workingPath=this.workingPath,h.fetchOptions=this.fetchOptions;const c=h.parse(l.buffer);n.push(c);break}}}return Promise.all(n).then(r=>{const a=new De;return r.forEach(o=>{a.add(o.scene)}),{tiles:r,scene:a}})}}class CM extends so{constructor(t=Nr){super(),this.manager=t}parse(t){return new Promise((e,i)=>{const n=this.manager,r=this.fetchOptions;let a=n.getHandler("path.gltf")||n.getHandler("path.glb");a||(a=new ea(n),r.credentials==="include"&&r.mode==="cors"&&a.setCrossOrigin("use-credentials"),"credentials"in r&&a.setWithCredentials(r.credentials==="include"),r.headers&&a.setRequestHeader(r.headers));let o=a.resourcePath||a.path||this.workingPath;!/[\\/]$/.test(o)&&o.length&&(o+="/"),a.parse(t,o,l=>{e(l)},i)})}}const Hl=new rt;class EM extends De{constructor(t){super(),this.name="TilesRenderer.TilesGroup",this.tilesRenderer=t}raycast(t,e){this.tilesRenderer.optimizeRaycast&&this.tilesRenderer.raycast(t,e)}updateMatrixWorld(t){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||t){this.parent===null?Hl.copy(this.matrix):Hl.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const e=Hl.elements,i=this.matrixWorld.elements;let n=!1;for(let r=0;r<16;r++){const a=e[r],o=i[r];if(Math.abs(a-o)>Number.EPSILON){n=!0;break}}if(n){this.matrixWorld.copy(Hl);const r=this.children;for(let a=0,o=r.length;a<o;a++)r[a].updateMatrixWorld()}}}}const sa=new mi,Rn=new rt,Mg=new M,ra=new M,aa=new vr,bi=[];function bu(s,t){return s.distance-t.distance}function Mu(s,t,e){s.traverse(i=>{Object.getPrototypeOf(i).raycast.call(i,t,e)})}function wg(s,t,e,i){if(e.has(s)){if(Mu(s.cached.scene,i,bi),bi.length>0){bi.length>1&&bi.sort(bu);const l=bi[0];return bi.length=0,l}return null}const n=[],r=s.children;for(let l=0,h=r.length;l<h;l++){const c=r[l],u=c.cached,p=t.matrixWorld;Rn.copy(p);const m=u.sphere;if(m&&(sa.copy(m),sa.applyMatrix4(Rn),!i.ray.intersectsSphere(sa)))continue;const f=u.box,g=u.boxTransform;if(f){if(Rn.multiply(g).invert(),aa.copy(i.ray),aa.applyMatrix4(Rn),!aa.intersectBox(f,Mg))continue;{let _;ra.setFromMatrixScale(Rn),_=ra.x,Math.abs(Math.max(ra.x-ra.y,ra.x-ra.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when raycasting.");let v={distance:1/0,tile:null};n.push(v),v.distance=Mg.distanceToSquared(aa.origin)*_*_,v.tile=c}}}n.sort(bu);let a=1/0,o=null;for(let l=0,h=n.length;l<h;l++){const c=n[l];if(c.distance>a)break;{const u=c.tile,p=u.cached.scene;let m=null;if(e.has(u)?(Mu(p,i,bi),bi.length>0&&(bi.length>1&&bi.sort(bu),m=bi[0])):m=wg(u,t,e,i),m){const f=m.distance*m.distance;f<a&&(a=f,o=m),bi.length=0}}}return o}function Sg(s,t,e,i,n){const r=s.cached,a=t.matrixWorld;Rn.copy(a);const o=r.sphere;if(o&&(sa.copy(o),sa.applyMatrix4(Rn),!i.ray.intersectsSphere(sa)))return;const l=r.box,h=r.boxTransform;if(l&&(Rn.multiply(h).invert(),aa.copy(i.ray).applyMatrix4(Rn),!aa.intersectsBox(l)))return;const c=r.scene;if(e.has(s))return void Mu(c,i,n);const u=s.children;for(let p=0,m=u.length;p<m;p++)Sg(u[p],t,e,i,n)}const Tg=Symbol("INITIAL_FRUSTUM_CULLED"),hs=new rt,wu=new rt,Vi=new M,Dn=new M,Ln=new M,In=new M,AM=new M(1,0,0),PM=new M(0,1,0);function Cg(s,t){s.traverse(e=>{e.frustumCulled=e[Tg]&&t})}class Su extends yM{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(t){this._autoDisableRendererCulling!==t&&(super._autoDisableRendererCulling=t,this.forEachLoadedModel(e=>{Cg(e,!t)}))}constructor(...t){super(...t),this.group=new EM(this),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this.activeTiles=new Set,this.visibleTiles=new Set,this._autoDisableRendererCulling=!0,this.optimizeRaycast=!0,this.onLoadTileSet=null,this.onLoadModel=null,this.onDisposeModel=null,this.onTileVisibilityChange=null;const e=new um;e.setURLModifier(n=>this.preprocessURL?this.preprocessURL(n):n),this.manager=e;const i=this;this._overridenRaycast=function(n,r){i.optimizeRaycast||Object.getPrototypeOf(this).raycast.call(this,n,r)}}getBounds(t){if(!this.root)return!1;const e=this.root.cached,i=e.box,n=e.boxTransform;return!!i&&(t.copy(i),t.applyMatrix4(n),!0)}getOrientedBounds(t,e){if(!this.root)return!1;const i=this.root.cached,n=i.box,r=i.boxTransform;return!!n&&(t.copy(n),e.copy(r),!0)}getBoundingSphere(t){if(!this.root)return!1;const e=this.root.cached.sphere;return!!e&&(t.copy(e),!0)}forEachLoadedModel(t){this.traverse(e=>{const i=e.cached.scene;i&&t(i,e)})}raycast(t,e){if(this.root)if(t.firstHitOnly){const i=wg(this.root,this.group,this.activeTiles,t);i&&e.push(i)}else Sg(this.root,this.group,this.activeTiles,t,e)}hasCamera(t){return this.cameraMap.has(t)}setCamera(t){const e=this.cameras,i=this.cameraMap;return!i.has(t)&&(i.set(t,new j),e.push(t),!0)}setResolution(t,e,i){const n=this.cameraMap;return!!n.has(t)&&(e instanceof j?n.get(t).copy(e):n.get(t).set(e,i),!0)}setResolutionFromRenderer(t,e){const i=this.cameraMap;if(!i.has(t))return!1;const n=i.get(t);return e.getSize(n),n.multiplyScalar(e.getPixelRatio()),!0}deleteCamera(t){const e=this.cameras,i=this.cameraMap;if(i.has(t)){const n=e.indexOf(t);return e.splice(n,1),i.delete(t),!0}return!1}fetchTileSet(t,...e){const i=super.fetchTileSet(t,...e);return i.then(n=>{this.onLoadTileSet&&Promise.resolve().then(()=>{this.onLoadTileSet(n,t)})}),i}update(){const t=this.group,e=this.cameras,i=this.cameraMap,n=this.cameraInfo;if(e.length===0)return void console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.");for(;n.length>e.length;)n.pop();for(;n.length<e.length;)n.push({frustum:new Pa,isOrthographic:!1,sseDenominator:-1,position:new M,invScale:-1,pixelSize:0});let r;wu.copy(t.matrixWorld).invert(),Vi.setFromMatrixScale(wu),r=Vi.x,Math.abs(Math.max(Vi.x-Vi.y,Vi.x-Vi.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let a=0,o=n.length;a<o;a++){const l=e[a],h=n[a],c=h.frustum,u=h.position,p=i.get(l);p.width!==0&&p.height!==0||console.warn("TilesRenderer: resolution for camera error calculation is not set.");const m=l.projectionMatrix.elements;if(h.isOrthographic=m[15]===1,h.isOrthographic){const f=2/m[0],g=2/m[5];h.pixelSize=Math.max(g/p.height,f/p.width)}else h.sseDenominator=2/m[5]/p.height;h.invScale=r,hs.copy(t.matrixWorld),hs.premultiply(l.matrixWorldInverse),hs.premultiply(l.projectionMatrix),c.setFromProjectionMatrix(hs),u.set(0,0,0),u.applyMatrix4(l.matrixWorld),u.applyMatrix4(wu)}super.update()}preprocessNode(t,e,i){super.preprocessNode(t,e,i);const n=new rt;if(t.transform){const c=t.transform;for(let u=0;u<16;u++)n.elements[u]=c[u]}else n.identity();e&&n.premultiply(e.cached.transform);const r=new rt().copy(n).invert();let a=null,o=null,l=null;if("box"in t.boundingVolume){const c=t.boundingVolume.box;a=new He,o=new rt,l=new rt,Dn.set(c[3],c[4],c[5]),Ln.set(c[6],c[7],c[8]),In.set(c[9],c[10],c[11]);const u=Dn.length(),p=Ln.length(),m=In.length();Dn.normalize(),Ln.normalize(),In.normalize(),u===0&&Dn.crossVectors(Ln,In),p===0&&Ln.crossVectors(Dn,In),m===0&&In.crossVectors(Dn,Ln),o.set(Dn.x,Ln.x,In.x,c[0],Dn.y,Ln.y,In.y,c[1],Dn.z,Ln.z,In.z,c[2],0,0,0,1),o.premultiply(n),l.copy(o).invert(),a.min.set(-u,-p,-m),a.max.set(u,p,m)}let h=null;if("sphere"in t.boundingVolume){const c=t.boundingVolume.sphere;h=new mi,h.center.set(c[0],c[1],c[2]),h.radius=c[3],h.applyMatrix4(n)}else if("box"in t.boundingVolume){const c=t.boundingVolume.box;h=new mi,a.getBoundingSphere(h),h.center.set(c[0],c[1],c[2]),h.applyMatrix4(n)}"region"in t.boundingVolume&&console.warn("ThreeTilesRenderer: region bounding volume not supported."),t.cached={loadIndex:0,transform:n,transformInverse:r,active:!1,inFrustum:[],box:a,boxTransform:o,boxTransformInverse:l,sphere:h,region:null,scene:null,geometry:null,material:null}}parseTile(t,e,i){e._loadIndex=e._loadIndex||0,e._loadIndex++;const n=e.content.uri.split(/[\\\/]/g);n.pop();const r=n.join("/"),a=this.fetchOptions,o=this.manager,l=e._loadIndex;let h=null;switch(i){case"b3dm":{const u=new _g(o);u.workingPath=r,u.fetchOptions=a,h=u.parse(t).then(p=>p.scene);break}case"pnts":{const u=new vg(o);u.workingPath=r,u.fetchOptions=a,h=u.parse(t).then(p=>p.scene);break}case"i3dm":{const u=new bg(o);u.workingPath=r,u.fetchOptions=a,h=u.parse(t).then(p=>p.scene);break}case"cmpt":{const u=new TM(o);u.workingPath=r,u.fetchOptions=a,h=u.parse(t).then(p=>p.scene);break}case"gltf":case"glb":const c=new CM(o);c.workingPath=r,c.fetchOptions=a,h=c.parse(t).then(u=>u.scene);break;default:console.warn(`TilesRenderer: Content type "${i}" not supported.`),h=Promise.resolve(null)}return h.then(c=>{if(e._loadIndex!==l)return;const u=this.rootTileSet.asset&&this.rootTileSet.asset.gltfUpAxis||"y",p=e.cached,m=p.transform;switch(u.toLowerCase()){case"x":hs.makeRotationAxis(PM,-Math.PI/2);break;case"y":hs.makeRotationAxis(AM,Math.PI/2);break;case"z":hs.identity()}c.updateMatrix(),i!=="pnts"&&c.matrix.multiply(hs),c.matrix.premultiply(m),c.matrix.decompose(c.position,c.quaternion,c.scale),c.traverse(v=>{v[Tg]=v.frustumCulled}),Cg(c,!this.autoDisableRendererCulling),p.scene=c,c.traverse(v=>{v.raycast=this._overridenRaycast});const f=[],g=[],_=[];c.traverse(v=>{if(v.geometry&&g.push(v.geometry),v.material){const x=v.material;f.push(v.material);for(const y in x){const b=x[y];b&&b.isTexture&&_.push(b)}}}),p.materials=f,p.geometry=g,p.textures=_,this.onLoadModel&&this.onLoadModel(c,e)})}disposeTile(t){const e=t.cached;if(e.scene){const i=e.materials,n=e.geometry,r=e.textures;for(let a=0,o=n.length;a<o;a++)n[a].dispose();for(let a=0,o=i.length;a<o;a++)i[a].dispose();for(let a=0,o=r.length;a<o;a++)r[a].dispose();this.onDisposeModel&&this.onDisposeModel(e.scene,t),e.scene=null,e.materials=null,e.textures=null,e.geometry=null}t._loadIndex++}setTileVisible(t,e){const i=t.cached.scene,n=this.visibleTiles,r=this.group;e?(r.add(i),n.add(t),i.updateMatrixWorld(!0)):(r.remove(i),n.delete(t)),this.onTileVisibilityChange&&this.onTileVisibilityChange(i,t,e)}setTileActive(t,e){const i=this.activeTiles;e?i.add(t):i.delete(t)}calculateError(t){const e=t.cached,i=e.inFrustum,n=this.cameras,r=this.cameraInfo,a=t.boundingVolume;if("box"in a||"sphere"in a){const o=e.sphere,l=e.box,h=e.boxTransformInverse,c=e.transformInverse,u=l&&h;let p=-1/0,m=1/0;for(let f=0,g=n.length;f<g;f++){if(!i[f])continue;const _=r[f],v=_.invScale;let x;if(_.isOrthographic){const y=_.pixelSize;x=t.geometricError/(y*v)}else{let y;Vi.copy(_.position),u?(Vi.applyMatrix4(h),y=l.distanceToPoint(Vi)):(Vi.applyMatrix4(c),y=Math.max(o.distanceToPoint(Vi),0));const b=y*v,S=_.sseDenominator;x=t.geometricError/(b*S),m=Math.min(m,b)}p=Math.max(p,x)}t.__distanceFromCamera=m,t.__error=p}else"region"in a&&console.warn("ThreeTilesRenderer : Region bounds not supported.")}tileInView(t){const e=t.cached,i=e.sphere,n=e.inFrustum;if(i){const r=this.cameraInfo;let a=!1;for(let o=0,l=r.length;o<l;o++)r[o].frustum.intersectsSphere(i)?(a=!0,n[o]=!0):n[o]=!1;return a}return!0}}const Hi=new M,Eg=["x","y","z"];class RM extends dc{constructor(t,e=16776960,i=40){const n=new Pt,r=[];for(let a=0;a<3;a++){const o=Eg[a],l=Eg[(a+1)%3];Hi.set(0,0,0);for(let h=0;h<i;h++){let c;c=2*Math.PI*h/(i-1),Hi[o]=Math.sin(c),Hi[l]=Math.cos(c),r.push(Hi.x,Hi.y,Hi.z),c=2*Math.PI*(h+1)/(i-1),Hi[o]=Math.sin(c),Hi[l]=Math.cos(c),r.push(Hi.x,Hi.y,Hi.z)}}n.setAttribute("position",new se(new Float32Array(r),3)),n.computeBoundingSphere(),super(n,new Is({color:e,toneMapped:!1})),this.sphere=t,this.type="SphereHelper"}updateMatrixWorld(t){const e=this.sphere;this.position.copy(e.center),this.scale.setScalar(e.radius),super.updateMatrixWorld(t)}}const Tu=Symbol("ORIGINAL_MATERIAL"),Cu=Symbol("HAS_RANDOM_COLOR"),Eu=Symbol("HAS_RANDOM_NODE_COLOR");function Ag(){}class DM extends Su{constructor(...t){super(...t);const e=this.group,i=new De;i.name="DebugTilesRenderer.boxGroup",e.add(i);const n=new De;n.name="DebugTilesRenderer.sphereGroup",e.add(n),this.displayBoxBounds=!1,this.displaySphereBounds=!1,this.colorMode=0,this.customColorCallback=null,this.boxGroup=i,this.sphereGroup=n,this.maxDebugDepth=-1,this.maxDebugDistance=-1,this.maxDebugError=-1,this.getDebugColor=(r,a)=>{a.setRGB(r,r,r)},this.extremeDebugDepth=-1,this.extremeDebugError=-1}initExtremes(){let t=-1;this.traverse(i=>{t=Math.max(t,i.__depth)});let e=-1;this.traverse(i=>{e=Math.max(e,i.geometricError)}),this.extremeDebugDepth=t,this.extremeDebugError=e}fetchTileSet(...t){const e=super.fetchTileSet(...t);return e.then(()=>{Promise.resolve().then(()=>{this.initExtremes()})}).catch(()=>{}),e}getTileInformationFromActiveObject(t){let e=null;return this.activeTiles.forEach(i=>{if(e)return!0;const n=i.cached.scene;n&&n.traverse(r=>{r===t&&(e=i)})}),e?{distanceToCamera:e.__distanceFromCamera,geometricError:e.geometricError,screenSpaceError:e.__error,depth:e.__depth,isLeaf:e.__isLeaf}:null}update(){if(super.update(),!this.root)return;this.boxGroup.visible=this.displayBoxBounds,this.sphereGroup.visible=this.displaySphereBounds;let t=-1;t=this.maxDebugDepth===-1?this.extremeDebugDepth:this.maxDebugDepth;let e=-1;e=this.maxDebugError===-1?this.extremeDebugError:this.maxDebugError;let i=-1;i=this.maxDebugDistance===-1?this.root.cached.sphere.radius:this.maxDebugDistance;const n=this.errorTarget,r=this.colorMode;this.visibleTiles.forEach(a=>{const o=a.cached.scene;let l,h,c;r===7&&(l=Math.random(),h=.5+.5*Math.random(),c=.375+.25*Math.random()),o.traverse(u=>{r===8&&(l=Math.random(),h=.5+.5*Math.random(),c=.375+.25*Math.random());const p=u.material;if(p){const m=u[Tu];if(r===0&&p!==m)u.material.dispose(),u.material=u[Tu];else if(r!==0&&p===m)if(u.isPoints){const f=new Na;f.size=m.size,f.sizeAttenuation=m.sizeAttenuation,u.material=f}else u.material=new yn,u.material.flatShading=!0;switch(r!==7&&delete u.material[Cu],r!==8&&delete u.material[Eu],r){case 4:{const f=a.__depth/t;this.getDebugColor(f,u.material.color);break}case 5:{const f=a.__depthFromRenderedParent/t;this.getDebugColor(f,u.material.color);break}case 1:{const f=a.__error/n;f>1?u.material.color.setRGB(1,0,0):this.getDebugColor(f,u.material.color);break}case 2:{const f=Math.min(a.geometricError/e,1);this.getDebugColor(f,u.material.color);break}case 3:{const f=Math.min(a.__distanceFromCamera/i,1);this.getDebugColor(f,u.material.color);break}case 6:a.children&&a.children.length!==0?this.getDebugColor(0,u.material.color):this.getDebugColor(1,u.material.color);break;case 8:u.material[Eu]||(u.material.color.setHSL(l,h,c),u.material[Eu]=!0);break;case 7:u.material[Cu]||(u.material.color.setHSL(l,h,c),u.material[Cu]=!0);break;case 9:this.customColorCallback?this.customColorCallback(a,u):console.warn("DebugTilesRenderer: customColorCallback not defined")}}})})}setTileVisible(t,e){super.setTileVisible(t,e);const i=t.cached,n=this.sphereGroup,r=this.boxGroup,a=i.boxHelperGroup,o=i.sphereHelper;e?(a&&(r.add(a),a.updateMatrixWorld(!0)),o&&(n.add(o),o.updateMatrixWorld(!0))):(a&&r.remove(a),o&&n.remove(o))}parseTile(t,e,i){return super.parseTile(t,e,i).then(()=>{const n=e.cached,r=n.scene;if(r){if(n.box&&n.boxTransform){const a=n.box,o=n.boxTransform,l=new De;l.name="DebugTilesRenderer.boxHelperGroup",l.matrix.copy(o),l.matrixAutoUpdate=!1;const h=new wy(a,function(c){if(!du[c]){const u=Math.random(),p=.5+.5*Math.random(),m=.375+.25*Math.random();du[c]=new tt().setHSL(u,p,m)}return du[c]}(e.__depth));h.raycast=Ag,l.add(h),n.boxHelperGroup=l,this.visibleTiles.has(e)&&this.displayBoxBounds&&(this.boxGroup.add(l),l.updateMatrixWorld(!0))}if(n.sphere){const a=n.sphere,o=new RM(a);o.raycast=Ag,n.sphereHelper=o,this.visibleTiles.has(e)&&this.displaySphereBounds&&(this.sphereGroup.add(o),o.updateMatrixWorld(!0))}r.traverse(a=>{const o=a.material;o&&(a[Tu]=o)})}})}disposeTile(t){super.disposeTile(t);const e=t.cached;e.boxHelperGroup&&(e.boxHelperGroup.children[0].geometry.dispose(),delete e.boxHelperGroup),e.sphereHelper&&(e.sphereHelper.geometry.dispose(),delete e.sphereHelper)}}class LM{constructor(t){d(this,"_tileMaxLevel",19),d(this,"_subscribedMaxLodLevel",1),d(this,"_elementHandlers",[]),d(this,"_objectParent",null),d(this,"subscribedDataTypeMap",{}),d(this,"_active",!1),d(this,"_configVersion",0),d(this,"shouldIgnoreTile",e=>e.__lodLevel>this._subscribedMaxLodLevel),d(this,"parseElements",e=>{const i=e.cached.scene,n=i.batchTable&&i.batchTable.header;if(!n||!n.id||!n.dataType)return;const r=n.id,a=n.dataType,o={},l=new Map;let h=null,c=null,u=null;for(let p=0,m=a.length;p<m;p++){if(!this.subscribedDataTypeMap[a[p]])continue;h=a[p],c=this.subscribedDataTypeMap[h],u=r[p];const f={id:u,dataType:h,position:[],uv:[],normal:[],index:[]};o[p]=f;const g=l.get(c);g?g.push(f):l.set(c,[f])}for(const p of i.children)this.findElementInMesh(p,o,l);for(const p of l.keys()){const m=l.get(p);p.addTileElementObjects(e,m)}}),d(this,"getInterleavedBufferValue2",(e,i)=>{const n=e.data.array,r=e.data.stride*i+e.offset;return[n[r],n[r+1]]}),d(this,"getInterleavedBufferValue3",(e,i)=>{const n=e.data.array,r=e.data.stride*i+e.offset;return[n[r],n[r+1],n[r+2]]}),d(this,"findElementInMesh",(e,i,n)=>{if(!e||!e.geometry)return;const r=e.geometry.getAttribute("_batchid");if(!r)return;const a=e.geometry.getAttribute("normal");if(!a)return;const o=e.geometry.getAttribute("position"),l=e.geometry.getAttribute("uv"),h=r.data.count,c={};let u=null;for(let m=0;m<h;m++){if(u=r.getX(m),!i[u])continue;let f=i[u],g=this.getInterleavedBufferValue3(o,m),_=this.getInterleavedBufferValue3(a,m),v=this.getInterleavedBufferValue2(l,m);f.position.push(g[0],g[1],g[2]),f.normal.push(_[0],_[1],_[2]),f.uv.push(v[0],v[1]),c[m]={batchId:u,index:f.position.length/3-1}}const p=e.geometry.index.array;for(let m=0,f=p.length-2;m<f;m+=3){let g=p[m];if(c[g]===void 0)continue;let _=p[m+1],v=p[m+2],x=c[g],y=x.batchId,b=x.index,S=c[_]&&c[_].index,w=c[v]&&c[v].index;if(S===void 0||w===void 0){console.warn("one face includes more than one object");continue}i[y].index.push(b,S,w)}for(const m of Object.keys(i)){const f=i[m],g=new Pt;g.setAttribute("position",new se(new Float32Array(f.position),3)),g.setAttribute("normal",new se(new Float32Array(f.normal),3)),g.setAttribute("uv",new se(new Float32Array(f.uv),2)),g.setIndex(f.index),f.geometry=g}}),d(this,"onTileLoad",(e,i)=>{this.parseTileInfo(e),this.shouldIgnoreTile(e)}),d(this,"onTileDispose",(e,i)=>{if(!this.shouldIgnoreTile(e))for(const n of this._elementHandlers)n.disposeTileElementObjects(e)}),d(this,"onTileShow",e=>{this._active&&!this.shouldIgnoreTile(e)&&this.refreshTile(e)}),d(this,"onTileHide",e=>{if(this._active&&!this.shouldIgnoreTile(e))for(const i of this._elementHandlers)i.hideTileElementObjects(e)}),d(this,"parseTileInfo",e=>{const i=e.content.uri,n=i.substring(i.lastIndexOf("/")+1).split(".")[0],r=n.split("-");e.__id=n,e.__level=parseInt(r[0],10),e.__lodLevel=this._tileMaxLevel-e.__level}),d(this,"refreshTile",e=>{if(e.__elementsConfigVersion!==this._configVersion){for(const i of this._elementHandlers)i.disposeTileElementObjects(e);this.parseElements(e),e.__elementsConfigVersion=this._configVersion}for(const i of this._elementHandlers)i.showTileElementObjects(e)}),d(this,"refreshTiles",()=>{this.tilesRenderer.forEachLoadedModel((e,i)=>{i.__visible&&!this.shouldIgnoreTile(i)&&this.refreshTile(i)}),this.engine.requestRender()}),this._objectParent=t}registerElement(t){t.parent=this._objectParent,t.engine=this.engine;for(const e of t.subscribedDataTypeIds)this.subscribedDataTypeMap[e]=t;return this._elementHandlers.push(t),this._configVersion++,this._active=!0,this.refreshTiles(),t}unregisterElement(t){for(let i of Object.keys(this.subscribedDataTypeMap))this.subscribedDataTypeMap[i]===t&&delete this.subscribedDataTypeMap[i];let e=this._elementHandlers.indexOf(t);e>-1&&(t.dispose(),this._elementHandlers.splice(e,1)),this._configVersion++,this._active=this._elementHandlers.length>0,this.refreshTiles()}tick(t){if(this._active)for(const e of this._elementHandlers)e.tick(t)}get subscribedMaxLodLevel(){return this._subscribedMaxLodLevel}set subscribedMaxLodLevel(t){this._subscribedMaxLodLevel=t}}class Au extends St{constructor(t){if(super(),d(this,"isEventEntitySupported",!0),d(this,"_expandStepSize",100),d(this,"_meshes",[]),d(this,"_colorMap",{}),d(this,"_attributes",[]),d(this,"_idIndexMap",{}),d(this,"_indexIdMap",{}),d(this,"_instanceMatrixArray",new Float32Array(1600)),d(this,"_instanceColorArray",new Float32Array(300).fill(1)),d(this,"_instanceMatrixArraySize",100),d(this,"_currentCount",0),d(this,"_rtc",null),d(this,"updateRenderingMesh",()=>{const e=this._meshes,i=e.length,n=this.children;for(let r=0;r<i;++r){const a=e[r],o=new tm(a.geometry,a.material);o.__eventProxyByParent=!0,o.castShadow=a.castShadow,o.receiveShadow=a.receiveShadow,o.parent=this,n[r]=o}if(n.length>i)for(let r=n.length-1;r>=i;--r)this.remove(this.children[r])}),d(this,"expandInstanceArray",e=>{const i=this._instanceMatrixArraySize+this._expandStepSize*Math.ceil(e/this._expandStepSize),n=new Float32Array(16*i),r=new Float32Array(3*i).fill(1);r.set(this._instanceColorArray),n.set(this._instanceMatrixArray),this._instanceMatrixArray=n,this._instanceColorArray=r,this._instanceMatrixArraySize=i}),d(this,"copyArrayData",(e,i,n,r,a)=>{for(let o=0;o<a;o++)e[i+o]=n[r+o]}),t)this.meshes=t;else{const e=new lt(new oe(1,1,1),new ae({color:16777215}));this._meshes=[e]}this.updateRenderingMesh()}getEntityByIndex(t){const e=this._indexIdMap[t];if(e===void 0)return null;const i={id:e};return i.matrix=this._instanceMatrixArray.slice(16*t,16*(t+1)),i}has(t){return this._idIndexMap[t]!==void 0}clear(){this._idIndexMap={},this._indexIdMap={},this._instanceMatrixArray=new Float32Array(1600),this._instanceColorArray=new Float32Array(300).fill(1),this._instanceMatrixArraySize=100,this._currentCount=0,this._rtc=null}setBufferData(t){this.clear(),this.addInstances(t)}setColor(t,e){e?this._colorMap[t]=e:delete this._colorMap[t]}addInstances(t){if(!t)return;const e=t.id,i=e.length;if(i!==0)if(this._currentCount+i>this._instanceMatrixArraySize&&this.expandInstanceArray(i),t.instanceMatrix)this._instanceMatrixArray.set(t.instanceMatrix,16*this._currentCount),this._currentCount+=i;else{const n=t.translation,r=t.scale,a=t.rotation,o=t.color,l=this._instanceMatrixArray,h=this._instanceColorArray;let c=new rt,u=new M,p=new M,m=new Wi,f=new Ht,g=null,_=null,v=this._rtc;v||(n?(v=[n[0],n[1],n[2]],this._rtc=v,this.position.set(v[0],v[1],v[2])):v=[0,0,0]);for(let x=0;x<i;x++){let y=3*x;if(r?p.set(r[y],r[y+1],r[y+2]):p.set(1,1,1),n?u.set(n[y]-v[0],n[y+1]-v[1],n[y+2]-v[2]):u.set(0,0,0),a?m.set(a[y],a[y+1],a[y+2],"XYZ"):m.set(0,0,0,"XYZ"),y=3*(this._currentCount+x),o[x]){const{r:S,g:w,b:C}=new tt(o[x]),L=[S,w,C];for(let T=0;T<3;T++)h[y+T]=L[T]}f.setFromEuler(m),c.compose(u,f,p),y=16*(this._currentCount+x);const b=c.elements;for(let S=0;S<16;S++)l[y+S]=b[S];g=e[x],_=this._currentCount+x,this._idIndexMap[g]=_,this._indexIdMap[_]=g}this._currentCount+=i}}removeInstance(t){this.removeInstances({id:[t]})}removeInstances(t){const e=t.id,i=e.length;if(i!==0)for(let n=0;n<i;++n){const r=e[n],a=this._idIndexMap[r];if(a===void 0){console.warn(`remove an item ${r} not exist`);continue}const o=this._currentCount-1;if(!(a>o)){if(a<o){this.copyArrayData(this._instanceMatrixArray,16*a,this._instanceMatrixArray,16*o,16);const l=this._indexIdMap[o];this._indexIdMap[a]=l,this._idIndexMap[l]=a,delete this._idIndexMap[r]}this._currentCount--}}}update(){const t=this.children;for(const e of t)e.instanceMatrix=new Xi(this._instanceMatrixArray,16),e.instanceColor=new Xi(this._instanceColorArray,3),e.count=this._currentCount;Object.keys(this._colorMap).forEach(e=>{const i=this._idIndexMap[e];i>-1&&this.children.forEach(n=>{n.setColorAt(i,this._colorMap[e]),n.instanceColor.needsUpdate=!0,n.needsUpdate=!0})})}set meshes(t){t&&(Array.isArray(t)?this._meshes=t:t.isMesh?this._meshes=[t]:t.isGroup&&(this._meshes=t.children),this.updateRenderingMesh(),this.update())}set needsUpdate(t){t&&this.update()}get meshes(){return this._meshes}}class Pg extends St{constructor(t){super(),d(this,"_lodMeshes",[]),d(this,"_lodChildren",{}),this._lodMeshes=t||[]}addInstances(t,e=0){let i=this._lodChildren[e];if(!i){let n=this._lodMeshes[e];n||(n=this._lodMeshes[this._lodMeshes.length-1]),i=new Au(n),this._lodChildren[e]=i,this.add(i)}i&&i.addInstances(t)}removeInstances(t,e=0){const i=this._lodChildren[e];i&&i.removeInstances(t)}setMeshesAt(t,e=0){this._lodMeshes[e]=t;const i=this._lodChildren;i[e]&&(i[e].meshes=t)}setLODMeshes(t){for(let e=0;e<t.length;e++){const i=t[e];this.setMeshesAt(i,e)}}set needsUpdate(t){if(t){const e=this.children;for(const i of e)i&&(i.needsUpdate=!0)}}}const IM={pars:"",main_before:"",main_after:"",project_after:"",worldpos_after:""},OM={pars:"",main_before:"",color_after:"",custom_map:""};class jl extends Zt{constructor(t){super(),d(this,"getShaderSource",(a,o,l,h)=>{const c=Object.assign({},o,l);for(const u of Object.keys(c)){const p=c[u];a=a.replace("#chunk <"+h+"_"+u+">",p)}return a}),d(this,"setCommonUniforms",a=>{for(const o of Object.keys(a))this.uniforms[o]=a[o]}),this.lights=!0,this.fog=!0,this.type="ExtendMeshStandardMaterial",this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.defineMaterialNormalProperties=jt,this.defineMaterialAliasProperties=_i,jt(this,["roughness","metalness","map","lightMap","aoMap","emissive","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap","envMap"]),_i(this,[["color","diffuse"]]),this.uniforms=pt.clone(pt.merge([oi.standard.uniforms,t.uniforms])),this.color=new tt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new tt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Hn,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1;const{vertexShaderChunks:e,fragmentShaderChunks:i,uniforms:n,...r}=t;this.setValues(r),this.vertexShaderChunks=e,this.fragmentShaderChunks=i}set vertexShaderChunks(t){this.vertexShader=this.getShaderSource(`#define GLSLIFY 1
#define STANDARD

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

	varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#chunk <vertex_pars>

void main() {

    #chunk <vertex_main_before>

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#chunk <vertex_project_after>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#chunk <vertex_worldpos_after>
	#include <shadowmap_vertex>
	#include <fog_vertex>

#ifdef USE_TRANSMISSION

	vWorldPosition = worldPosition.xyz;

#endif
    #chunk <vertex_main_after>
}`,IM,t,"vertex"),this.needsUpdate=!0}set fragmentShaderChunks(t){this.fragmentShader=this.getShaderSource(`#define GLSLIFY 1
#define STANDARD

#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
	uniform float ior;
#endif

#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;

	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif

	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif

#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;

	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif

	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

#chunk <fragment_pars>

void main() {

	#ifdef USE_MAP
    	vec2 uv = vec2(vUv);
	#endif
    #chunk <fragment_main_before>
	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#ifdef USE_MAP

		#ifdef USE_CUSTOM_MAP
			 #chunk <fragment_custom_map>
		#else
			vec4 sampledDiffuseColor = texture2D( map, uv );
		#endif

        #ifdef DECODE_VIDEO_TEXTURE

            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)

            sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );

        #endif

        diffuseColor *= sampledDiffuseColor;

    #endif
	#include <color_fragment>
    #chunk <fragment_color_after>
	#ifdef USE_ALPHAMAP

        diffuseColor.a *= texture2D( alphaMap, uv ).g;

    #endif
	#include <alphatest_fragment>
	float roughnessFactor = roughness;

    #ifdef USE_ROUGHNESSMAP

        vec4 texelRoughness = texture2D( roughnessMap, uv );

        // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
        roughnessFactor *= texelRoughness.g;

    #endif
	float metalnessFactor = metalness;

    #ifdef USE_METALNESSMAP

        vec4 texelMetalness = texture2D( metalnessMap, uv );

        // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
        metalnessFactor *= texelMetalness.b;

    #endif
	#include <normal_fragment_begin>
	#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

    #elif defined( TANGENTSPACE_NORMALMAP )

        vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;
        mapN.xy *= normalScale;

        #ifdef USE_TANGENT

            normal = normalize( vTBN * mapN );

        #else

            normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );

        #endif

    #elif defined( USE_BUMPMAP )

        normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

    #endif
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#ifdef USE_EMISSIVEMAP

        vec4 emissiveColor = texture2D( emissiveMap, uv );

        totalEmissiveRadiance *= emissiveColor.rgb;

    #endif

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	#include <transmission_fragment>

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	#ifdef USE_SHEEN

		// Sheen energy compensation approximation calculation can be found at the end of
		// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

	#endif

	#ifdef USE_CLEARCOAT

		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

	#endif

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}`,OM,t,"fragment"),this.needsUpdate=!0}dispose(){let t=["map","lightMap","aoMap","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap","envMap","specularIntensityMap","specularColorMap","sheenColorMap","sheenRoughnessMap"];for(let e=0;e<t.length;e++){const i=t[e];this[i]&&this[i].dispose()}super.dispose()}}const zM={pars:`
        uniform float elapsedTime;
        uniform vec3 windDirection;
        uniform float windStrength;
    `,main_after:`
        
    `,project_after:`
    vec4 modelPosition = vec4( transformed, 1.0 );
    #ifdef USE_INSTANCING
        modelPosition = instanceMatrix * modelPosition;
    #endif
    modelPosition = modelMatrix * modelPosition;

    float dirDot = abs(dot(windDirection, normal));
    float period = 1500.0 * dirDot + 500.0;
    period = sin(mod(elapsedTime, period) / period * PI * 2.0);
    period = (period + 1.0) / 2.0;
    vec3 worldPositionOffset = windDirection * windStrength * period * dirDot;
    modelPosition.xyz += worldPositionOffset;

    mvPosition = viewMatrix * modelPosition;
    gl_Position = projectionMatrix * mvPosition;
    `,worldpos_after:`
    #if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
        worldPosition.xyz += worldPositionOffset;
    #endif
    `},kM={pars:`
    `,main_before:`
    `,color_after:`
    `};class Gl extends jl{constructor(t={}){super({uniforms:{windDirection:{value:[1,0,0]},windStrength:{value:.5}}}),this.vertexShaderChunks=zM,this.fragmentShaderChunks=kM,this.setValues(t)}get windDirection(){return this.uniforms.windDirection.value}set windDirection(t){this.uniforms.windDirection.value=t}get windStrength(){return this.uniforms.windStrength.value}set windStrength(t){this.uniforms.windStrength.value=t}static fromMaterial(t,e){const i=new Gl(e);return i.map=t.map,i.alphaTest=t.alphaTest,i.metalness=t.metalness,i.roughness=t.roughness,i.side=t.side,i.vertexColors=t.vertexColors,i}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const Rg=s=>{if(s.isMesh)s.geometry.applyMatrix4(s.matrixWorld);else if(s.children.length>0)for(const t of s.children)Rg(t);s.position.set(0,0,0),s.scale.set(1,1,1),s.quaternion.set(0,0,0,1)},Dg=(s,t)=>{if(s.isMesh)t.push(s);else if(s.children.length>0)for(const e of s.children)Dg(e,t)},Wl=(s,t,e)=>{t&&(n=>{const r=new He;r.setFromObject(n);const a=Math.max(r.max.x-r.min.x,r.max.y-r.min.y,r.max.z-r.min.z);n.scale.multiplyScalar(1/a)})(s),e&&(s.rotation.x=Math.PI/2),s.updateMatrixWorld(),Rg(s),s.updateMatrixWorld();const i=[];return Dg(s,i),i},Lg=(s,t,e)=>{const i=[];for(const n of s){const r=n.name;if(!r.startsWith("lod"))continue;const a=parseInt(r.substring(3),10);if(isNaN(a))continue;const o=Wl(n,t,e);i[a]=o}return i},NM=Object.freeze(Object.defineProperty({__proto__:null,parseLODModel:Lg,parseScene:Wl},Symbol.toStringTag,{value:"Module"})),UM=new ea;class FM{constructor(){d(this,"_lastUpdateTime",0),d(this,"_updateDelayTimerHander",null),d(this,"_configVersion",0),d(this,"_treeEnabled",!0),d(this,"_labelEnabled",!1),d(this,"_idEnabled",!1),d(this,"_dataTypeEnabled",!1),d(this,"markNeedsUpdate",()=>{this._updateDelayTimerHander||(this._updateDelayTimerHander=setTimeout(()=>{this._tree.needsUpdate=!0,this.engine.requestRender(),this._updateDelayTimerHander=null},100))}),d(this,"parseInstancedData",(e,i)=>{const n=e.geometry,r=i.__id,a=n.attributes.position,o=a.count;if(o===0)return;const l=[];i.__lodLevel;const h=n.attributes.scale,c=n.attributes.rotation,u=new Float32Array(3*o),p=new Float32Array(3*o),m=new Float32Array(3*o),f=i.cached.scene.matrix,g=new M;for(let v=0;v<o;v++)g.set(a.getX(v),a.getY(v),a.getZ(v)),g.applyMatrix4(f),u[3*v]=g.x,u[3*v+1]=g.y,u[3*v+2]=g.z,p[3*v]=h.getX(v),p[3*v+1]=h.getY(v),p[3*v+2]=h.getZ(v),m[3*v]=c.getX(v),m[3*v+1]=c.getY(v),m[3*v+2]=c.getZ(v),l.push(r+"-"+v);const _={translation:u,scale:p,rotation:m,id:l};i.__instanceData=_}),d(this,"parseLabelData",(e,i)=>{const n=e.geometry,r=i.__id,a=n.attributes.position,o=a.count;if(o===0)return;const l=n.attributes.rotation,h=i.cached.scene,c=h.matrix,u=h.batchTable.header.text,p=[],m=new M;for(let f=0;f<o;f++)m.set(a.getX(f),a.getY(f),a.getZ(f)),m.applyMatrix4(c),p.push({id:r+"-"+f,type:"flat",position:[m.x,m.y,m.z],text:u[f],rotateZ:l.getZ(f)});i.__labelData=p}),d(this,"remapBatchValueToNumber",e=>e?isFinite(e)?e=Math.round(e%100):typeof e=="string"?(e=e.charCodeAt(3)||0)%100:0:0),d(this,"parseBatchTableAttribute",(e,i,n)=>{const r=e.cached.scene,a=r.children,o=r.batchTable&&r.batchTable.header;if(!o)return;const l=o[i];if(l)for(const h of a){if(h.originalMaterialName==="_tree"||h.originalMaterialName==="_label")continue;const c=h.geometry,u=c.getAttribute("_batchid");if(!u)continue;const p=u.data.count;let m=-1,f=0;const g=[];for(let _=0;_<p;_++)m=u.getX(_),f=this.remapBatchValueToNumber(l[m]),g.push(f);c.attributes[n]=new se(new Float32Array(g),1)}}),d(this,"onTileLoad",(e,i)=>{}),d(this,"onTileDispose",(e,i)=>{}),d(this,"onTileShow",e=>{this.refreshTile(e)}),d(this,"onTileHide",e=>{const i=e.__instanceData;e.__hasAddInstancedData&&i&&(this._tree.removeInstances(i,e.__lodLevel),e.__hasAddInstancedData=!1,this.markNeedsUpdate());const n=e.__labelData;e.__hasAddLabelData&&n&&(this.engine.rendering.label.removeLabels(n),e.__hasAddLabelData=!1)}),d(this,"refreshTile",e=>{const i=e.cached.scene.children;if(e.__instanceConfigVersion!==this._configVersion){for(const a of i)a.originalMaterialName==="_tree"?(a.visible=!1,this._treeEnabled&&!e.__instanceTreeParsed&&(this.parseInstancedData(a,e),e.__instanceTreeParsed=!0)):a.originalMaterialName==="_label"&&(a.visible=!1,this._labelEnabled&&!e.__instanceLabelParsed&&(this.parseLabelData(a,e),e.__instanceLabelParsed=!0));this._idEnabled&&!e.__instanceIdParsed&&(this.parseBatchTableAttribute(e,"id","_id"),e.__instanceIdParsed=!0),this._dataTypeEnabled&&!e.__instanceDataTypeParsed&&(this.parseBatchTableAttribute(e,"dataType","_dataType"),e.__instanceDataTypeParsed=!0),e.__instanceConfigVersion=this._configVersion}const n=e.__instanceData;n&&(this._treeEnabled&&!e.__hasAddInstancedData&&(this._tree.addInstances(n,e.__lodLevel),this.markNeedsUpdate(),e.__hasAddInstancedData=!0),!this._treeEnabled&&e.__hasAddInstancedData&&(this._tree.removeInstances(n,e.__lodLevel),this.markNeedsUpdate(),e.__hasAddInstancedData=!1));const r=e.__labelData;r&&(this._labelEnabled&&!e.__hasAddLabelData&&(this.engine.rendering.label.addLabels(r,e.__lodLevel),e.__hasAddLabelData=!0),!this._labelEnabled&&e.__hasAddLabelData&&(this.engine.rendering.label.removeLabels(r,e.__lodLevel),e.__hasAddLabelData=!1))}),d(this,"refreshTiles",()=>{this.tilesRenderer.forEachLoadedModel((e,i)=>{i.__visible&&this.refreshTile(i)}),this.engine.requestRender()}),d(this,"updateTreeModelPath",e=>{UM.load(e,i=>{const n=Lg(i.scenes,!0,!0);for(const r of n)for(const a of r){if(a.material.name==="__foliage_leaf"){const o=Gl.fromMaterial(a.material);o.setCommonUniforms(this.engine.rendering.uniforms),a.material=o}a.castShadow=!0,a.receiveShadow=!0}this._tree.setLODMeshes(n)})}),this.group=new De;const t=this._tree=new Pg;this.updateTreeModelPath(Jt("assets/models/tree/tree18.glb")),this.group.add(t)}set treeModelPath(t){this.updateTreeModelPath(t)}set treeEnabled(t){this._treeEnabled=t,this._configVersion++,this.refreshTiles()}get treeEnabled(){return this._treeEnabled}set labelEnabled(t){this._labelEnabled=t,this._configVersion++,this.refreshTiles()}get labelEnabled(){return this._labelEnabled}set idEnabled(t){this._idEnabled=t,this._configVersion++,this.refreshTiles()}get idEnabled(){return this._idEnabled}set dataTypeEnabled(t){this._dataTypeEnabled=t,this._configVersion++,this.refreshTiles()}get dataTypeEnabled(){return this._dataTypeEnabled}}class BM{constructor(){d(this,"_configVersion",0),d(this,"_deletedIds",new Set),d(this,"_needsRefreshAll",!1),d(this,"updateEditableAttribute",t=>{const e=t.cached.scene,i=e.children,n=e.batchTable&&e.batchTable.header;if(!n)return;const r=n.id;if(!r)return;const a=this._deletedIds;for(const o of i){const l=o.geometry,h=l.getAttribute("_batchid");if(!h)continue;const c=h.data.count;let u=-1,p=0;const m=[];for(let f=0;f<c;f++)u=h.getX(f),p=r[u]+"",a.has(p)||this.shouldBeHidden(n,u)?m.push(1):m.push(0);l.attributes._tileEditableValue=new se(new Float32Array(m),1)}}),d(this,"shouldBeHidden",(t,e)=>!1),d(this,"onTileLoad",(t,e)=>{t.__editableConfigVersion=0}),d(this,"onTileDispose",(t,e)=>{}),d(this,"onTileShow",t=>{this.refreshTile(t)}),d(this,"onTileHide",t=>{}),d(this,"refreshTile",t=>{t.cached.scene.children,t.__editableConfigVersion!==this._configVersion&&(this.updateEditableAttribute(t),t.__editableConfigVersion=this._configVersion)}),d(this,"refreshTiles",()=>{this._needsRefreshAll&&this.tilesRenderer.forEachLoadedModel((t,e)=>{e.__visible&&this.refreshTile(e)})})}addDeletedId(t){t+="",this._deletedIds.add(t),this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}addDeletedIds(t){for(let e=0;e<t.length;e++){const i=t[e]+"";this._deletedIds.add(i)}this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}removeDeletedId(t){t+="",this._deletedIds.delete(t),this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}removeDeletedIds(t){for(let e=0;e<t.length;e++){const i=t[e]+"";this._deletedIds.delete(i)}this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}hasDeletedId(t){return this._deletedIds.has(t)}requestUpdate(){this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}}const ui={},Pu={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}};let oa={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},Ru={},ii={east:new M,north:new M,up:new M,west:new M,south:new M,down:new M},Ks=new M,Qs=new M,$s=new M;const Xl=s=>s!==void 0,VM=new M,HM=new M(1/40680631590769,1/40680631590769,1/40408299984661445e-3),cs=new M,ql=new M,Ig=function(s,t,e=0,i){const n=new M(40680631590769,40680631590769,40408299984661445e-3),r=Math.cos(t);cs.x=r*Math.cos(s),cs.y=r*Math.sin(s),cs.z=Math.sin(t),cs.normalize(),ql.multiplyVectors(n,cs);const a=Math.sqrt(cs.dot(ql));return ql.divideScalar(a),cs.multiplyScalar(e),Xl(i)||(i=new M),i.addVectors(ql,cs)};ui.lnglatToEcef=(s,t,e=0,i)=>Ig(s*Math.PI/180,t*Math.PI/180,e,i),ui.radianToEcef=Ig,ui.localFrameToFixedFrameGenerator=function(s,t){if(!Pu.hasOwnProperty(s)||!Pu[s].hasOwnProperty(t))throw new Error("firstAxis and secondAxis must be east, north, up, west, south or down.");let e,i=Pu[s][t],n=s+t;return Xl(Ru[n])?e=Ru[n]:(e=function(r,a){if(!Xl(r))throw new Error("origin is required.");if(Xl(a)||(a=new rt),r.equals(VM))Ks.fromArray(oa[s]),Qs.fromArray(oa[t]),$s.fromArray(oa[i]);else if(Math.abs(r.x)<1e-14&&Math.abs(r.y)<1e-14){let h=(o=+(o=r.z))==0?o:o>0?1:-1;Ks.fromArray(oa[s]),s!=="east"&&s!=="west"&&Ks.multiplyScalar(h),Qs.fromArray(oa[t]),t!=="east"&&t!=="west"&&Qs.multiplyScalar(h),$s.fromArray(oa[i]),i!=="east"&&i!=="west"&&$s.multiplyScalar(h)}else{((u,p)=>{p.multiplyVectors(u,HM).normalize()})(r,ii.up);let h=ii.up,c=ii.east;c.x=-r.y,c.y=r.x,c.z=0,ii.east.copy(c).normalize(),ii.north.crossVectors(h,c),ii.down.copy(ii.up).multiplyScalar(-1),ii.west.copy(ii.east).multiplyScalar(-1),ii.south.copy(ii.north).multiplyScalar(-1),Ks=ii[s],Qs=ii[t],$s=ii[i]}var o;const l=a.elements;return l[0]=Ks.x,l[1]=Ks.y,l[2]=Ks.z,l[3]=0,l[4]=Qs.x,l[5]=Qs.y,l[6]=Qs.z,l[7]=0,l[8]=$s.x,l[9]=$s.y,l[10]=$s.z,l[11]=0,l[12]=r.x,l[13]=r.y,l[14]=r.z,l[15]=1,a},Ru[n]=e),e},ui.eastNorthUpToFixedFrame=ui.localFrameToFixedFrameGenerator("east","north"),ui.northEastDownToFixedFrame=ui.localFrameToFixedFrameGenerator("north","east"),ui.northUpEastToFixedFrame=ui.localFrameToFixedFrameGenerator("north","up"),ui.northWestUpToFixedFrame=ui.localFrameToFixedFrameGenerator("north","west");const Og=(s,t)=>s.__inFrustum!==t.__inFrustum?s.__inFrustum?1:-1:s.__depth!==t.__depth?s.__depth>t.__depth?-1:1:s.__error!==t.__error?s.__error>t.__error?1:-1:s.__used!==t.__used?s.__used?1:-1:s.__distanceFromCamera!==t.__distanceFromCamera?s.__distanceFromCamera>t.__distanceFromCamera?-1:1:0;Su.prototype.setTileVisible=function(s,t){const e=s.cached.scene,i=this.visibleTiles,n=this.group;t?(n.add(e),i.add(s),e.updateMatrixWorld(!0)):(n.remove(e),i.delete(s)),this.onTileVisibleChanged&&this.onTileVisibleChanged(s,t)};class Yl{constructor(){d(this,"_materrialMap",new Map),d(this,"_inited",!1)}init(){this._inited||(this.onInit(),this._inited=!0)}onInit(){}getMaterialByKey(t){return this._materrialMap.get(t)}dispose(){this.beforeDispose();for(const t of Object.keys(this._materrialMap))this._materrialMap[t].dispose()}beforeDispose(){}}const Du=new Ie().load(Jt("assets/textures/water/waternormal.jpg"));Du.wrapS=Du.wrapT=ze;const jM=pt.merge([ot.fog,{normalMap:{value:null},alpha:{value:1},time:{value:0},size:{value:10},distortionScale:{value:2},textureMatrix:{value:new rt},sunColor:{value:new tt(16777215)},sunDirection:{value:new M(.70707,.70707,0)},eye:{value:new M},waterColor:{value:new tt(8956603)},reflectionColor:{value:new tt(8956603)},envMap:{value:null},mvt_normalMatrix:{value:new Ke}}]);class zg extends Be{constructor(t={}){super(),d(this,"_timeScaleFactor",1e-4),this.type="WaterMaterial",this.vertexShader=`#define GLSLIFY 1
uniform mat4 textureMatrix;
uniform float time;

varying vec4 mirrorCoord;
varying vec4 worldPosition;

#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() {
    mirrorCoord = modelMatrix * vec4(position, 1.0);
    worldPosition = mirrorCoord.xyzw;
    mirrorCoord = textureMatrix * mirrorCoord;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <logdepthbuf_vertex>
    #include <fog_vertex>
    #include <shadowmap_vertex>
}`,this.fragmentShader=`precision highp float;
precision highp int;
#define GLSLIFY 1

// uniform sampler2D mirrorSampler;
uniform float alpha;
uniform float time;
uniform float size;
uniform float distortionScale;
uniform sampler2D normalMap;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform vec3 eye;
uniform vec3 waterColor;
#ifdef USE_ENVMAP
    uniform sampler2D envMap;
#else
    uniform vec3 reflectionColor;
#endif
uniform mat3 mvt_normalMatrix;

varying vec4 mirrorCoord;
varying vec4 worldPosition;

vec4 getNoise(vec2 uv) {
    vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);
    vec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);
    vec2 uv2 = uv / vec2(8907.0, 9803.0) + vec2(time / 101.0, time / 97.0);
    vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);
    vec4 noise = texture2D(normalMap, uv0) +
        texture2D(normalMap, uv1) +
        texture2D(normalMap, uv2) +
        texture2D(normalMap, uv3);
    return noise * 0.5 - 1.0;
}

void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor) {
    vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));
    float direction = max(0.0, dot(eyeDirection, reflection));
    specularColor += pow(direction, shiny) * sunColor * spec;
    diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;
}

#define ENVMAP_TYPE_CUBE_UV

#include <common>
#include <packing>

#include <bsdfs>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

#include <cube_uv_reflection_fragment>

#define MVT_FRAG_REFLECTION_FACTOR
#define MVT_FRAG_NORMAL

void main() {

	#include <logdepthbuf_fragment>
    vec4 noise = getNoise(worldPosition.xy * size);
    vec3 surfaceNormal = normalize(noise.xyz * vec3(1.5, 1.5, 1.0));

    vec3 diffuseLight = vec3(0.0);
    vec3 specularLight = vec3(0.0);

    vec3 worldToEye = cameraPosition - worldPosition.xyz;
    vec3 eyeDirection = normalize(worldToEye);
    sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);

    float distance = length(worldToEye);

    vec2 distortion = surfaceNormal.xy * (0.001 + 1.0 / distance) * distortionScale;
    // vec3 reflectionSample = vec3(texture2D(mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion));
    vec3 reflectDir = reflect(vec3(-worldToEye.x, -worldToEye.y, -worldToEye.z), vec3(0.0, 0.0, 1.0));
    reflectDir.xy += distortion;

    #ifdef USE_ENVMAP
        vec3 reflectionSample = textureCubeUV(envMap, reflectDir, 0.0).xyz;
    #else
        vec3 reflectionSample = reflectionColor;
    #endif

    float theta = max(dot(eyeDirection, surfaceNormal), 0.0);
    float rf0 = 0.3;
    float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta), 5.0);
    vec3 scatter = max(0.0, dot(surfaceNormal, eyeDirection)) * waterColor;
    vec3 albedo = mix((sunColor * diffuseLight * 0.3 + scatter) * getShadowMask(), (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);
    vec3 outgoingLight = albedo;
    gl_FragColor = vec4(outgoingLight, alpha);
    float mvt_frag_reflectionFactor = 1.0;
    // vec3 mvt_frag_normal = vec3(0., 0., 1.0) * mvt_normalMatrix;
    vec3 mvt_frag_normal = normalize(noise.xyz * vec3(0.2, 0.2, 1.0)) * mvt_normalMatrix;
    // gl_FragColor = worldPosition;
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
}`,this.isWaterMaterial=!0,Object.assign(this.uniforms,pt.clone(jM)),this.defines={CUBEUV_TEXEL_WIDTH:.0003255208333333333,CUBEUV_TEXEL_HEIGHT:.000244140625,CUBEUV_MAX_MIP:"10.0"},jt(this,["sunColor","waterColor","reflectionColor","size","alpha","distortionScale"]),Object.defineProperties(this,{}),this.uniforms.normalMap.value=Du,this.setValues(t)}onBeforeSceneRender(t,e,i){if(this.uniforms.eye.value.copy(i.position),this.uniforms.time.value=t.rendering.uniforms.elapsedTime.value*this._timeScaleFactor,this.uniforms.envMap.value!==e.environment){this.uniforms.envMap.value=e.environment;const r=Ym(e.environment);r&&(this.defines.CUBEUV_TEXEL_WIDTH=r.texelWidth,this.defines.CUBEUV_TEXEL_HEIGHT=r.texelHeight,this.defines.CUBEUV_MAX_MIP=r.maxMip+".0"),e.environment?this.defines.USE_ENVMAP=!0:delete this.defines.USE_ENVMAP}this.uniforms.mvt_normalMatrix.value.getNormalMatrix(i.matrixWorld);const n=t.rendering.sky;n&&this.uniforms.sunDirection.value.copy(n.sunDirection)}get timeScaleFactor(){return this._timeScaleFactor}set timeScaleFactor(t){this._timeScaleFactor=t}dispose(){let t=["envMap","normalMap"];for(let e=0;e<t.length;e++){const i=t[e];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}super.dispose()}}const la=new Ie,GM=new tt(16777215);class WM extends Zt{constructor(t){super(),this.fragmentShader=`#define GLSLIFY 1
#include <common>
varying vec3 vIdColor;
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    gl_FragColor = vec4(vIdColor.xyz, 1.0);

}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
#ifdef MVT_TYPE_DATATYPE
attribute float _dataType;
#else 
attribute float _id;
#endif

varying vec3 vIdColor;
#include <logdepthbuf_pars_vertex>
void main() { 
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    #ifdef MVT_TYPE_DATATYPE
         float value = _dataType * 0.2536789535;
         vIdColor = vec3(mod(value, 0.1) * 9.0, mod(value, 0.01) * 90.0, mod(value, 0.001) * 900.0);
        // vIdColor = vec3(mod(_dataType * 0.2, 0.7), mod(1.0 - mod(_dataType * 0.835, 1.0), 0.4) + 0.4, mod(_dataType * 0.57245, 0.2) + 0.2);
    #else 
        float value = (_id + 9.3234242) * 0.2536789535;
         vIdColor = vec3(mod(value, 0.1) * 10.0, mod(value, 0.01) * 100.0, mod(value, 0.001) * 1000.0);
        // vIdColor = vec3(mod(_id * 0.2, 0.7), mod(1.0 - mod(_id * 0.835, 1.0), 0.7), mod(_id * 0.57245, 0.5));
    #endif
    
    #include <logdepthbuf_vertex>
}`,this.defines={MVT_TYPE_ID:!0},this.type=1,this.setValues(t)}set type(t){t===1?(this.defines.MVT_TYPE_ID=!0,delete this.defines.MVT_TYPE_DATATYPE):t===2&&(this.defines.MVT_TYPE_DATATYPE=!0,delete this.defines.MVT_TYPE_ID),this.needsUpdate=!0}get type(){return this.defines.MVT_TYPE_DATATYPE?2:1}}class kg{constructor(t){d(this,"_parent",null),d(this,"_material",null),d(this,"subscribedDataTypeIds",[]),d(this,"_positionScaleFactor",1.3),d(this,"_tileObjectMap",new Map),d(this,"_idObjectMap",new Map),d(this,"_objectDataMap",new Map),d(this,"_visibleIdMap",new Map),d(this,"_scaleSize",.05),d(this,"_tickInterval",500),d(this,"_lastTickTime",0),this._parent=t}set parent(t){this._parent=t}createMeshFromGeometry(t){return this._material||(this._material=new ae({color:16777130}),this._material.emissive=new tt(16777130)),new lt(t,this._material)}addTileElementObjects(t,e){const i=t.cached.scene,n=[];for(const r of e){const a=this.createMeshFromGeometry(r.geometry,r);a.userData.id=r.id;const o=r.geometry.getAttribute("position").array,l=r.geometry.getAttribute("normal").array;for(let h=0,c=o.length-2;h<c;h+=3)o[h]=o[h]+this._scaleSize*l[h],o[h+1]=o[h+1]+this._scaleSize*l[h+1],o[h+2]=o[h+2]+this._scaleSize*l[h+2];a.position.copy(i.position),a.rotation.copy(i.rotation),a.scale.copy(i.scale),a.__tile=t,n.push(a),this._objectDataMap.set(a,r)}this._tileObjectMap.set(t,n)}onEntityShow(t,e){}showTileElementObjects(t){const e=this._tileObjectMap.get(t);if(e)for(const i of e){const n=i.userData.id;this._visibleIdMap.set(n,i),this.onEntityShow(n,i),this._parent.add(i)}}hideTileElementObjects(t){const e=this._tileObjectMap.get(t);if(e)for(const i of e){const n=i.userData.id;this._visibleIdMap.get(n)===i&&this._visibleIdMap.delete(n),this._parent.remove(i)}}disposeTileElementObjects(t){const e=this._tileObjectMap.get(t);if(e){for(const i of e)i.parent&&i.parent.remove(i),this._objectDataMap.delete(i),i.geometry.dispose();this._tileObjectMap.delete(t)}}doTick(t){for(const e of this._visibleIdMap.keys()){const i=this._visibleIdMap.get(e);this.tickObject(i,t)}}tickObject(t,e){}tick(t){this._tickInterval<=0||t-this._lastTickTime>this._tickInterval&&(this._lastTickTime=t,this.doTick(t))}dispose(){this._material&&this._material.dispose(),this._tileObjectMap.forEach((t,e)=>{for(const i of t)this._parent.remove(i)})}}class XM extends St{constructor(t){super(),this.geometry=t;const e=this.material=new ae({color:16777130});e.emissive=new tt(16777130);const i=this.mesh=new lt(t,e);this.add(i)}set color(t){t.isColor||(t=new tt(t)),this.material.color=t,this.material.emissive=t}get color(){return this.material.color}}const Ng=new Ie,Zl=Ng.load(Jt("assets/textures/element/traffic_light_mask.jpg"));Zl.flipY=!1,Zl.magFilter=Zl.minFilter=Ft;const Jl=Ng.load(Jt("assets/textures/element/traffic_light_number_mask.jpg"));Jl.flipY=!1,Jl.magFilter=Jl.minFilter=Ft;const qM=pt.merge([ot.fog,is,{spriteCount:{value:16},slotCount:{value:3},slotSpriteOffset0:{value:0},slotSpriteOffset1:{value:0},slotSpriteOffset2:{value:0},slotSpriteOffset3:{value:0},slotState0:{value:0},slotState1:{value:0},slotState2:{value:0},slotState3:{value:0},maskMap:{value:null},numberMaskMap:{value:null},number:0,redColor:{value:[1,.1,.1]},greenColor:{value:[.1,1,.1]},yellowColor:{value:[1,.6,.1]}}]);class YM extends Be{constructor(t={}){super(),this.type="TrafficLightMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

#include <logdepthbuf_pars_vertex>

varying vec2 vUv;
void main() { 
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#include <logdepthbuf_pars_fragment>
uniform sampler2D maskMap;
uniform sampler2D numberMaskMap;
uniform float spriteCount;

// 最多4个槽位，
uniform float slotCount;
// 每个槽位图标的偏移位置， -1代表当前槽位是倒数读秒数
uniform float slotSpriteOffset0;
uniform float slotSpriteOffset1;
uniform float slotSpriteOffset2;
uniform float slotSpriteOffset3;

// 每个slot的状态，0，1，2，3 分别代表关、红、黄、绿，后续考虑合并到一个变量中
uniform float slotState0;
uniform float slotState1;
uniform float slotState2;
uniform float slotState3;

uniform float number;
varying vec2 vUv;

uniform vec3 redColor;
uniform vec3 greenColor;
uniform vec3 yellowColor;

//#include <mvt_mrt_output_pars_fragment>

void main() {

    // 当前像素落在哪个槽位
    float slotIndex = floor(vUv.y * slotCount);
    float currentSlotState = 0.0;
    float spriteIndex = 0.0;
    if (slotIndex == 0.0) {
        currentSlotState = slotState0;
        spriteIndex = slotSpriteOffset0;
    }
    else if (slotIndex == 1.0) {
        currentSlotState = slotState1;
        spriteIndex = slotSpriteOffset1;
    }
    else if (slotIndex == 2.0) {
        currentSlotState = slotState2;
        spriteIndex = slotSpriteOffset2;
    }
    else if (slotIndex == 3.0) {
        currentSlotState = slotState3;
        spriteIndex = slotSpriteOffset3;
    }
    if (currentSlotState == 0.0) {
        discard;
    }
    vec3 outColor;
    if (currentSlotState == 1.0) {
        outColor = redColor;
    }
    else if (currentSlotState == 2.0) {
        outColor = yellowColor;
    }
    else if (currentSlotState == 3.0) {
        outColor = greenColor;
    }
    //float slotRatio = 1.0 / spriteCount;
    // 将高亮区域的v缩放到0-1
    float v = (vUv.y - float(slotIndex) / slotCount) * slotCount;
    // v = v * 0.98 + 0.01;

    float u = 0.0;
    float spriteUnit = 1.0 / spriteCount;

    // 数字
    if (spriteIndex == -1.0) {
        // gl_FragColor = vec4(1.0, 0, 0, 1.0);
        float i1 = floor((number + 0.001) / 10.0);
        float i2 = floor(mod(number, 10.0));
        if (vUv.x < 0.5) {
            u = mix(i1 * 0.1, i1 * 0.1 + 0.1, vUv.x * 2.0);
        }
        else {
            u = mix(i2 * 0.1, i2 * 0.1 + 0.1, (vUv.x - 0.5) * 2.0);
        }
        float r = texture2D(numberMaskMap, vec2(u, v)).r;
        if (r < 0.05) {
            discard;
        }
    }
    else {
        u = mix(spriteIndex * spriteUnit, (spriteIndex + 1.0) * spriteUnit, vUv.x);
        float r = texture2D(maskMap, vec2(u, v)).r;
        if (r < 0.05) {
            discard;
        }
    }
    
    // gl_FragColor = vec4(texture2D(maskMap, vec2(u, v)).xyz, 1.0);
    gl_FragColor = vec4(outColor, 1.0);
    #include <logdepthbuf_fragment> 
	//#include <mvt_mrt_output_fragment>
}`,this.isTrafficLightMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,pt.clone(qM)),jt(this,["slotState0","slotState1","slotState2","slotState3","number","redColor","greenColor","yellowColor"]),ss(this),Object.defineProperties(this,{slotConfig:{get:function(){return this._slotConfig},set:function(e){this._slotConfig=e,this.uniforms.slotCount.value=e.length,this.uniforms.slotSpriteOffset0.value=e[0],this.uniforms.slotSpriteOffset1.value=e[1]||0,this.uniforms.slotSpriteOffset2.value=e[2]||0,this.uniforms.slotSpriteOffset3.value=e[3]||0}}}),this.uniforms.maskMap.value=Zl,this.uniforms.numberMaskMap.value=Jl,this.emissiveEnabled=!0,this.emissiveIntensity=.8,this.setValues(t)}dispose(){this.uniforms.maskMap&&this.uniforms.maskMap.value&&this.uniforms.maskMap.value.dispose(),this.uniforms.numberMaskMap&&this.uniforms.numberMaskMap.value&&this.uniforms.numberMaskMap.value.dispose(),super.dispose()}}class Ug extends St{constructor(t){super(),d(this,"isMesh",!0),d(this,"_slots",[]),d(this,"_slotCount",3),d(this,"_numberSlot",-1),d(this,"_timeTable",null),d(this,"_channelCount",3),this.geometry=t,this.material=new YM,this.number=0}set slots(t){this._slots=t,this._slotCount=t.length;let e=-1,i=0;for(let n=0,r=t.length;n<r;n++)t[n]===-1?e=n:i++;this._numberSlot=e,this._channelCount=i,this.material.slotConfig=t}get slots(){return this._slots}get slotCount(){return this._slotCount}get numberSlot(){return this._numberSlot}get number(){return this._number}set number(t){this._number=t,this.material.number=t}set timeTable(t){this._number=0,this._lightState=0,this._timeTable=t}get timeTable(){return this.timeTable}set lightState(t){this._lightState=t}get lightState(){return this._lightState}updateState(t){if(this._timeTable){const e=this._timeTable,i=(t/1e3-e.startTime)%e.period;for(let n=e.states.length-1,r=n;r>=0;--r)if(e.states[r][0]<=i){this._lightState=e.states[r][1],this._number=(r===n?e.period:e.states[r+1][0])-i+1;break}this._active=!0,this.updateMaterial()}else this._lightState!==void 0&&this._lightState!==null?(this._active=!0,this.updateMaterial()):this._active&&(this.updateMaterial(),this._active=!1)}updateMaterial(){const t=this.material;this._channelCount===3?(t.slotState0=this._lightState===1?1:0,t.slotState1=this._lightState===2?2:0,t.slotState2=this._lightState===3?3:0,this._numberSlot!==-1&&(t.number=this._number,t.slotState3=this._lightState)):this._channelCount===2?(t.slotState0=this._lightState===1?1:0,t.slotState1=this._lightState===3?3:0,this._numberSlot!==-1&&(t.number=this._number,t.slotState2=this._lightState)):this._channelCount===1?(t.slotState0=this._lightState,this._numberSlot!==-1&&(t.number=this._number,t.slotState1=this._lightState)):this._channelCount===0?this._numberSlot!==-1&&(t.number=this._number,t.slotState0=this._lightState):console.warn("invalid channel count:",this._channelCount)}}const Fg=new Ug,ro=class extends rs{constructor(s){super(s),d(this,"_geoDataType"),d(this,"_geoFeatures",[]),d(this,"_geoIndexMap",[]),this.type="GeoJSONDataSource"}getOriginDataIndex(s){return s<this._templateDataLength?this._geoIndexMap[s]:[s-this._templateDataLength+this._geoFeatures.length,0]}getOriginData(s){if(s<this._templateDataLength){const t=this._geoIndexMap[s];return this._geoFeatures[t[0]]}return this._addCache[s-this._templateDataLength]}async _getFetchData(s){return await s.json()}onClear(){this._geoDataType=void 0,this._geoFeatures=[],this._geoIndexMap=[]}_onProcessTemplateData(s,t){return this._prepareFeatures(),this._parseFeatures(s,t),s}originToFeatures(s){for(let t=0;t<this._geoFeatures.length;t++){const e=this._geoFeatures[t];s.push({type:"Feature",geometry:{type:e.geometry.type,coordinates:e.geometry.coordinates},properties:e.properties})}return s}_parseFeatures(s,t){let e=0;for(let i=0;i<this._geoFeatures.length;i++){const n=this._geoFeatures[i],r=this._onDecomposeFeature(this._geoDataType,n);for(let a=0;a<r.length;a++){const o=r[a];s.position.push(o.geometry[this.projectionName]),a>0&&e++,s.index.push(i+e),this._geoIndexMap[i+e]=[i,a];let l={position:o.geometry[this.projectionName],index:i+e};for(const h of this._attributeMap.keys()){let c;o.properties&&o.properties[this._attributeMap.get(h)]!==void 0&&o.properties[this._attributeMap.get(h)]!==null?c=o.properties[this._attributeMap.get(h)]:this._attributeMap.get(h)instanceof Function&&(c=this._attributeMap.get(h)(o.properties)),s[h].push(c),l[h]=c}t.push(l)}}}_prepareFeatures(){var s,t;this._geoFeatures=xl(this._origin,this.projectionName),this._geoDataType=super._getDataType((t=(s=this._geoFeatures[0])==null?void 0:s.geometry)==null?void 0:t.type)}get geoDataType(){return this._geoDataType}};let us=ro;d(us,"fromGeoJSON",async function(s){let t=new ro;return await t.load(s),t}),d(us,"fromUrl",async function(s){let t=new ro;return await t.load(s),t}),d(us,"fromGeoJSONObject",function(s){let t=new ro;return t.setData(s),t}),d(us,"fromObject",function(s){let t=new ro;return t.setData(s),t});var Bg=typeof Co<"u"?Co:typeof self<"u"?self:typeof window<"u"?window:{},en=[],Mi=[],ZM=typeof Uint8Array<"u"?Uint8Array:Array,Lu=!1;function Vg(){Lu=!0;for(var s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=0,e=s.length;t<e;++t)en[t]=s[t],Mi[s.charCodeAt(t)]=t;Mi[45]=62,Mi[95]=63}function JM(s,t,e){for(var i,n,r=[],a=t;a<e;a+=3)i=(s[a]<<16)+(s[a+1]<<8)+s[a+2],r.push(en[(n=i)>>18&63]+en[n>>12&63]+en[n>>6&63]+en[63&n]);return r.join("")}function Hg(s){var t;Lu||Vg();for(var e=s.length,i=e%3,n="",r=[],a=16383,o=0,l=e-i;o<l;o+=a)r.push(JM(s,o,o+a>l?l:o+a));return i===1?(t=s[e-1],n+=en[t>>2],n+=en[t<<4&63],n+="=="):i===2&&(t=(s[e-2]<<8)+s[e-1],n+=en[t>>10],n+=en[t>>4&63],n+=en[t<<2&63],n+="="),r.push(n),r.join("")}function Kl(s,t,e,i,n){var r,a,o=8*n-i-1,l=(1<<o)-1,h=l>>1,c=-7,u=e?n-1:0,p=e?-1:1,m=s[t+u];for(u+=p,r=m&(1<<-c)-1,m>>=-c,c+=o;c>0;r=256*r+s[t+u],u+=p,c-=8);for(a=r&(1<<-c)-1,r>>=-c,c+=i;c>0;a=256*a+s[t+u],u+=p,c-=8);if(r===0)r=1-h;else{if(r===l)return a?NaN:1/0*(m?-1:1);a+=Math.pow(2,i),r-=h}return(m?-1:1)*a*Math.pow(2,r-i)}function jg(s,t,e,i,n,r){var a,o,l,h=8*r-n-1,c=(1<<h)-1,u=c>>1,p=n===23?Math.pow(2,-24)-Math.pow(2,-77):0,m=i?0:r-1,f=i?1:-1,g=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,a=c):(a=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-a))<1&&(a--,l*=2),(t+=a+u>=1?p/l:p*Math.pow(2,1-u))*l>=2&&(a++,l/=2),a+u>=c?(o=0,a=c):a+u>=1?(o=(t*l-1)*Math.pow(2,n),a+=u):(o=t*Math.pow(2,u-1)*Math.pow(2,n),a=0));n>=8;s[e+m]=255&o,m+=f,o/=256,n-=8);for(a=a<<n|o,h+=n;h>0;s[e+m]=255&a,m+=f,a/=256,h-=8);s[e+m-f]|=128*g}var KM={}.toString,Gg=Array.isArray||function(s){return KM.call(s)=="[object Array]"};function Ql(){return W.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function On(s,t){if(Ql()<t)throw new RangeError("Invalid typed array length");return W.TYPED_ARRAY_SUPPORT?(s=new Uint8Array(t)).__proto__=W.prototype:(s===null&&(s=new W(t)),s.length=t),s}function W(s,t,e){if(!(W.TYPED_ARRAY_SUPPORT||this instanceof W))return new W(s,t,e);if(typeof s=="number"){if(typeof t=="string")throw new Error("If encoding is specified then the first argument must be a string");return Iu(this,s)}return Wg(this,s,t,e)}function Wg(s,t,e,i){if(typeof t=="number")throw new TypeError('"value" argument must not be a number');return typeof ArrayBuffer<"u"&&t instanceof ArrayBuffer?function(n,r,a,o){if(r.byteLength,a<0||r.byteLength<a)throw new RangeError("'offset' is out of bounds");if(r.byteLength<a+(o||0))throw new RangeError("'length' is out of bounds");return r=a===void 0&&o===void 0?new Uint8Array(r):o===void 0?new Uint8Array(r,a):new Uint8Array(r,a,o),W.TYPED_ARRAY_SUPPORT?(n=r).__proto__=W.prototype:n=Ou(n,r),n}(s,t,e,i):typeof t=="string"?function(n,r,a){if(typeof a=="string"&&a!==""||(a="utf8"),!W.isEncoding(a))throw new TypeError('"encoding" must be a valid string encoding');var o=0|qg(r,a);n=On(n,o);var l=n.write(r,a);return l!==o&&(n=n.slice(0,l)),n}(s,t,e):function(n,r){if(nn(r)){var a=0|zu(r.length);return(n=On(n,a)).length===0||r.copy(n,0,0,a),n}if(r){if(typeof ArrayBuffer<"u"&&r.buffer instanceof ArrayBuffer||"length"in r)return typeof r.length!="number"||(o=r.length)!=o?On(n,0):Ou(n,r);if(r.type==="Buffer"&&Gg(r.data))return Ou(n,r.data)}var o;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(s,t)}function Xg(s){if(typeof s!="number")throw new TypeError('"size" argument must be a number');if(s<0)throw new RangeError('"size" argument must not be negative')}function Iu(s,t){if(Xg(t),s=On(s,t<0?0:0|zu(t)),!W.TYPED_ARRAY_SUPPORT)for(var e=0;e<t;++e)s[e]=0;return s}function Ou(s,t){var e=t.length<0?0:0|zu(t.length);s=On(s,e);for(var i=0;i<e;i+=1)s[i]=255&t[i];return s}function zu(s){if(s>=Ql())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+Ql().toString(16)+" bytes");return 0|s}function nn(s){return!(s==null||!s._isBuffer)}function qg(s,t){if(nn(s))return s.length;if(typeof ArrayBuffer<"u"&&typeof ArrayBuffer.isView=="function"&&(ArrayBuffer.isView(s)||s instanceof ArrayBuffer))return s.byteLength;typeof s!="string"&&(s=""+s);var e=s.length;if(e===0)return 0;for(var i=!1;;)switch(t){case"ascii":case"latin1":case"binary":return e;case"utf8":case"utf-8":case void 0:return eh(s).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*e;case"hex":return e>>>1;case"base64":return i_(s).length;default:if(i)return eh(s).length;t=(""+t).toLowerCase(),i=!0}}function QM(s,t,e){var i=!1;if((t===void 0||t<0)&&(t=0),t>this.length||((e===void 0||e>this.length)&&(e=this.length),e<=0)||(e>>>=0)<=(t>>>=0))return"";for(s||(s="utf8");;)switch(s){case"hex":return ow(this,t,e);case"utf8":case"utf-8":return Kg(this,t,e);case"ascii":return rw(this,t,e);case"latin1":case"binary":return aw(this,t,e);case"base64":return sw(this,t,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return lw(this,t,e);default:if(i)throw new TypeError("Unknown encoding: "+s);s=(s+"").toLowerCase(),i=!0}}function tr(s,t,e){var i=s[t];s[t]=s[e],s[e]=i}function Yg(s,t,e,i,n){if(s.length===0)return-1;if(typeof e=="string"?(i=e,e=0):e>2147483647?e=2147483647:e<-2147483648&&(e=-2147483648),e=+e,isNaN(e)&&(e=n?0:s.length-1),e<0&&(e=s.length+e),e>=s.length){if(n)return-1;e=s.length-1}else if(e<0){if(!n)return-1;e=0}if(typeof t=="string"&&(t=W.from(t,i)),nn(t))return t.length===0?-1:Zg(s,t,e,i,n);if(typeof t=="number")return t&=255,W.TYPED_ARRAY_SUPPORT&&typeof Uint8Array.prototype.indexOf=="function"?n?Uint8Array.prototype.indexOf.call(s,t,e):Uint8Array.prototype.lastIndexOf.call(s,t,e):Zg(s,[t],e,i,n);throw new TypeError("val must be string, number or Buffer")}function Zg(s,t,e,i,n){var r,a=1,o=s.length,l=t.length;if(i!==void 0&&((i=String(i).toLowerCase())==="ucs2"||i==="ucs-2"||i==="utf16le"||i==="utf-16le")){if(s.length<2||t.length<2)return-1;a=2,o/=2,l/=2,e/=2}function h(m,f){return a===1?m[f]:m.readUInt16BE(f*a)}if(n){var c=-1;for(r=e;r<o;r++)if(h(s,r)===h(t,c===-1?0:r-c)){if(c===-1&&(c=r),r-c+1===l)return c*a}else c!==-1&&(r-=r-c),c=-1}else for(e+l>o&&(e=o-l),r=e;r>=0;r--){for(var u=!0,p=0;p<l;p++)if(h(s,r+p)!==h(t,p)){u=!1;break}if(u)return r}return-1}function $M(s,t,e,i){e=Number(e)||0;var n=s.length-e;i?(i=Number(i))>n&&(i=n):i=n;var r=t.length;if(r%2!=0)throw new TypeError("Invalid hex string");i>r/2&&(i=r/2);for(var a=0;a<i;++a){var o=parseInt(t.substr(2*a,2),16);if(isNaN(o))return a;s[e+a]=o}return a}function tw(s,t,e,i){return ih(eh(t,s.length-e),s,e,i)}function Jg(s,t,e,i){return ih(function(n){for(var r=[],a=0;a<n.length;++a)r.push(255&n.charCodeAt(a));return r}(t),s,e,i)}function ew(s,t,e,i){return Jg(s,t,e,i)}function iw(s,t,e,i){return ih(i_(t),s,e,i)}function nw(s,t,e,i){return ih(function(n,r){for(var a,o,l,h=[],c=0;c<n.length&&!((r-=2)<0);++c)o=(a=n.charCodeAt(c))>>8,l=a%256,h.push(l),h.push(o);return h}(t,s.length-e),s,e,i)}function sw(s,t,e){return t===0&&e===s.length?Hg(s):Hg(s.slice(t,e))}function Kg(s,t,e){e=Math.min(s.length,e);for(var i=[],n=t;n<e;){var r,a,o,l,h=s[n],c=null,u=h>239?4:h>223?3:h>191?2:1;if(n+u<=e)switch(u){case 1:h<128&&(c=h);break;case 2:(192&(r=s[n+1]))==128&&(l=(31&h)<<6|63&r)>127&&(c=l);break;case 3:r=s[n+1],a=s[n+2],(192&r)==128&&(192&a)==128&&(l=(15&h)<<12|(63&r)<<6|63&a)>2047&&(l<55296||l>57343)&&(c=l);break;case 4:r=s[n+1],a=s[n+2],o=s[n+3],(192&r)==128&&(192&a)==128&&(192&o)==128&&(l=(15&h)<<18|(63&r)<<12|(63&a)<<6|63&o)>65535&&l<1114112&&(c=l)}c===null?(c=65533,u=1):c>65535&&(c-=65536,i.push(c>>>10&1023|55296),c=56320|1023&c),i.push(c),n+=u}return function(p){var m=p.length;if(m<=Qg)return String.fromCharCode.apply(String,p);for(var f="",g=0;g<m;)f+=String.fromCharCode.apply(String,p.slice(g,g+=Qg));return f}(i)}W.TYPED_ARRAY_SUPPORT=Bg.TYPED_ARRAY_SUPPORT===void 0||Bg.TYPED_ARRAY_SUPPORT,Ql(),W.poolSize=8192,W._augment=function(s){return s.__proto__=W.prototype,s},W.from=function(s,t,e){return Wg(null,s,t,e)},W.TYPED_ARRAY_SUPPORT&&(W.prototype.__proto__=Uint8Array.prototype,W.__proto__=Uint8Array,typeof Symbol<"u"&&Symbol.species&&W[Symbol.species]),W.alloc=function(s,t,e){return function(i,n,r,a){return Xg(n),n<=0?On(i,n):r!==void 0?typeof a=="string"?On(i,n).fill(r,a):On(i,n).fill(r):On(i,n)}(null,s,t,e)},W.allocUnsafe=function(s){return Iu(null,s)},W.allocUnsafeSlow=function(s){return Iu(null,s)},W.isBuffer=wi,W.compare=function(s,t){if(!nn(s)||!nn(t))throw new TypeError("Arguments must be Buffers");if(s===t)return 0;for(var e=s.length,i=t.length,n=0,r=Math.min(e,i);n<r;++n)if(s[n]!==t[n]){e=s[n],i=t[n];break}return e<i?-1:i<e?1:0},W.isEncoding=function(s){switch(String(s).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},W.concat=function(s,t){if(!Gg(s))throw new TypeError('"list" argument must be an Array of Buffers');if(s.length===0)return W.alloc(0);var e;if(t===void 0)for(t=0,e=0;e<s.length;++e)t+=s[e].length;var i=W.allocUnsafe(t),n=0;for(e=0;e<s.length;++e){var r=s[e];if(!nn(r))throw new TypeError('"list" argument must be an Array of Buffers');r.copy(i,n),n+=r.length}return i},W.byteLength=qg,W.prototype._isBuffer=!0,W.prototype.swap16=function(){var s=this.length;if(s%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<s;t+=2)tr(this,t,t+1);return this},W.prototype.swap32=function(){var s=this.length;if(s%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<s;t+=4)tr(this,t,t+3),tr(this,t+1,t+2);return this},W.prototype.swap64=function(){var s=this.length;if(s%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<s;t+=8)tr(this,t,t+7),tr(this,t+1,t+6),tr(this,t+2,t+5),tr(this,t+3,t+4);return this},W.prototype.toString=function(){var s=0|this.length;return s===0?"":arguments.length===0?Kg(this,0,s):QM.apply(this,arguments)},W.prototype.equals=function(s){if(!nn(s))throw new TypeError("Argument must be a Buffer");return this===s||W.compare(this,s)===0},W.prototype.inspect=function(){var s="";return this.length>0&&(s=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(s+=" ... ")),"<Buffer "+s+">"},W.prototype.compare=function(s,t,e,i,n){if(!nn(s))throw new TypeError("Argument must be a Buffer");if(t===void 0&&(t=0),e===void 0&&(e=s?s.length:0),i===void 0&&(i=0),n===void 0&&(n=this.length),t<0||e>s.length||i<0||n>this.length)throw new RangeError("out of range index");if(i>=n&&t>=e)return 0;if(i>=n)return-1;if(t>=e)return 1;if(this===s)return 0;for(var r=(n>>>=0)-(i>>>=0),a=(e>>>=0)-(t>>>=0),o=Math.min(r,a),l=this.slice(i,n),h=s.slice(t,e),c=0;c<o;++c)if(l[c]!==h[c]){r=l[c],a=h[c];break}return r<a?-1:a<r?1:0},W.prototype.includes=function(s,t,e){return this.indexOf(s,t,e)!==-1},W.prototype.indexOf=function(s,t,e){return Yg(this,s,t,e,!0)},W.prototype.lastIndexOf=function(s,t,e){return Yg(this,s,t,e,!1)},W.prototype.write=function(s,t,e,i){if(t===void 0)i="utf8",e=this.length,t=0;else if(e===void 0&&typeof t=="string")i=t,e=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(e)?(e|=0,i===void 0&&(i="utf8")):(i=e,e=void 0)}var n=this.length-t;if((e===void 0||e>n)&&(e=n),s.length>0&&(e<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var r=!1;;)switch(i){case"hex":return $M(this,s,t,e);case"utf8":case"utf-8":return tw(this,s,t,e);case"ascii":return Jg(this,s,t,e);case"latin1":case"binary":return ew(this,s,t,e);case"base64":return iw(this,s,t,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return nw(this,s,t,e);default:if(r)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),r=!0}},W.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var Qg=4096;function rw(s,t,e){var i="";e=Math.min(s.length,e);for(var n=t;n<e;++n)i+=String.fromCharCode(127&s[n]);return i}function aw(s,t,e){var i="";e=Math.min(s.length,e);for(var n=t;n<e;++n)i+=String.fromCharCode(s[n]);return i}function ow(s,t,e){var i=s.length;(!t||t<0)&&(t=0),(!e||e<0||e>i)&&(e=i);for(var n="",r=t;r<e;++r)n+=cw(s[r]);return n}function lw(s,t,e){for(var i=s.slice(t,e),n="",r=0;r<i.length;r+=2)n+=String.fromCharCode(i[r]+256*i[r+1]);return n}function Ee(s,t,e){if(s%1!=0||s<0)throw new RangeError("offset is not uint");if(s+t>e)throw new RangeError("Trying to access beyond buffer length")}function ni(s,t,e,i,n,r){if(!nn(s))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>n||t<r)throw new RangeError('"value" argument is out of bounds');if(e+i>s.length)throw new RangeError("Index out of range")}function $l(s,t,e,i){t<0&&(t=65535+t+1);for(var n=0,r=Math.min(s.length-e,2);n<r;++n)s[e+n]=(t&255<<8*(i?n:1-n))>>>8*(i?n:1-n)}function th(s,t,e,i){t<0&&(t=4294967295+t+1);for(var n=0,r=Math.min(s.length-e,4);n<r;++n)s[e+n]=t>>>8*(i?n:3-n)&255}function $g(s,t,e,i,n,r){if(e+i>s.length)throw new RangeError("Index out of range");if(e<0)throw new RangeError("Index out of range")}function t_(s,t,e,i,n){return n||$g(s,0,e,4),jg(s,t,e,i,23,4),e+4}function e_(s,t,e,i,n){return n||$g(s,0,e,8),jg(s,t,e,i,52,8),e+8}W.prototype.slice=function(s,t){var e,i=this.length;if((s=~~s)<0?(s+=i)<0&&(s=0):s>i&&(s=i),(t=t===void 0?i:~~t)<0?(t+=i)<0&&(t=0):t>i&&(t=i),t<s&&(t=s),W.TYPED_ARRAY_SUPPORT)(e=this.subarray(s,t)).__proto__=W.prototype;else{var n=t-s;e=new W(n,void 0);for(var r=0;r<n;++r)e[r]=this[r+s]}return e},W.prototype.readUIntLE=function(s,t,e){s|=0,t|=0,e||Ee(s,t,this.length);for(var i=this[s],n=1,r=0;++r<t&&(n*=256);)i+=this[s+r]*n;return i},W.prototype.readUIntBE=function(s,t,e){s|=0,t|=0,e||Ee(s,t,this.length);for(var i=this[s+--t],n=1;t>0&&(n*=256);)i+=this[s+--t]*n;return i},W.prototype.readUInt8=function(s,t){return t||Ee(s,1,this.length),this[s]},W.prototype.readUInt16LE=function(s,t){return t||Ee(s,2,this.length),this[s]|this[s+1]<<8},W.prototype.readUInt16BE=function(s,t){return t||Ee(s,2,this.length),this[s]<<8|this[s+1]},W.prototype.readUInt32LE=function(s,t){return t||Ee(s,4,this.length),(this[s]|this[s+1]<<8|this[s+2]<<16)+16777216*this[s+3]},W.prototype.readUInt32BE=function(s,t){return t||Ee(s,4,this.length),16777216*this[s]+(this[s+1]<<16|this[s+2]<<8|this[s+3])},W.prototype.readIntLE=function(s,t,e){s|=0,t|=0,e||Ee(s,t,this.length);for(var i=this[s],n=1,r=0;++r<t&&(n*=256);)i+=this[s+r]*n;return i>=(n*=128)&&(i-=Math.pow(2,8*t)),i},W.prototype.readIntBE=function(s,t,e){s|=0,t|=0,e||Ee(s,t,this.length);for(var i=t,n=1,r=this[s+--i];i>0&&(n*=256);)r+=this[s+--i]*n;return r>=(n*=128)&&(r-=Math.pow(2,8*t)),r},W.prototype.readInt8=function(s,t){return t||Ee(s,1,this.length),128&this[s]?-1*(255-this[s]+1):this[s]},W.prototype.readInt16LE=function(s,t){t||Ee(s,2,this.length);var e=this[s]|this[s+1]<<8;return 32768&e?4294901760|e:e},W.prototype.readInt16BE=function(s,t){t||Ee(s,2,this.length);var e=this[s+1]|this[s]<<8;return 32768&e?4294901760|e:e},W.prototype.readInt32LE=function(s,t){return t||Ee(s,4,this.length),this[s]|this[s+1]<<8|this[s+2]<<16|this[s+3]<<24},W.prototype.readInt32BE=function(s,t){return t||Ee(s,4,this.length),this[s]<<24|this[s+1]<<16|this[s+2]<<8|this[s+3]},W.prototype.readFloatLE=function(s,t){return t||Ee(s,4,this.length),Kl(this,s,!0,23,4)},W.prototype.readFloatBE=function(s,t){return t||Ee(s,4,this.length),Kl(this,s,!1,23,4)},W.prototype.readDoubleLE=function(s,t){return t||Ee(s,8,this.length),Kl(this,s,!0,52,8)},W.prototype.readDoubleBE=function(s,t){return t||Ee(s,8,this.length),Kl(this,s,!1,52,8)},W.prototype.writeUIntLE=function(s,t,e,i){s=+s,t|=0,e|=0,i||ni(this,s,t,e,Math.pow(2,8*e)-1,0);var n=1,r=0;for(this[t]=255&s;++r<e&&(n*=256);)this[t+r]=s/n&255;return t+e},W.prototype.writeUIntBE=function(s,t,e,i){s=+s,t|=0,e|=0,i||ni(this,s,t,e,Math.pow(2,8*e)-1,0);var n=e-1,r=1;for(this[t+n]=255&s;--n>=0&&(r*=256);)this[t+n]=s/r&255;return t+e},W.prototype.writeUInt8=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,1,255,0),W.TYPED_ARRAY_SUPPORT||(s=Math.floor(s)),this[t]=255&s,t+1},W.prototype.writeUInt16LE=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,2,65535,0),W.TYPED_ARRAY_SUPPORT?(this[t]=255&s,this[t+1]=s>>>8):$l(this,s,t,!0),t+2},W.prototype.writeUInt16BE=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,2,65535,0),W.TYPED_ARRAY_SUPPORT?(this[t]=s>>>8,this[t+1]=255&s):$l(this,s,t,!1),t+2},W.prototype.writeUInt32LE=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,4,4294967295,0),W.TYPED_ARRAY_SUPPORT?(this[t+3]=s>>>24,this[t+2]=s>>>16,this[t+1]=s>>>8,this[t]=255&s):th(this,s,t,!0),t+4},W.prototype.writeUInt32BE=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,4,4294967295,0),W.TYPED_ARRAY_SUPPORT?(this[t]=s>>>24,this[t+1]=s>>>16,this[t+2]=s>>>8,this[t+3]=255&s):th(this,s,t,!1),t+4},W.prototype.writeIntLE=function(s,t,e,i){if(s=+s,t|=0,!i){var n=Math.pow(2,8*e-1);ni(this,s,t,e,n-1,-n)}var r=0,a=1,o=0;for(this[t]=255&s;++r<e&&(a*=256);)s<0&&o===0&&this[t+r-1]!==0&&(o=1),this[t+r]=(s/a>>0)-o&255;return t+e},W.prototype.writeIntBE=function(s,t,e,i){if(s=+s,t|=0,!i){var n=Math.pow(2,8*e-1);ni(this,s,t,e,n-1,-n)}var r=e-1,a=1,o=0;for(this[t+r]=255&s;--r>=0&&(a*=256);)s<0&&o===0&&this[t+r+1]!==0&&(o=1),this[t+r]=(s/a>>0)-o&255;return t+e},W.prototype.writeInt8=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,1,127,-128),W.TYPED_ARRAY_SUPPORT||(s=Math.floor(s)),s<0&&(s=255+s+1),this[t]=255&s,t+1},W.prototype.writeInt16LE=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,2,32767,-32768),W.TYPED_ARRAY_SUPPORT?(this[t]=255&s,this[t+1]=s>>>8):$l(this,s,t,!0),t+2},W.prototype.writeInt16BE=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,2,32767,-32768),W.TYPED_ARRAY_SUPPORT?(this[t]=s>>>8,this[t+1]=255&s):$l(this,s,t,!1),t+2},W.prototype.writeInt32LE=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,4,2147483647,-2147483648),W.TYPED_ARRAY_SUPPORT?(this[t]=255&s,this[t+1]=s>>>8,this[t+2]=s>>>16,this[t+3]=s>>>24):th(this,s,t,!0),t+4},W.prototype.writeInt32BE=function(s,t,e){return s=+s,t|=0,e||ni(this,s,t,4,2147483647,-2147483648),s<0&&(s=4294967295+s+1),W.TYPED_ARRAY_SUPPORT?(this[t]=s>>>24,this[t+1]=s>>>16,this[t+2]=s>>>8,this[t+3]=255&s):th(this,s,t,!1),t+4},W.prototype.writeFloatLE=function(s,t,e){return t_(this,s,t,!0,e)},W.prototype.writeFloatBE=function(s,t,e){return t_(this,s,t,!1,e)},W.prototype.writeDoubleLE=function(s,t,e){return e_(this,s,t,!0,e)},W.prototype.writeDoubleBE=function(s,t,e){return e_(this,s,t,!1,e)},W.prototype.copy=function(s,t,e,i){if(e||(e=0),i||i===0||(i=this.length),t>=s.length&&(t=s.length),t||(t=0),i>0&&i<e&&(i=e),i===e||s.length===0||this.length===0)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(e<0||e>=this.length)throw new RangeError("sourceStart out of bounds");if(i<0)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),s.length-t<i-e&&(i=s.length-t+e);var n,r=i-e;if(this===s&&e<t&&t<i)for(n=r-1;n>=0;--n)s[n+t]=this[n+e];else if(r<1e3||!W.TYPED_ARRAY_SUPPORT)for(n=0;n<r;++n)s[n+t]=this[n+e];else Uint8Array.prototype.set.call(s,this.subarray(e,e+r),t);return r},W.prototype.fill=function(s,t,e,i){if(typeof s=="string"){if(typeof t=="string"?(i=t,t=0,e=this.length):typeof e=="string"&&(i=e,e=this.length),s.length===1){var n=s.charCodeAt(0);n<256&&(s=n)}if(i!==void 0&&typeof i!="string")throw new TypeError("encoding must be a string");if(typeof i=="string"&&!W.isEncoding(i))throw new TypeError("Unknown encoding: "+i)}else typeof s=="number"&&(s&=255);if(t<0||this.length<t||this.length<e)throw new RangeError("Out of range index");if(e<=t)return this;var r;if(t>>>=0,e=e===void 0?this.length:e>>>0,s||(s=0),typeof s=="number")for(r=t;r<e;++r)this[r]=s;else{var a=nn(s)?s:eh(new W(s,i).toString()),o=a.length;for(r=0;r<e-t;++r)this[r+t]=a[r%o]}return this};var hw=/[^+\/0-9A-Za-z-_]/g;function cw(s){return s<16?"0"+s.toString(16):s.toString(16)}function eh(s,t){var e;t=t||1/0;for(var i=s.length,n=null,r=[],a=0;a<i;++a){if((e=s.charCodeAt(a))>55295&&e<57344){if(!n){if(e>56319){(t-=3)>-1&&r.push(239,191,189);continue}if(a+1===i){(t-=3)>-1&&r.push(239,191,189);continue}n=e;continue}if(e<56320){(t-=3)>-1&&r.push(239,191,189),n=e;continue}e=65536+(n-55296<<10|e-56320)}else n&&(t-=3)>-1&&r.push(239,191,189);if(n=null,e<128){if((t-=1)<0)break;r.push(e)}else if(e<2048){if((t-=2)<0)break;r.push(e>>6|192,63&e|128)}else if(e<65536){if((t-=3)<0)break;r.push(e>>12|224,e>>6&63|128,63&e|128)}else{if(!(e<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;r.push(e>>18|240,e>>12&63|128,e>>6&63|128,63&e|128)}}return r}function i_(s){return function(t){var e,i,n,r,a,o;Lu||Vg();var l=t.length;if(l%4>0)throw new Error("Invalid string. Length must be a multiple of 4");a=t[l-2]==="="?2:t[l-1]==="="?1:0,o=new ZM(3*l/4-a),n=a>0?l-4:l;var h=0;for(e=0,i=0;e<n;e+=4,i+=3)r=Mi[t.charCodeAt(e)]<<18|Mi[t.charCodeAt(e+1)]<<12|Mi[t.charCodeAt(e+2)]<<6|Mi[t.charCodeAt(e+3)],o[h++]=r>>16&255,o[h++]=r>>8&255,o[h++]=255&r;return a===2?(r=Mi[t.charCodeAt(e)]<<2|Mi[t.charCodeAt(e+1)]>>4,o[h++]=255&r):a===1&&(r=Mi[t.charCodeAt(e)]<<10|Mi[t.charCodeAt(e+1)]<<4|Mi[t.charCodeAt(e+2)]>>2,o[h++]=r>>8&255,o[h++]=255&r),o}(function(t){if((t=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(t).replace(hw,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(s))}function ih(s,t,e,i){for(var n=0;n<i&&!(n+e>=t.length||n>=s.length);++n)t[n+e]=s[n];return n}function wi(s){return s!=null&&(!!s._isBuffer||n_(s)||function(t){return typeof t.readFloatLE=="function"&&typeof t.slice=="function"&&n_(t.slice(0,0))}(s))}function n_(s){return!!s.constructor&&typeof s.constructor.isBuffer=="function"&&s.constructor.isBuffer(s)}class Kt extends Error{constructor(t,e,i,...n){Array.isArray(e)&&(e=e.join(" ").trim()),super(e),Error.captureStackTrace!==void 0&&Error.captureStackTrace(this,Kt),this.code=t;for(const r of n)for(const a in r){const o=r[a];this[a]=wi(o)?o.toString(i.encoding):o==null?o:JSON.parse(JSON.stringify(o))}}}const uw=function(s){return typeof s=="object"&&s!==null&&!Array.isArray(s)},s_=function(s){const t=[];for(let e=0,i=s.length;e<i;e++){const n=s[e];if(n==null||n===!1)t[e]={disabled:!0};else if(typeof n=="string")t[e]={name:n};else{if(!uw(n))throw new Kt("CSV_INVALID_COLUMN_DEFINITION",["Invalid column definition:","expect a string or a literal object,",`got ${JSON.stringify(n)} at position ${e}`]);if(typeof n.name!="string")throw new Kt("CSV_OPTION_COLUMNS_MISSING_NAME",["Option columns missing name:",`property "name" is required at position ${e}`,"when column is an object literal"]);t[e]=n}}return t};class r_{constructor(t=100){this.size=t,this.length=0,this.buf=W.allocUnsafe(t)}prepend(t){if(wi(t)){const e=this.length+t.length;if(e>=this.size&&(this.resize(),e>=this.size))throw Error("INVALID_BUFFER_STATE");const i=this.buf;this.buf=W.allocUnsafe(this.size),t.copy(this.buf,0),i.copy(this.buf,t.length),this.length+=t.length}else{const e=this.length++;e===this.size&&this.resize();const i=this.clone();this.buf[0]=t,i.copy(this.buf,1,0,e)}}append(t){const e=this.length++;e===this.size&&this.resize(),this.buf[e]=t}clone(){return W.from(this.buf.slice(0,this.length))}resize(){const t=this.length;this.size=2*this.size;const e=W.allocUnsafe(this.size);this.buf.copy(e,0,0,t),this.buf=e}toString(t){return t?this.buf.slice(0,this.length).toString(t):Uint8Array.prototype.slice.call(this.buf.slice(0,this.length))}toJSON(){return this.toString("utf8")}reset(){this.length=0}}const dw=function(s){return{bomSkipped:!1,bufBytesStart:0,castField:s.cast_function,commenting:!1,error:void 0,enabled:s.from_line===1,escaping:!1,escapeIsQuote:wi(s.escape)&&wi(s.quote)&&W.compare(s.escape,s.quote)===0,expectedRecordLength:Array.isArray(s.columns)?s.columns.length:void 0,field:new r_(20),firstLineToHeaders:s.cast_first_line_to_header,needMoreDataSize:Math.max(s.comment!==null?s.comment.length:0,...s.delimiter.map(t=>t.length),s.quote!==null?s.quote.length:0),previousBuf:void 0,quoting:!1,stop:!1,rawBuffer:new r_(100),record:[],recordHasError:!1,record_length:0,recordDelimiterMaxLength:s.record_delimiter.length===0?0:Math.max(...s.record_delimiter.map(t=>t.length)),trimChars:[W.from(" ",s.encoding)[0],W.from("	",s.encoding)[0]],wasQuoting:!1,wasRowDelimiter:!1,timchars:[W.from(W.from([13],"utf8").toString(),s.encoding),W.from(W.from([10],"utf8").toString(),s.encoding),W.from(W.from([12],"utf8").toString(),s.encoding),W.from(W.from([32],"utf8").toString(),s.encoding),W.from(W.from([9],"utf8").toString(),s.encoding)]}},a_=function(s){const t={};for(const n in s)t[e=n,e.replace(/([A-Z])/g,function(r,a){return"_"+a.toLowerCase()})]=s[n];var e;if(t.encoding===void 0||t.encoding===!0)t.encoding="utf8";else if(t.encoding===null||t.encoding===!1)t.encoding=null;else if(typeof t.encoding!="string"&&t.encoding!==null)throw new Kt("CSV_INVALID_OPTION_ENCODING",["Invalid option encoding:","encoding must be a string or null to return a buffer,",`got ${JSON.stringify(t.encoding)}`],t);if(t.bom===void 0||t.bom===null||t.bom===!1)t.bom=!1;else if(t.bom!==!0)throw new Kt("CSV_INVALID_OPTION_BOM",["Invalid option bom:","bom must be true,",`got ${JSON.stringify(t.bom)}`],t);if(t.cast_function=null,t.cast===void 0||t.cast===null||t.cast===!1||t.cast==="")t.cast=void 0;else if(typeof t.cast=="function")t.cast_function=t.cast,t.cast=!0;else if(t.cast!==!0)throw new Kt("CSV_INVALID_OPTION_CAST",["Invalid option cast:","cast must be true or a function,",`got ${JSON.stringify(t.cast)}`],t);if(t.cast_date===void 0||t.cast_date===null||t.cast_date===!1||t.cast_date==="")t.cast_date=!1;else if(t.cast_date===!0)t.cast_date=function(n){const r=Date.parse(n);return isNaN(r)?n:new Date(r)};else if(typeof t.cast_date!="function")throw new Kt("CSV_INVALID_OPTION_CAST_DATE",["Invalid option cast_date:","cast_date must be true or a function,",`got ${JSON.stringify(t.cast_date)}`],t);if(t.cast_first_line_to_header=null,t.columns===!0)t.cast_first_line_to_header=void 0;else if(typeof t.columns=="function")t.cast_first_line_to_header=t.columns,t.columns=!0;else if(Array.isArray(t.columns))t.columns=s_(t.columns);else{if(t.columns!==void 0&&t.columns!==null&&t.columns!==!1)throw new Kt("CSV_INVALID_OPTION_COLUMNS",["Invalid option columns:","expect an array, a function or true,",`got ${JSON.stringify(t.columns)}`],t);t.columns=!1}if(t.group_columns_by_name===void 0||t.group_columns_by_name===null||t.group_columns_by_name===!1)t.group_columns_by_name=!1;else{if(t.group_columns_by_name!==!0)throw new Kt("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",["Invalid option group_columns_by_name:","expect an boolean,",`got ${JSON.stringify(t.group_columns_by_name)}`],t);if(t.columns===!1)throw new Kt("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",["Invalid option group_columns_by_name:","the `columns` mode must be activated."],t)}if(t.comment===void 0||t.comment===null||t.comment===!1||t.comment==="")t.comment=null;else if(typeof t.comment=="string"&&(t.comment=W.from(t.comment,t.encoding)),!wi(t.comment))throw new Kt("CSV_INVALID_OPTION_COMMENT",["Invalid option comment:","comment must be a buffer or a string,",`got ${JSON.stringify(t.comment)}`],t);const i=JSON.stringify(t.delimiter);if(Array.isArray(t.delimiter)||(t.delimiter=[t.delimiter]),t.delimiter.length===0)throw new Kt("CSV_INVALID_OPTION_DELIMITER",["Invalid option delimiter:","delimiter must be a non empty string or buffer or array of string|buffer,",`got ${i}`],t);if(t.delimiter=t.delimiter.map(function(n){if(n==null||n===!1)return W.from(",",t.encoding);if(typeof n=="string"&&(n=W.from(n,t.encoding)),!wi(n)||n.length===0)throw new Kt("CSV_INVALID_OPTION_DELIMITER",["Invalid option delimiter:","delimiter must be a non empty string or buffer or array of string|buffer,",`got ${i}`],t);return n}),t.escape===void 0||t.escape===!0?t.escape=W.from('"',t.encoding):typeof t.escape=="string"?t.escape=W.from(t.escape,t.encoding):t.escape!==null&&t.escape!==!1||(t.escape=null),t.escape!==null&&!wi(t.escape))throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(t.escape)}`);if(t.from===void 0||t.from===null)t.from=1;else{if(typeof t.from=="string"&&/\d+/.test(t.from)&&(t.from=parseInt(t.from)),!Number.isInteger(t.from))throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(t.from)}`);if(t.from<0)throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(s.from)}`)}if(t.from_line===void 0||t.from_line===null)t.from_line=1;else{if(typeof t.from_line=="string"&&/\d+/.test(t.from_line)&&(t.from_line=parseInt(t.from_line)),!Number.isInteger(t.from_line))throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(s.from_line)}`);if(t.from_line<=0)throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(s.from_line)}`)}if(t.ignore_last_delimiters===void 0||t.ignore_last_delimiters===null)t.ignore_last_delimiters=!1;else if(typeof t.ignore_last_delimiters=="number")t.ignore_last_delimiters=Math.floor(t.ignore_last_delimiters),t.ignore_last_delimiters===0&&(t.ignore_last_delimiters=!1);else if(typeof t.ignore_last_delimiters!="boolean")throw new Kt("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS",["Invalid option `ignore_last_delimiters`:","the value must be a boolean value or an integer,",`got ${JSON.stringify(t.ignore_last_delimiters)}`],t);if(t.ignore_last_delimiters===!0&&t.columns===!1)throw new Kt("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS",["The option `ignore_last_delimiters`","requires the activation of the `columns` option"],t);if(t.info===void 0||t.info===null||t.info===!1)t.info=!1;else if(t.info!==!0)throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(t.info)}`);if(t.max_record_size===void 0||t.max_record_size===null||t.max_record_size===!1)t.max_record_size=0;else if(!(Number.isInteger(t.max_record_size)&&t.max_record_size>=0)){if(typeof t.max_record_size!="string"||!/\d+/.test(t.max_record_size))throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(t.max_record_size)}`);t.max_record_size=parseInt(t.max_record_size)}if(t.objname===void 0||t.objname===null||t.objname===!1)t.objname=void 0;else if(wi(t.objname)){if(t.objname.length===0)throw new Error("Invalid Option: objname must be a non empty buffer");t.encoding===null||(t.objname=t.objname.toString(t.encoding))}else if(typeof t.objname=="string"){if(t.objname.length===0)throw new Error("Invalid Option: objname must be a non empty string")}else if(typeof t.objname!="number")throw new Error(`Invalid Option: objname must be a string or a buffer, got ${t.objname}`);if(t.objname!==void 0){if(typeof t.objname=="number"){if(t.columns!==!1)throw Error("Invalid Option: objname index cannot be combined with columns or be defined as a field")}else if(t.columns===!1)throw Error("Invalid Option: objname field must be combined with columns or be defined as an index")}if(t.on_record===void 0||t.on_record===null)t.on_record=void 0;else if(typeof t.on_record!="function")throw new Kt("CSV_INVALID_OPTION_ON_RECORD",["Invalid option `on_record`:","expect a function,",`got ${JSON.stringify(t.on_record)}`],t);if(t.quote===null||t.quote===!1||t.quote==="")t.quote=null;else if(t.quote===void 0||t.quote===!0?t.quote=W.from('"',t.encoding):typeof t.quote=="string"&&(t.quote=W.from(t.quote,t.encoding)),!wi(t.quote))throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(t.quote)}`);if(t.raw===void 0||t.raw===null||t.raw===!1)t.raw=!1;else if(t.raw!==!0)throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(t.raw)}`);if(t.record_delimiter===void 0)t.record_delimiter=[];else if(typeof t.record_delimiter=="string"||wi(t.record_delimiter)){if(t.record_delimiter.length===0)throw new Kt("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a non empty string or buffer,",`got ${JSON.stringify(t.record_delimiter)}`],t);t.record_delimiter=[t.record_delimiter]}else if(!Array.isArray(t.record_delimiter))throw new Kt("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a string, a buffer or array of string|buffer,",`got ${JSON.stringify(t.record_delimiter)}`],t);if(t.record_delimiter=t.record_delimiter.map(function(n,r){if(typeof n!="string"&&!wi(n))throw new Kt("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a string, a buffer or array of string|buffer",`at index ${r},`,`got ${JSON.stringify(n)}`],t);if(n.length===0)throw new Kt("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a non empty string or buffer",`at index ${r},`,`got ${JSON.stringify(n)}`],t);return typeof n=="string"&&(n=W.from(n,t.encoding)),n}),typeof t.relax_column_count!="boolean"){if(t.relax_column_count!==void 0&&t.relax_column_count!==null)throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(t.relax_column_count)}`);t.relax_column_count=!1}if(typeof t.relax_column_count_less!="boolean"){if(t.relax_column_count_less!==void 0&&t.relax_column_count_less!==null)throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(t.relax_column_count_less)}`);t.relax_column_count_less=!1}if(typeof t.relax_column_count_more!="boolean"){if(t.relax_column_count_more!==void 0&&t.relax_column_count_more!==null)throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(t.relax_column_count_more)}`);t.relax_column_count_more=!1}if(typeof t.relax_quotes!="boolean"){if(t.relax_quotes!==void 0&&t.relax_quotes!==null)throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(t.relax_quotes)}`);t.relax_quotes=!1}if(typeof t.skip_empty_lines!="boolean"){if(t.skip_empty_lines!==void 0&&t.skip_empty_lines!==null)throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(t.skip_empty_lines)}`);t.skip_empty_lines=!1}if(typeof t.skip_records_with_empty_values!="boolean"){if(t.skip_records_with_empty_values!==void 0&&t.skip_records_with_empty_values!==null)throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(t.skip_records_with_empty_values)}`);t.skip_records_with_empty_values=!1}if(typeof t.skip_records_with_error!="boolean"){if(t.skip_records_with_error!==void 0&&t.skip_records_with_error!==null)throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(t.skip_records_with_error)}`);t.skip_records_with_error=!1}if(t.rtrim===void 0||t.rtrim===null||t.rtrim===!1)t.rtrim=!1;else if(t.rtrim!==!0)throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(t.rtrim)}`);if(t.ltrim===void 0||t.ltrim===null||t.ltrim===!1)t.ltrim=!1;else if(t.ltrim!==!0)throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(t.ltrim)}`);if(t.trim===void 0||t.trim===null||t.trim===!1)t.trim=!1;else if(t.trim!==!0)throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(t.trim)}`);if(t.trim===!0&&s.ltrim!==!1?t.ltrim=!0:t.ltrim!==!0&&(t.ltrim=!1),t.trim===!0&&s.rtrim!==!1?t.rtrim=!0:t.rtrim!==!0&&(t.rtrim=!1),t.to===void 0||t.to===null)t.to=-1;else{if(typeof t.to=="string"&&/\d+/.test(t.to)&&(t.to=parseInt(t.to)),!Number.isInteger(t.to))throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(s.to)}`);if(t.to<=0)throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(s.to)}`)}if(t.to_line===void 0||t.to_line===null)t.to_line=-1;else{if(typeof t.to_line=="string"&&/\d+/.test(t.to_line)&&(t.to_line=parseInt(t.to_line)),!Number.isInteger(t.to_line))throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(s.to_line)}`);if(t.to_line<=0)throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(s.to_line)}`)}return t},o_=function(s){return s.every(t=>t==null||t.toString&&t.toString().trim()==="")},ha={utf8:W.from([239,187,191]),utf16le:W.from([255,254])},pw=function(s,t={}){typeof s=="string"&&(s=W.from(s));const e=t&&t.objname?{}:[],i=function(l={}){const h=a_(l);return{info:{bytes:0,comment_lines:0,empty_lines:0,invalid_field_length:0,lines:1,records:0},original_options:l,options:h,state:dw(h),__needMoreData:function(c,u,p){if(p)return!1;const{encoding:m,escape:f,quote:g}=this.options,{quoting:_,needMoreDataSize:v,recordDelimiterMaxLength:x}=this.state;return u-c-1<Math.max(v,x===0?W.from(`\r
`,m).length:x,_?(f===null?0:f.length)+g.length:0,_?g.length+x:0)},parse:function(c,u,p,m){const{bom:f,encoding:g,from_line:_,ltrim:v,max_record_size:x,raw:y,relax_quotes:b,rtrim:S,skip_empty_lines:w,to:C,to_line:L}=this.options;let{comment:T,escape:E,quote:I,record_delimiter:z}=this.options;const{bomSkipped:B,previousBuf:O,rawBuffer:F,escapeIsQuote:Q}=this.state;let k;if(O===void 0){if(c===void 0)return void m();k=c}else k=O!==void 0&&c===void 0?O:W.concat([O,c]);if(B===!1)if(f===!1)this.state.bomSkipped=!0;else if(k.length<3){if(u===!1)return void(this.state.previousBuf=k)}else{for(const H in ha)if(ha[H].compare(k,0,ha[H].length)===0){const Z=ha[H].length;this.state.bufBytesStart+=Z,k=k.slice(Z),this.options=a_({...this.original_options,encoding:H}),{comment:T,escape:E,quote:I}=this.options;break}this.state.bomSkipped=!0}const X=k.length;let U;for(U=0;U<X&&!this.__needMoreData(U,X,u);U++){if(this.state.wasRowDelimiter===!0&&(this.info.lines++,this.state.wasRowDelimiter=!1),L!==-1&&this.info.lines>L)return this.state.stop=!0,void m();this.state.quoting===!1&&z.length===0&&this.__autoDiscoverRecordDelimiter(k,U)&&(z=this.options.record_delimiter);const H=k[U];if(y===!0&&F.append(H),H!==13&&H!==10||this.state.wasRowDelimiter!==!1||(this.state.wasRowDelimiter=!0),this.state.escaping===!0)this.state.escaping=!1;else{if(E!==null&&this.state.quoting===!0&&this.__isEscape(k,U,H)&&U+E.length<X){if(!Q){this.state.escaping=!0,U+=E.length-1;continue}if(this.__isQuote(k,U+E.length)){this.state.escaping=!0,U+=E.length-1;continue}}if(this.state.commenting===!1&&this.__isQuote(k,U))if(this.state.quoting===!0){const _t=k[U+I.length],Mt=S&&this.__isCharTrimable(k,U+I.length),wt=T!==null&&this.__compareBytes(T,k,U+I.length,_t),R=this.__isDelimiter(k,U+I.length,_t),A=z.length===0?this.__autoDiscoverRecordDelimiter(k,U+I.length):this.__isRecordDelimiter(_t,k,U+I.length);if(E!==null&&this.__isEscape(k,U,H)&&this.__isQuote(k,U+E.length))U+=E.length-1;else{if(!_t||R||A||wt||Mt){this.state.quoting=!1,this.state.wasQuoting=!0,U+=I.length-1;continue}if(b===!1){const G=this.__error(new Kt("CSV_INVALID_CLOSING_QUOTE",["Invalid Closing Quote:",`got "${String.fromCharCode(_t)}"`,`at line ${this.info.lines}`,"instead of delimiter, record delimiter, trimable character","(if activated) or comment"],this.options,this.__infoField()));if(G!==void 0)return G}else this.state.quoting=!1,this.state.wasQuoting=!0,this.state.field.prepend(I),U+=I.length-1}}else{if(this.state.field.length===0){this.state.quoting=!0,U+=I.length-1;continue}if(b===!1){const _t=this.__infoField(),Mt=Object.keys(ha).map(R=>!!ha[R].equals(this.state.field.toString())&&R).filter(Boolean)[0],wt=this.__error(new Kt("INVALID_OPENING_QUOTE",["Invalid Opening Quote:",`a quote is found on field ${JSON.stringify(_t.column)} at line ${_t.lines}, value is ${JSON.stringify(this.state.field.toString(g))}`,Mt?`(${Mt} bom)`:void 0],this.options,_t,{field:this.state.field}));if(wt!==void 0)return wt}}if(this.state.quoting===!1){const _t=this.__isRecordDelimiter(H,k,U);if(_t!==0){if(this.state.commenting&&this.state.wasQuoting===!1&&this.state.record.length===0&&this.state.field.length===0)this.info.comment_lines++;else{if(this.state.enabled===!1&&this.info.lines+(this.state.wasRowDelimiter===!0?1:0)>=_){this.state.enabled=!0,this.__resetField(),this.__resetRecord(),U+=_t-1;continue}if(w===!0&&this.state.wasQuoting===!1&&this.state.record.length===0&&this.state.field.length===0){this.info.empty_lines++,U+=_t-1;continue}this.info.bytes=this.state.bufBytesStart+U;const wt=this.__onField();if(wt!==void 0)return wt;this.info.bytes=this.state.bufBytesStart+U+_t;const R=this.__onRecord(p);if(R!==void 0)return R;if(C!==-1&&this.info.records>=C)return this.state.stop=!0,void m()}this.state.commenting=!1,U+=_t-1;continue}if(this.state.commenting)continue;if((T===null?0:this.__compareBytes(T,k,U,H))!==0){this.state.commenting=!0;continue}const Mt=this.__isDelimiter(k,U,H);if(Mt!==0){this.info.bytes=this.state.bufBytesStart+U;const wt=this.__onField();if(wt!==void 0)return wt;U+=Mt-1;continue}}}if(this.state.commenting===!1&&x!==0&&this.state.record_length+this.state.field.length>x)return this.__error(new Kt("CSV_MAX_RECORD_SIZE",["Max Record Size:","record exceed the maximum number of tolerated bytes",`of ${x}`,`at line ${this.info.lines}`],this.options,this.__infoField()));const Z=v===!1||this.state.quoting===!0||this.state.field.length!==0||!this.__isCharTrimable(k,U),mt=S===!1||this.state.wasQuoting===!1;if(Z!==!0||mt!==!0){if(S!==!0||this.__isCharTrimable(k,U)){Z===!1&&(U+=this.__isCharTrimable(k,U)-1);continue}return this.__error(new Kt("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE",["Invalid Closing Quote:","found non trimable byte after quote",`at line ${this.info.lines}`],this.options,this.__infoField()))}this.state.field.append(H)}if(u===!0)if(this.state.quoting===!0){const H=this.__error(new Kt("CSV_QUOTE_NOT_CLOSED",["Quote Not Closed:",`the parsing is finished with an opening quote at line ${this.info.lines}`],this.options,this.__infoField()));if(H!==void 0)return H}else if(this.state.wasQuoting===!0||this.state.record.length!==0||this.state.field.length!==0){this.info.bytes=this.state.bufBytesStart+U;const H=this.__onField();if(H!==void 0)return H;const Z=this.__onRecord(p);if(Z!==void 0)return Z}else this.state.wasRowDelimiter===!0?this.info.empty_lines++:this.state.commenting===!0&&this.info.comment_lines++;else this.state.bufBytesStart+=U,this.state.previousBuf=k.slice(U);this.state.wasRowDelimiter===!0&&(this.info.lines++,this.state.wasRowDelimiter=!1)},__onRecord:function(c){const{columns:u,group_columns_by_name:p,encoding:m,info:f,from:g,relax_column_count:_,relax_column_count_less:v,relax_column_count_more:x,raw:y,skip_records_with_empty_values:b}=this.options,{enabled:S,record:w}=this.state;if(S===!1)return this.__resetRecord();const C=w.length;if(u===!0)return b===!0&&o_(w)?void this.__resetRecord():this.__firstLineToColumns(w);if(u===!1&&this.info.records===0&&(this.state.expectedRecordLength=C),C!==this.state.expectedRecordLength){const L=u===!1?new Kt("CSV_RECORD_INCONSISTENT_FIELDS_LENGTH",["Invalid Record Length:",`expect ${this.state.expectedRecordLength},`,`got ${C} on line ${this.info.lines}`],this.options,this.__infoField(),{record:w}):new Kt("CSV_RECORD_INCONSISTENT_COLUMNS",["Invalid Record Length:",`columns length is ${u.length},`,`got ${C} on line ${this.info.lines}`],this.options,this.__infoField(),{record:w});if(_===!0||v===!0&&C<this.state.expectedRecordLength||x===!0&&C>this.state.expectedRecordLength)this.info.invalid_field_length++,this.state.error=L;else{const T=this.__error(L);if(T)return T}}if(b===!0&&o_(w))this.__resetRecord();else{if(this.state.recordHasError===!0)return this.__resetRecord(),void(this.state.recordHasError=!1);if(this.info.records++,g===1||this.info.records>=g){const{objname:L}=this.options;if(u!==!1){const T={};for(let E=0,I=w.length;E<I;E++)u[E]===void 0||u[E].disabled||(p===!0&&T[u[E].name]!==void 0?Array.isArray(T[u[E].name])?T[u[E].name]=T[u[E].name].concat(w[E]):T[u[E].name]=[T[u[E].name],w[E]]:T[u[E].name]=w[E]);if(y===!0||f===!0){const E=Object.assign({record:T},y===!0?{raw:this.state.rawBuffer.toString(m)}:{},f===!0?{info:this.__infoRecord()}:{}),I=this.__push(L===void 0?E:[T[L],E],c);if(I)return I}else{const E=this.__push(L===void 0?T:[T[L],T],c);if(E)return E}}else if(y===!0||f===!0){const T=Object.assign({record:w},y===!0?{raw:this.state.rawBuffer.toString(m)}:{},f===!0?{info:this.__infoRecord()}:{}),E=this.__push(L===void 0?T:[w[L],T],c);if(E)return E}else{const T=this.__push(L===void 0?w:[w[L],w],c);if(T)return T}}this.__resetRecord()}},__firstLineToColumns:function(c){const{firstLineToHeaders:u}=this.state;try{const p=u===void 0?c:u.call(null,c);if(!Array.isArray(p))return this.__error(new Kt("CSV_INVALID_COLUMN_MAPPING",["Invalid Column Mapping:","expect an array from column function,",`got ${JSON.stringify(p)}`],this.options,this.__infoField(),{headers:p}));const m=s_(p);return this.state.expectedRecordLength=m.length,this.options.columns=m,void this.__resetRecord()}catch(p){return p}},__resetRecord:function(){this.options.raw===!0&&this.state.rawBuffer.reset(),this.state.error=void 0,this.state.record=[],this.state.record_length=0},__onField:function(){const{cast:c,encoding:u,rtrim:p,max_record_size:m}=this.options,{enabled:f,wasQuoting:g}=this.state;if(f===!1)return this.__resetField();let _=this.state.field.toString(u);if(p===!0&&g===!1&&(_=_.trimRight()),c===!0){const[v,x]=this.__cast(_);if(v!==void 0)return v;_=x}this.state.record.push(_),m!==0&&typeof _=="string"&&(this.state.record_length+=_.length),this.__resetField()},__resetField:function(){this.state.field.reset(),this.state.wasQuoting=!1},__push:function(c,u){const{on_record:p}=this.options;if(p!==void 0){const m=this.__infoRecord();try{c=p.call(null,c,m)}catch(f){return f}if(c==null)return}u(c)},__cast:function(c){const{columns:u,relax_column_count:p}=this.options;if(Array.isArray(u)===!0&&p&&this.options.columns.length<=this.state.record.length)return[void 0,void 0];if(this.state.castField!==null)try{const m=this.__infoField();return[void 0,this.state.castField.call(null,c,m)]}catch(m){return[m]}if(this.__isFloat(c))return[void 0,parseFloat(c)];if(this.options.cast_date!==!1){const m=this.__infoField();return[void 0,this.options.cast_date.call(null,c,m)]}return[void 0,c]},__isCharTrimable:function(c,u){return((p,m)=>{const{timchars:f}=this.state;t:for(let g=0;g<f.length;g++){const _=f[g];for(let v=0;v<_.length;v++)if(_[v]!==p[m+v])continue t;return _.length}return 0})(c,u)},__isFloat:function(c){return c-parseFloat(c)+1>=0},__compareBytes:function(c,u,p,m){if(c[0]!==m)return 0;const f=c.length;for(let g=1;g<f;g++)if(c[g]!==u[p+g])return 0;return f},__isDelimiter:function(c,u,p){const{delimiter:m,ignore_last_delimiters:f}=this.options;if(f===!0&&this.state.record.length===this.options.columns.length-1||f!==!1&&typeof f=="number"&&this.state.record.length===f-1)return 0;t:for(let g=0;g<m.length;g++){const _=m[g];if(_[0]===p){for(let v=1;v<_.length;v++)if(_[v]!==c[u+v])continue t;return _.length}}return 0},__isRecordDelimiter:function(c,u,p){const{record_delimiter:m}=this.options,f=m.length;t:for(let g=0;g<f;g++){const _=m[g],v=_.length;if(_[0]===c){for(let x=1;x<v;x++)if(_[x]!==u[p+x])continue t;return _.length}}return 0},__isEscape:function(c,u,p){const{escape:m}=this.options;if(m===null)return!1;const f=m.length;if(m[0]===p){for(let g=0;g<f;g++)if(m[g]!==c[u+g])return!1;return!0}return!1},__isQuote:function(c,u){const{quote:p}=this.options;if(p===null)return!1;const m=p.length;for(let f=0;f<m;f++)if(p[f]!==c[u+f])return!1;return!0},__autoDiscoverRecordDelimiter:function(c,u){const{encoding:p}=this.options,m=[W.from(`\r
`,p),W.from(`
`,p),W.from("\r",p)];t:for(let f=0;f<m.length;f++){const g=m[f].length;for(let _=0;_<g;_++)if(m[f][_]!==c[u+_])continue t;return this.options.record_delimiter.push(m[f]),this.state.recordDelimiterMaxLength=m[f].length,m[f].length}return 0},__error:function(c){const{encoding:u,raw:p,skip_records_with_error:m}=this.options,f=typeof c=="string"?new Error(c):c;return m?(this.state.recordHasError=!0,void(this.options.on_skip!==void 0&&this.options.on_skip(f,p?this.state.rawBuffer.toString(u):void 0))):f},__infoDataSet:function(){return{...this.info,columns:this.options.columns}},__infoRecord:function(){const{columns:c,raw:u,encoding:p}=this.options;return{...this.__infoDataSet(),error:this.state.error,header:c===!0,index:this.state.record.length,raw:u?this.state.rawBuffer.toString(p):void 0}},__infoField:function(){const{columns:c}=this.options,u=Array.isArray(c);return{...this.__infoRecord(),column:u===!0?c.length>this.state.record.length?c[this.state.record.length].name:null:this.state.record.length,quoting:this.state.wasQuoting}}}}(t),n=l=>{i.options.objname===void 0?e.push(l):e[l[0]]=l[1]},r=()=>{},a=i.parse(s,!1,n,r);if(a!==void 0)throw a;const o=i.parse(void 0,!0,n,r);if(o!==void 0)throw o;return e};var ao={exports:{}};ao.exports=c_,ao.exports.parse=c_,ao.exports.stringify=function s(t){t.type==="Feature"&&(t=t.geometry);function e(a){return a.join(" ")}function i(a){return a.map(e).join(", ")}function n(a){return a.map(i).map(r).join(", ")}function r(a){return"("+a+")"}switch(t.type){case"Point":return"POINT ("+e(t.coordinates)+")";case"LineString":return"LINESTRING ("+i(t.coordinates)+")";case"Polygon":return"POLYGON ("+n(t.coordinates)+")";case"MultiPoint":return"MULTIPOINT ("+i(t.coordinates)+")";case"MultiPolygon":return"MULTIPOLYGON ("+(t.coordinates.map(n).map(r).join(", ")+")");case"MultiLineString":return"MULTILINESTRING ("+n(t.coordinates)+")";case"GeometryCollection":return"GEOMETRYCOLLECTION ("+t.geometries.map(s).join(", ")+")";default:throw new Error("stringify requires a valid GeoJSON Feature or geometry object as input")}};var l_=/[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/,h_=new RegExp("^"+l_.source+"(\\s"+l_.source+"){1,}");function c_(s){var t=s.split(";"),e=t.pop(),i=(t.shift()||"").split("=").pop(),n=0;function r(c){var u=e.substring(n).match(c);return u?(n+=u[0].length,u[0]):null}function a(){r(/^\s*/)}function o(){a();for(var c,u=0,p=[],m=[p],f=p;c=r(/^(\()/)||r(/^(\))/)||r(/^(,)/)||r(h_);){if(c==="(")m.push(f),f=[],m[m.length-1].push(f),u++;else if(c===")"){if(f.length===0||!(f=m.pop()))return null;if(--u===0)break}else if(c===",")f=[],m[m.length-1].push(f);else{if(c.split(/\s/g).some(isNaN))return null;Array.prototype.push.apply(f,c.split(/\s/g).map(parseFloat))}a()}return u!==0?null:p}function l(){for(var c,u,p=[];u=r(h_)||r(/^(,)/);)u===","?(p.push(c),c=[]):u.split(/\s/g).some(isNaN)||(c||(c=[]),Array.prototype.push.apply(c,u.split(/\s/g).map(parseFloat))),a();return c?(p.push(c),p.length?p:null):null}function h(){return function(){if(!r(/^(point(\sz)?)/i)||(a(),!r(/^(\()/)))return null;var c=l();return c?(a(),r(/^(\))/)?{type:"Point",coordinates:c[0]}:null):null}()||function(){if(!r(/^(linestring(\sz)?)/i)||(a(),!r(/^(\()/)))return null;var c=l();return c&&r(/^(\))/)?{type:"LineString",coordinates:c}:null}()||function(){if(!r(/^(polygon(\sz)?)/i))return null;a();var c=o();return c?{type:"Polygon",coordinates:c}:null}()||function(){if(!r(/^(multipoint)/i))return null;a();var c=e.substring(e.indexOf("(")+1,e.length-1).replace(/\(/g,"").replace(/\)/g,"");e="MULTIPOINT ("+c+")";var u=o();return u?(a(),{type:"MultiPoint",coordinates:u}):null}()||function(){if(!r(/^(multilinestring)/i))return null;a();var c=o();return c?(a(),{type:"MultiLineString",coordinates:c}):null}()||function(){if(!r(/^(multipolygon)/i))return null;a();var c=o();return c?{type:"MultiPolygon",coordinates:c}:null}()||function(){var c,u=[];if(!r(/^(geometrycollection)/i)||(a(),!r(/^(\()/)))return null;for(;c=h();)u.push(c),a(),r(/^(,)/),a();return r(/^(\))/)?{type:"GeometryCollection",geometries:u}:null}()}return function(c){return c&&i.match(/\d+/)&&(c.crs={type:"name",properties:{name:"urn:ogc:def:crs:EPSG::"+i}}),c}(h())}const u_=class extends rs{constructor(s){super(s),d(this,"_coordinatesKey","coordinates"),d(this,"_csvDataType"),d(this,"_csvFeatures",[]),d(this,"_csvIndexMap",[]),this.type="CSVDataSource"}async _getFetchData(s){return await s.text()}getOriginDataIndex(s){return s<this._templateDataLength?this._csvIndexMap[s]:[s-this._templateDataLength+this._csvFeatures.length,0]}getOriginData(s){if(s<this._templateDataLength){const t=this._csvIndexMap[s];return this._csvFeatures[t[0]]}return this._addCache[s-this._templateDataLength]}onClear(){this._csvDataType=void 0,this._csvFeatures=[]}originToFeatures(s){for(let t=0;t<this._csvFeatures.length;t++){const e=this._csvFeatures[t];s.push({type:"Feature",geometry:{type:e.geometry.type,coordinates:e.geometry.coordinates},properties:e.properties})}return s}_onProcessTemplateData(s,t){return this._prepareFeatures(),this._parseFeature(s,t),s}_parseFeature(s,t){let e=0;for(let i=0;i<this._csvFeatures.length;i++){const n=this._csvFeatures[i],r=this._onDecomposeFeature(this._csvDataType,n);for(let a=0;a<r.length;a++){const o=r[a];s.position.push(o.geometry[this.projectionName]),a>0&&e++,s.index.push(i+e),this._csvIndexMap[i+e]=[i,a];let l={position:o.geometry[this.projectionName],index:i+e};for(const h of this._attributeMap.keys()){let c;o.properties&&o.properties[this._attributeMap.get(h)]!==void 0&&o.properties[this._attributeMap.get(h)]!==null?c=o.properties[this._attributeMap.get(h)]:this._attributeMap.get(h)instanceof Function&&(c=this._attributeMap.get(h)(o.properties)),s[h].push(c),l[h]=c}t.push(l)}}}_prepareFeatures(){this._csvFeatures=this.csvToFeatures(),this._getDataType()}csvToFeatures(){if(!this.origin)return[];let s=pw(this.origin,{columns:!0,skip_empty_lines:!0});const t=[];for(let e=0;e<s.length;e++){const i=s[e],n={};let r;Object.keys(i).forEach(a=>{a===this._coordinatesKey?r={geometry:ao.exports(i[a]),properties:n}:n[a]=i[a]}),Array.isArray(r)?t.push(...r):t.push(r)}return xl(t,this.projectionName)}_getDataType(){var s,t;this._csvDataType=super._getDataType((t=(s=this._csvFeatures[0])==null?void 0:s.geometry)==null?void 0:t.type)}get csvDataType(){return this._csvDataType}};let d_=u_;d(d_,"fromUrl",async function(s){let t=new u_;return await t.load(s),t});const ku=class extends rs{constructor(s){super(s),d(this,"_coordinatesKey","coordinates"),d(this,"_jsonFeatures",[]),d(this,"_jsonIndexMap",[]),d(this,"_jsonDataType"),this.type="JSONDataSource"}getOriginDataIndex(s){return s<this._templateDataLength?this._jsonIndexMap[s]:[s-this._templateDataLength+this._jsonFeatures.length,0]}async _getFetchData(s){return await s.json()}getOriginData(s){if(s<this._templateDataLength){const t=this._jsonIndexMap[s];return this._jsonFeatures[t[0]]}return this._addCache[s-this._templateDataLength]}originToFeatures(s){for(let t=0;t<this._jsonFeatures.length;t++){const e=this._jsonFeatures[t];s.push({type:"Feature",geometry:{type:e.geometry.type,coordinates:e.geometry.coordinates},properties:e.properties})}return s}_onProcessTemplateData(s,t){return this._prepareFeatures(),this._parseFeature(s,t),s}_prepareFeatures(){this._jsonFeatures=this._parseJson(this.origin),this._getDataType()}_parseJson(s){let t=[];if(Array.isArray(s))for(let e=0;e<s.length;e++){const i=this._parseJson(s[e]);t.push(...i)}else{let e={},i={};for(let n in s)Object.hasOwnProperty.call(s,n)&&(n===this.coordinatesKey?(i.geometry=ao.exports(s[n]),i.properties=e):e[n]=s[n]);t.push(i)}return xl(t,this.projectionName)}_parseFeature(s,t){let e=0;for(let i=0;i<this._jsonFeatures.length;i++){const n=this._jsonFeatures[i],r=this._onDecomposeFeature(this._jsonDataType,n);for(let a=0;a<r.length;a++){const o=r[a];s.position.push(o.geometry[this.projectionName]),a>0&&e++,s.index.push(i+e),this._jsonIndexMap[i+e]=[i,a];let l={position:o.geometry[this.projectionName],index:i+e};for(const h of this._attributeMap.keys()){let c;o.properties&&o.properties[this._attributeMap.get(h)]!==void 0&&o.properties[this._attributeMap.get(h)]!==null?c=o.properties[this._attributeMap.get(h)]:this._attributeMap.get(h)instanceof Function&&(c=this._attributeMap.get(h)(o.properties)),s[h].push(c),l[h]=c}t.push(l)}}}_getDataType(){var s,t;this._jsonDataType=super._getDataType((t=(s=this._jsonFeatures[0])==null?void 0:s.geometry)==null?void 0:t.type)}onClear(){this._jsonDataType=void 0,this._jsonFeatures=[]}get jsonDataType(){return this._jsonDataType}get coordinatesKey(){return this._coordinatesKey}set coordinatesKey(s){this._coordinatesKey=s}};let Nu=ku;d(Nu,"fromUrl",async function(s){let t=new ku;return await t.load(s),t}),d(Nu,"fromJSON",function(s){let t=new ku;return t.setData(s),t});class mw{constructor(){d(this,"_process",[]),d(this,"_hasTime",!1)}provide(t){let e=0;this._hasTime||(e=new Date().valueOf());for(let i=0;i<t.length;i++){const n=t[i];for(let r=0;r<this._process.length;r++){const a=this._process[r];typeof a[1]=="string"&&n[a[1]]?n[a[0]]=n[a[1]]:a[1]instanceof Function?n[a[0]]=a[1](n):n[a[0]]=void 0}this._hasTime||(n.time=e)}return t}process(t,e){return t==="time"&&(this._hasTime=!0),this._process.push([t,e]),this}}class zn{constructor(t=0,e=0){this.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6],this.y=n[1]*e+n[4]*i+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),n=Math.sin(e),r=this.x-t.x,a=this.y-t.y;return this.x=r*i-a*n+t.x,this.y=r*n+a*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}for(let s=0;s<256;s++)s.toString(16);function p_(s,t,e){return Math.max(t,Math.min(e,s))}class fw{constructor(t=0,e=0,i=0,n=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=n}static slerp(t,e,i,n){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,e,n)}static slerpFlat(t,e,i,n,r,a,o){let l=i[n+0],h=i[n+1],c=i[n+2],u=i[n+3];const p=r[a+0],m=r[a+1],f=r[a+2],g=r[a+3];if(o===0)return t[e+0]=l,t[e+1]=h,t[e+2]=c,void(t[e+3]=u);if(o===1)return t[e+0]=p,t[e+1]=m,t[e+2]=f,void(t[e+3]=g);if(u!==g||l!==p||h!==m||c!==f){let _=1-o;const v=l*p+h*m+c*f+u*g,x=v>=0?1:-1,y=1-v*v;if(y>Number.EPSILON){const S=Math.sqrt(y),w=Math.atan2(S,v*x);_=Math.sin(_*w)/S,o=Math.sin(o*w)/S}const b=o*x;if(l=l*_+p*b,h=h*_+m*b,c=c*_+f*b,u=u*_+g*b,_===1-o){const S=1/Math.sqrt(l*l+h*h+c*c+u*u);l*=S,h*=S,c*=S,u*=S}}t[e]=l,t[e+1]=h,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,i,n,r,a){const o=i[n],l=i[n+1],h=i[n+2],c=i[n+3],u=r[a],p=r[a+1],m=r[a+2],f=r[a+3];return t[e]=o*f+c*u+l*m-h*p,t[e+1]=l*f+c*p+h*u-o*m,t[e+2]=h*f+c*m+o*p-l*u,t[e+3]=c*f-o*u-l*p-h*m,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,n){return this._x=t,this._y=e,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,n=t._y,r=t._z,a=t._order,o=Math.cos,l=Math.sin,h=o(i/2),c=o(n/2),u=o(r/2),p=l(i/2),m=l(n/2),f=l(r/2);switch(a){case"XYZ":this._x=p*c*u+h*m*f,this._y=h*m*u-p*c*f,this._z=h*c*f+p*m*u,this._w=h*c*u-p*m*f;break;case"YXZ":this._x=p*c*u+h*m*f,this._y=h*m*u-p*c*f,this._z=h*c*f-p*m*u,this._w=h*c*u+p*m*f;break;case"ZXY":this._x=p*c*u-h*m*f,this._y=h*m*u+p*c*f,this._z=h*c*f+p*m*u,this._w=h*c*u-p*m*f;break;case"ZYX":this._x=p*c*u-h*m*f,this._y=h*m*u+p*c*f,this._z=h*c*f-p*m*u,this._w=h*c*u+p*m*f;break;case"YZX":this._x=p*c*u+h*m*f,this._y=h*m*u+p*c*f,this._z=h*c*f-p*m*u,this._w=h*c*u-p*m*f;break;case"XZY":this._x=p*c*u-h*m*f,this._y=h*m*u-p*c*f,this._z=h*c*f+p*m*u,this._w=h*c*u+p*m*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,n=Math.sin(i);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],n=e[4],r=e[8],a=e[1],o=e[5],l=e[9],h=e[2],c=e[6],u=e[10],p=i+o+u;if(p>0){const m=.5/Math.sqrt(p+1);this._w=.25/m,this._x=(c-l)*m,this._y=(r-h)*m,this._z=(a-n)*m}else if(i>o&&i>u){const m=2*Math.sqrt(1+i-o-u);this._w=(c-l)/m,this._x=.25*m,this._y=(n+a)/m,this._z=(r+h)/m}else if(o>u){const m=2*Math.sqrt(1+o-i-u);this._w=(r-h)/m,this._x=(n+a)/m,this._y=.25*m,this._z=(l+c)/m}else{const m=2*Math.sqrt(1+u-i-o);this._w=(a-n)/m,this._x=(r+h)/m,this._y=(l+c)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(p_(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const n=Math.min(1,e/i);return this.slerp(t,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,n=t._y,r=t._z,a=t._w,o=e._x,l=e._y,h=e._z,c=e._w;return this._x=i*c+a*o+n*h-r*l,this._y=n*c+a*l+r*o-i*h,this._z=r*c+a*h+i*l-n*o,this._w=a*c-i*o-n*l-r*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,n=this._y,r=this._z,a=this._w;let o=a*t._w+i*t._x+n*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=a,this._x=i,this._y=n,this._z=r,this;const l=1-o*o;if(l<=Number.EPSILON){const m=1-e;return this._w=m*a+e*this._w,this._x=m*i+e*this._x,this._y=m*n+e*this._y,this._z=m*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(l),c=Math.atan2(h,o),u=Math.sin((1-e)*c)/h,p=Math.sin(e*c)/h;return this._w=a*u+this._w*p,this._x=i*u+this._x*p,this._y=n*u+this._y*p,this._z=r*u+this._z*p,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=Math.random(),e=Math.sqrt(1-t),i=Math.sqrt(t),n=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(n),i*Math.sin(r),i*Math.cos(r),e*Math.sin(n))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ca{constructor(t=0,e=0,i=0){this.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(m_.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(m_.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6]*n,this.y=r[1]*e+r[4]*i+r[7]*n,this.z=r[2]*e+r[5]*i+r[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,r=t.elements,a=1/(r[3]*e+r[7]*i+r[11]*n+r[15]);return this.x=(r[0]*e+r[4]*i+r[8]*n+r[12])*a,this.y=(r[1]*e+r[5]*i+r[9]*n+r[13])*a,this.z=(r[2]*e+r[6]*i+r[10]*n+r[14])*a,this}applyQuaternion(t){const e=this.x,i=this.y,n=this.z,r=t.x,a=t.y,o=t.z,l=t.w,h=l*e+a*n-o*i,c=l*i+o*e-r*n,u=l*n+r*i-a*e,p=-r*e-a*i-o*n;return this.x=h*l+p*-r+c*-o-u*-a,this.y=c*l+p*-a+u*-r-h*-o,this.z=u*l+p*-o+h*-a-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*n,this.y=r[1]*e+r[5]*i+r[9]*n,this.z=r[2]*e+r[6]*i+r[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,n=t.y,r=t.z,a=e.x,o=e.y,l=e.z;return this.x=n*l-r*o,this.y=r*a-i*l,this.z=i*o-n*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return Uu.copy(this).projectOnVector(t),this.sub(Uu)}reflect(t){return this.sub(Uu.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(p_(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,n=this.z-t.z;return e*e+i*i+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const n=Math.sin(e)*t;return this.x=n*Math.sin(i),this.y=Math.cos(e)*t,this.z=n*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=n,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(e),this.y=i*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Uu=new ca,m_=new fw;function oo(s,t,e=2e-7){return ds(s,t)<e}function ds(s,t){return Math.sqrt(Math.pow(s[0]-t[0],2)+Math.pow(s[1]-t[1],2)+Math.pow((s[2]||0)-(t[2]||0),2))}function ps(s,t,e){return s+(t-s)*e}function Fu(s,t,e){return[s[0]+(t[0]-s[0])*e,s[1]+(t[1]-s[1])*e,s[2]+(t[2]-s[2])*e]}function Ye(s,t){let e=new zn;return e.fromArray([t[0]-s[0],t[1]-s[1]]),e.normalize(),e}function Ze(s){return new zn(-s.y,s.x)}function f_(s,t){let e=new zn;return e.addVectors(s,t),e.normalize(),Ze(e)}function g_(s,t,e){const[i,n,r]=s,a=n[0]-i[0],o=n[1]-i[1],l=Math.atan(o/a),h=l+Math.PI/2,c=[i[0]+a*(1-r),i[1]+o*(1-r)],u=[0,c[1]-Math.tan(h)*c[0]],[p,m,f]=t,g=m[0]-p[0],_=m[1]-p[1],v=Math.atan(_/g)+Math.PI/2,x=[p[0]+g*f,p[1]+_*f],y=[0,x[1]-Math.tan(v)*x[0]],b=function(C,L,T,E){let I=(L.y-C.y)*(E.x-T.x)-(C.x-L.x)*(T.y-E.y);return I!==0&&{x:((L.x-C.x)*(E.x-T.x)*(T.y-C.y)+(L.y-C.y)*(E.x-T.x)*C.x-(E.y-T.y)*(L.x-C.x)*T.x)/I,y:-((L.y-C.y)*(E.y-T.y)*(T.x-C.x)+(L.x-C.x)*(E.y-T.y)*C.y-(E.x-T.x)*(L.y-C.y)*T.y)/I}}({x:u[0],y:u[1]},{x:c[0],y:c[1]},{x:y[0],y:y[1]},{x:x[0],y:x[1]});let S,w;if(b){const C=b.x-c[0],L=b.y-c[1],T=Math.sqrt(C*C+L*L),E=new ca(b.x,b.y),I=new ca(c[0],c[1]),z=new ca(x[0],x[1]),B=new ca().subVectors(E,I).normalize(),O=new ca().subVectors(E,z).normalize().angleTo(B),F=new zn().subVectors(new zn(n[0],n[1]),new zn(i[0],i[1])).normalize(),Q=new zn().subVectors(new zn(m[0],m[1]),new zn(p[0],p[1])).normalize();let k=0;switch(F.angle()<Math.PI/2?k=1:F.angle()<Math.PI?k=2:F.angle()<1.5*Math.PI?k=3:F.angle()<2*Math.PI&&(k=4),k){case 1:if(Q.angle()>F.angle()&&Q.angle()<F.negate().angle()){const X=Math.abs(l)+e*O/2,U=T*Math.sin(X),H=T*Math.cos(X);S=[b.x+U,b.y-H],w=[U,-H]}else{const X=Math.PI/2-Math.abs(l)+e*O/2,U=T*Math.cos(X),H=T*Math.sin(X);S=[b.x-U,b.y+H],w=[U,-H]}break;case 2:if(Q.angle()>F.angle()&&Q.angle()<F.negate().angle()){const X=Math.PI/2-Math.abs(l)+e*O/2,U=T*Math.cos(X),H=T*Math.sin(X);S=[b.x+U,b.y+H],w=[U,H]}else{const X=Math.abs(l)+e*O/2,U=T*Math.sin(X),H=T*Math.cos(X);S=[b.x-U,b.y-H],w=[U,H]}break;case 3:if(Q.angle()<F.angle()&&Q.angle()>F.negate().angle()){const X=Math.PI/2-Math.abs(l)+e*O/2,U=T*Math.cos(X),H=T*Math.sin(X);S=[b.x+U,b.y-H],w=[-U,H]}else{const X=Math.abs(l)+e*O/2,U=T*Math.sin(X),H=T*Math.cos(X);S=[b.x-U,b.y+H],w=[-U,H]}break;case 4:if(Q.angle()<F.angle()&&Q.angle()>F.negate().angle()){const X=Math.abs(l)+e*O/2,U=T*Math.sin(X),H=T*Math.cos(X);S=[b.x+U,b.y+H],w=[-U,-H]}else{const X=Math.PI/2-Math.abs(l)+e*O/2,U=T*Math.cos(X),H=T*Math.sin(X);S=[b.x-U,b.y-H],w=[-U,-H]}}}return{point:S,center:b,interPointA:c,interPointB:x,direction:w}}class gw{constructor(t){d(this,"id",null),d(this,"data",[]),d(this,"interpolateDirectThreshold",10),t&&typeof t=="number"&&(this.data=new Array(t))}tick(t,e){let i=this.data[0],n=this.data[1];if(!i||!n)return null;const r=(e-i.time)/(n.time-i.time),a=Fu(i.point,n.point,r),o=t.map.projectPointArr(a);let l=i.dir,h=ds(o,t.map.projectPointArr(n.point));return h<this.interpolateDirectThreshold&&(l=ps(l,n.dir,1-h/this.interpolateDirectThreshold)),{...i,id:this.id,modelType:i.modelType,ratio:r,point:a,position:o,dir:l}}push(t){if(!this.id&&t&&(this.id=t.id,this.modelType=t.modelType),this.id)return this.data.push(t)}shift(){return this.data.shift()}splice(t,e,...i){return this.data.splice(t,e,...i)}get length(){return this.data.length}get empty(){return this.data.join("")===""}}class _w{constructor(t){d(this,"_entities",new Map),d(this,"_entityCacheTimes",[]),d(this,"_startTime",1/0),d(this,"_timeOffset",0),this.delay=t.delay,this.twin=t.twin}push(t){const e=t[0].time,i=this._entities;for(let n=0;n<t.length;n++){const r=t[n];i.get(r.id)||i.set(r.id,new gw(this._entityCacheTimes.length)),i.get(r.id).push(r)}Array.from(i.entries()).forEach(([n,r])=>{r.length===this._entityCacheTimes.length&&r.push(void 0)}),this._entityCacheTimes.push(e)}shift(t){const e=this._entities,i=this._entityCacheTimes;let n=0,r=[];for(let a=1;a<i.length;a++){const o=i[a];if(t-this.delay-this.timeOffset<o)break;n+=1}return i.splice(0,n),Array.from(e.entries()).forEach(([a,o])=>{o.splice(0,n),o.empty&&(e.delete(a),r.push(a))}),i.length===1&&this.reset(),r}tick(t,e){if(e-this.delay<this._startTime)return{};this.shift(e);const i=Array.from(this._entities.values()),n=[],r=[],a=[],o=[],l=[],h=[],c=[],u=[],p=[],m={};for(let f=0;f<i.length;f++){let g=i[f].tick(t,e-this.delay-this.timeOffset);g&&(n.push(g.id),r.push(n.length-1),a.push(g.position),o.push(...g.position),l.push(0,0,g.dir),h.push(1,1,1),c.push(g.modelType),u.push(g),p.push(g.color),m[g.modelType]?m[g.modelType].push(n.length-1):m[g.modelType]=[n.length-1])}return{buffers:{id:n,index:r,position:a,translation:o,rotation:l,scale:h,modelType:c,payload:u,color:p},modelIndexMap:m}}reset(){this._startTime=1/0,this._timeOffset=0,this._entityCacheTimes=[],this._entities=new Map,this.twin.reset()}get startTime(){return this._startTime}set startTime(t){this._startTime=t}get timeOffset(){return this._timeOffset}set timeOffset(t){this._timeOffset=t}}class lo extends St{constructor(){super(...arguments),d(this,"_trackObject",null),d(this,"_trackConfig",{}),d(this,"_trackParams",{})}track(t,e){this._trackObject=t,this._trackConfig={...e}}stop(){const t=this._engine.map.map;if(this._engine.map.mapType==="blank"){t.cameraDistance=this._trackConfig.radius;let e=100/(this._engine._container.clientHeight/2)*Math.tan(this._engine.map.fov/2*Math.PI/180),i=this._engine.map.getZoomByZoomUnits(e);t.zoom=i,t.zoomUnits=e,t.heading=this._trackParams.heading,t.pitch=this._trackParams.pitch,t.center=this._trackParams.center}this._trackObject=null,this._trackConfig={},this._trackParams={}}afterAddToEngine(t){this._engine=t,t.map.mapType!=="blank"&&t.map.mapType!=="blank_3dcontrol"&&console.error("PathTracker is not compatible with current type of Map.")}onBeforeScenePrepareRender(t,e,i,n){this._trackObject&&(this._trackParams=lo.getCameraByTargetAndView(t,this._trackObject,this._trackConfig)),this._engine.requestRender()}static getCameraByTargetAndView(t,e,i={}){let n,r;if(e.instance&&e.instanceIndex!==void 0){const h=new M,c=new Ht,u=new Wi,p=new M,m=new rt,f=e.instance.getEntityByIndex(e.instanceIndex);if(!f)return;{m.elements=f.matrix,m.decompose(h,c,p),u.setFromQuaternion(c),u.y=u.z,r=u;const[g,_,v]=e.instance._rtc;n=new M(g+h.x,_+h.y,v+h.z)}}else if(e instanceof St){let h;n=e.getWorldPosition(new M),r=e.rotation,e.updateMatrix(),e.updateMatrixWorld(),e.boundingBox=null,e.traverse(c=>{if(c.geometry){c.geometry.boundingBox||c.geometry.computeBoundingBox(),c.updateMatrixWorld();const u=lo.computeTransformedBoundingBox(c.geometry.boundingBox,c.matrixWorld);e.boundingBox?e.boundingBox=e.boundingBox.union(u):e.boundingBox=u}}),h=e.boundingSphere?e.boundingSphere:e.geometry&&e.geometry.boundingSphere?e.geometry.boundingSphere:e.boundingBox.getBoundingSphere(new mi),n=h.center}else if(e instanceof M)n=e.clone();else{if(!(e instanceof Array))return null;n=new M(e[0],e[1],e[2]||0)}const a=t.camera,o=a.clone();o.rotation.copy(a.rotation),o.rotation.order="ZXY",o.rotation.z=r.y-Math.PI/2,o.rotation.x=i.pitch,o.updateMatrix(),o.updateMatrixWorld();const l=o.getWorldDirection(new M).multiplyScalar(-i.radius);return o.position.copy(n.add(l)),a.position.copy(o.position),a.position.z+=i.height||0,a.rotation.copy(o.rotation),a.updateMatrix(),a.updateMatrixWorld(),a.updateProjectionMatrix(),{heading:(r.y-Math.PI/2)/Math.PI*180,pitch:i.pitch/Math.PI*180,center:[a.position.x,a.position.y]}}static computeTransformedBoundingBox(t,e){const i=[new M(t.min.x,t.min.y,t.min.z).applyMatrix4(e),new M(t.min.x,t.min.y,t.min.z).applyMatrix4(e),new M(t.max.x,t.min.y,t.min.z).applyMatrix4(e),new M(t.min.x,t.max.y,t.min.z).applyMatrix4(e),new M(t.min.x,t.min.y,t.max.z).applyMatrix4(e),new M(t.min.x,t.max.y,t.max.z).applyMatrix4(e),new M(t.max.x,t.max.y,t.min.z).applyMatrix4(e),new M(t.max.x,t.min.y,t.max.z).applyMatrix4(e),new M(t.max.x,t.max.y,t.max.z).applyMatrix4(e)],n=new He;return n.setFromPoints(i),n}}const vw=new ea;new rt;let nh=new rt,er=new rt,ho=new rt,sh=new lt,kn=[],ir=new M,ua=new Lt;class Si extends Sn{constructor(t,e){super(),d(this,"type","InstancedMesh"),d(this,"isMesh",!0),d(this,"isInstancedMesh",!0),d(this,"frustumCulled",!1),d(this,"instanceColor",null),d(this,"count",0),d(this,"instanceMatrix"),d(this,"_enableInstanceColor",!1),d(this,"instanceMorphMatrix",new rt),d(this,"isEventEntitySupported",!0),d(this,"getInstanceLocalMatrix",(i,n,r)=>null),d(this,"addCustomAttributes",()=>{}),this.geometry=t,this.material=e,this.instanceMatrix=new Xi(new Float32Array(0),16)}set enableInstanceColor(t){t!==this._enableInstanceColor&&(this._enableInstanceColor=t,this.needsUpdate=!0)}get enableInstanceColor(){return this._enableInstanceColor}collisionTest(t){let e=this.material.keepSize?this.size:0;return{width:e,height:e}}setData(){let t=[];t=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData;const e=[],i=[],n=[];let r=1/0,a=1/0,o=1/0,l=-1/0,h=-1/0,c=-1/0;for(let p=0;p<t.length;p++){const m=t[p].position,[f,g,_=0]=m;f<r&&(r=f),f>l&&(l=f),g<a&&(a=g),g>h&&(h=g),_<o&&(o=_),_>c&&(c=_)}let u=[(r+l)/2,(a+h)/2,(o+c)/2||0];for(let p=0;p<t.length;p++){const m=t[p].position;t[p].index;const f=this.getInstanceLocalMatrix(m,this.dataSource.getOriginData(p),p),g=new rt;g.makeTranslation(m[0]-u[0],m[1]-u[1],(m[2]||0)-u[2]);let _=null;f?(_=new rt,_.multiplyMatrices(g,f)):_=g;const v=_.elements;if(e.push(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[14],v[15]),i.push(Math.random()),this._enableInstanceColor){let x=qm(t[p].color);n.push(x[0],x[1],x[2])}}this.geometry.setAttribute("instancedRandomFactor",new Xi(new Float32Array(i),1)),this.addCustomAttributes(this.geometry,this.dataSource),this.geometry.computeBoundingSphere(),this.geometry.instanceCount=e.length/16,this.instanceMatrix=new Xi(new Float32Array(e),16),this._enableInstanceColor&&(this.instanceColor=new Xi(new Float32Array(n),3)),this.count=this.geometry.instanceCount,this.makeMeshPositionOffset(u),this.needsUpdate=!1}computeInstanceMorphMatrix(){const t=this.material;let e=t.height||0,i=1;if(t.keepSize&&(i=t.zoomUnits||1),t.isUseSize3){const n=t.size3;ir.set(n[0]*i,n[1]*i,n[2]*i)}else if(t.isUseSize2){const n=t.size2;ir.set(n[0]*i,n[1]*i,i)}else{let n=t.size||1;ir.set(n*i,n*i,n*i)}this.instanceMorphMatrix.identity().scale(ir).premultiply(ho.identity().makeTranslation(0,0,e*i))}getEntityByIndex(t){const e=this.dataSource,i={index:t,value:e.getOriginData(t),itemIndex:e.getOriginDataIndex(t),pairs:{}},n=e.data;for(const r of Object.keys(n))i.pairs[r]=n[r][t];return i}raycast(t,e){if(!this.visible)return;let i=this.geometry,n=this.material,r=this.matrixWorld;if(!n||!i)return;const a=this.instanceMatrix;if(!a)return;const o=a.array;this.computeInstanceMorphMatrix();const l=this.count;if(sh.geometry=this.geometry.getInstanceGeometry?this.geometry.getInstanceGeometry():this.geometry,sh.material=n,n.isInstancedBallonMaterial){const h=t.camera,c=n.resolution,u=t.mouse,p=n.size/c[0],m=n.size/c[1],f=2*(n.height+n.size/2)/c[1],g=u.x-p,_=u.x+p,v=u.y-m-f,x=u.y+m-f;ho.multiplyMatrices(h.matrixWorldInverse,r),ho.multiplyMatrices(h.projectionMatrix,ho);for(let y=0;y<l;++y)if(er.fromArray(o,16*y),ua.set(0,0,0,1).applyMatrix4(er).applyMatrix4(ho).divideScalar(ua.w),ua.x>=g&&ua.y>=v&&ua.x<=_&&ua.y<=x){ir.set(er.elements[12],er.elements[13],er.elements[14]);const b=t.ray.origin.distanceTo(ir);b>=t.near&&b<=t.far&&(kn[0]={distance:b,point:ir.clone(),itemIndex:y,object:this},e.push(kn[0]),kn.length=0)}}else for(let h=0;h<l;++h)er.fromArray(o,16*h),nh.multiplyMatrices(er,this.instanceMorphMatrix),nh.multiplyMatrices(r,nh),sh.matrixWorld=nh,sh.raycast(t,kn),kn.length>0&&(kn[0].instanceId=h,kn[0].object=this,e.push(kn[0]),kn.length=0)}}class __ extends Sn{constructor(){super(...arguments),d(this,"isPoints",!0),d(this,"isEventEntitySupported",!0)}get size(){return this.material.size}set size(t){this.material.size=t}raycast(t,e){const i=t.params.Points.threshold;let n=i*this.size;this.material.uniforms.zoomUnits&&(n*=this.material.uniforms.zoomUnits.value),t.params.Points.threshold=n,ll.prototype.raycast.call(this,t,e),t.params.Points.threshold=i}getEntityByIndex(t){const e=this.dataSource.data,i={};for(const n of Object.keys(e))i[n]=e[n][t];return i}}class xw extends Pt{constructor(t){super(t),this.parameters=t}setData(t){const{vertexSizes:e,vertexColors:i}=this.parameters,{aPositions:n,aObjectIndices:r,aMapIndexs:a,aColors:o,aSizes:l}=t;this.setAttribute("position",new et(n,3)),this.setAttribute("objectIndex",new et(r,1)),this.setAttribute("aMapIndex",new et(a,1)),i&&this.setAttribute("aColor",new et(o,4)),e&&this.setAttribute("aSize",new et(l,1))}}const yw=new Ie,bw=pt.merge([ot.fog,ki,is,{isEmissive:{value:!1},color:{value:[0,1,1,1]},size:{value:30},vertexColors:{value:!1},vertexSizes:{value:!1},uShapeType:{value:2},opacity:{value:1},map:{value:null},useMap:{value:!1},uOffset:{value:[0,0]}}]);class Mw extends Be{constructor(t){super(),this.type="SimplePointMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_SIZE
    attribute float aSize;
    varying float vSize;
#endif

#ifdef MVT_USE_VERTEX_OFFSET
    attribute vec2 aOffset;
#else
    uniform vec2 uOffset;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
    varying vec4 vColor;
#endif

uniform float size;
uniform float pixelRatio;
uniform vec2 resolution;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 
    #include <mvt_selective_vertex>

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);

    #ifdef MVT_USE_VERTEX_OFFSET
        vec2 offset = aOffset * 2. * pixelRatio * pixelSize;
    #else
        vec2 offset = uOffset * 2. * pixelRatio * pixelSize;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.xy = gl_Position.xy - offset;

    #ifdef MVT_USE_VERTEX_SIZE
        vSize = aSize * pixelRatio;
        gl_PointSize = vSize;
    #else
        gl_PointSize = size * pixelRatio;
    #endif

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #endif

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif
uniform vec4 color;
uniform float uShapeType;
uniform float opacity;

#ifdef MVT_USE_VERTEX_SIZE
    varying float vSize;
#else
    uniform float size;
#endif
uniform bool useMap;
uniform sampler2D map;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = color;
    #endif

    if (uShapeType == 2.) {
        float d = distance(gl_PointCoord, vec2(0.5, 0.5));
        #ifdef MVT_USE_VERTEX_SIZE
            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);
        #else
            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);
        #endif
        
        if (alpha <= 0.) {
            discard;
        } else {
            gl_FragColor.a *= alpha;
        }
    }
 
    if (useMap) {
        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);
     //    gl_FragColor.a += tColor.a;
        
        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);
        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);
        // gl_FragColor.a += tColor.a;
        // gl_FragColor = tColor;
    }
    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }
    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}`,this.isSimplePointMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,pt.clone(bw)),ns(this),jt(this,["size","uShapeType","opacity","isEmissive"]),_i(this,[["offset","uOffset"]]),Bs(this,["color"]),Qe(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexSizes","MVT_USE_VERTEX_SIZE"]]),ss(this),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,n="url_map";if(this.userData[n]===e)return;if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[n];const r=yw.load(e);r.wrapS=r.wrapT=ue,this.uniforms.map.value=r,this.userData[n]=e,this.uniforms.useMap.value=!0}}}),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class Bu extends __{constructor(t){super(t),d(this,"geometry"),d(this,"material"),d(this,"color"),d(this,"vertexColors"),d(this,"size"),d(this,"vertexSizes"),d(this,"opacity"),d(this,"emissive"),this.parameters=t,this.defineMaterialProxyProperties(["size","uShapeType","opacity","emissive","vertexColors","vertexSizes","color","mapSrc"])}collisionTest(t){return this.parameters.vertexSizes&&t.size?{width:t.size,height:t.size}:{width:this.size,height:this.size}}initObject(){this.geometry=new xw(this.parameters),this.material=new Mw(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}setData(){const t=this.dataSource.data,{vertexSizes:e,vertexColors:i}=this.parameters;let n=[];n=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData;const r=[],a=[],o=[],l=[];for(let h=0;h<n.length;h++){const c=n[h].position,u=n[h].index;if(r.push(...c),a.push(u),i&&t.color){let p=es(n[h].color);o.push(...p.toArray())}e&&t.size&&l.push(n[h].size)}this.geometry.setData({aPositions:r,aObjectIndices:a,aColors:o,aSizes:l}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,r),this.needsUpdate=!1}}let v_=new He,x_=new M;class rh extends vm{constructor(){super(...arguments),d(this,"isCustomInstancedBufferGeometry",!0),d(this,"instanceGeometry",null)}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new He);const t=this.attributes.instancedPosition;t!==void 0?this.boundingBox.setFromBufferAttribute(t):this.boundingBox.makeEmpty(),(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('CustomInstancedBufferGeometry.computeBoundingBox: Computed min/max have NaN values.The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new mi);let t=this.attributes.instancedPosition;if(t){let e=this.boundingSphere.center;v_.setFromBufferAttribute(t),v_.getCenter(e);let i=0;for(let n=0,r=t.count;n<r;n++)x_.fromBufferAttribute(t,n),i=Math.max(i,e.distanceToSquared(x_));this.boundingSphere.radius=Math.sqrt(i),t.count===1&&(this.boundingSphere.radius=1e5),isNaN(this.boundingSphere.radius)&&console.error('CustomInstancedBufferGeometry.computeBoundingSphere(): Computed radius is NaN.The "position" attribute is likely to have NaN values.',this)}}getInstanceGeometry(){return this.instanceGeometry||(this.instanceGeometry=new Pt,this.instanceGeometry.attributes=this.attributes,this.instanceGeometry.index=this.index),this.instanceGeometry}}class ah extends rh{constructor(){super(),d(this,"setModelData",()=>{this.setAttribute("position",new et([-.5,-.5,0,-.5,.5,0,.5,.5,0,.5,-.5,0],3)),this.setAttribute("uv",new et([0,0,0,1,1,1,1,0],2)),this.setIndex([0,2,1,0,3,2])}),this.setModelData()}}const ww=s=>{Object.defineProperties(s,{color:{get:function(){return this.uniforms.color.value},set:function(t){this.uniforms.color.value=es(t)}},height:{get:function(){return this.uniforms.height.value},set:function(t){this.uniforms.height.value=t}},size:{get:function(){return this.uniforms.size.value},set:function(t){this.uniforms.size.value=t}},size3:{get:function(){return this.uniforms.size3.value},set:function(t){Array.isArray(t)&&t.length===3&&(this.uniforms.size3.value=t)}},useSize3:{get:function(){return this.defines.USE_SIZE3},set:function(t){t===this.defines.USE_SIZE3&&(this.defines.USE_SIZE3=!!t),this.needsUpdate=!0}},opacity:{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}}})},Sw=s=>{Object.defineProperties(s,{animationRotate:{get:function(){return!!this.defines.ENABLE_ANIMATION_ROTATE},set:function(t){t!==this.animationRotate&&(t?this.defines.ENABLE_ANIMATION_ROTATE=!0:delete this.defines.ENABLE_ANIMATION_ROTATE,this.needsUpdate=!0)}},animationRotatePeriod:{get:function(){return this.uniforms.animationRotatePeriod.value},set:function(t){this.uniforms.animationRotatePeriod.value=t}},animationJump:{get:function(){return!!this.defines.ENABLE_ANIMATION_JUMP},set:function(t){t!==this.animationJump&&(t?this.defines.ENABLE_ANIMATION_JUMP=!0:delete this.defines.ENABLE_ANIMATION_JUMP,this.needsUpdate=!0)}},animationJumpPeriod:{get:function(){return this.uniforms.animationJumpPeriod.value},set:function(t){this.uniforms.animationJumpPeriod.value=t}},animationJumpHeight:{get:function(){return this.uniforms.animationJumpHeight.value},set:function(t){this.uniforms.animationJumpHeight.value=t}},animationPeriodOffset:{get:function(){return this.uniforms.animationPeriodOffset.value},set:function(t){this.uniforms.animationPeriodOffset.value=t}},animationEffect:{get:function(){return this.uniforms.animationEffect.value},set:function(t){this.uniforms.animationEffect.value=t}},animationEffectPeriod:{get:function(){return this.uniforms.animationEffectPeriod.value},set:function(t){this.uniforms.animationEffectPeriod.value=t}}})},Tw=pt.merge([ot.fog,{height:{value:0},size:{value:1},size3:{value:[1,1,1]},resolution:{value:[1,1]},zoomUnits:{value:1},color:{value:[1,0,0,1]},opacity:{value:1}},{animationRotatePeriod:{value:4e3},animationJumpPeriod:{value:4e3},animationJumpHeight:{value:30},animationPeriodOffset:{value:!1},animationEffect:{value:!0},animationEffectPeriod:{value:4e3}},ki,Ic,{isCesium:{value:!1}}]);class sn extends Be{constructor(t){super(),this.type="InstancedEffectPointMaterial",this.isInstancedEffectPointMaterial=!0,this.lights=!1,this.transparent=!0,Object.assign(this.uniforms,pt.clone(Tw)),ww(this),Sw(this),ns(this),Oc(this),this.setValues(t)}}const Cw=pt.merge([ot.fog,ki,{isEmissive:{value:!1},elapsedTime:{value:0}}]);class Ew extends sn{constructor(t){super(t),d(this,"type","SpecialPointMaterial"),d(this,"isSpecialPointMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

varying vec2 vPosition;
varying float vEffectRatio;
varying vec2 vUV;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {
    vUV = uv;
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);
 
    #include <mvt_animation_vertex>

    transformed *= size;
  
    #include <mvt_keepsize_vertex>

    // gl_Position = projectionMatrix * modelViewMatrix * 
    //     vec4(instancedPosition + transformed, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
}`,this.fragmentShader=`#define GLSLIFY 1
#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))
#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )
#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )
#define M_PI 3.1415926535897932384626433832795

#define blue1 vec3(0.74,0.95,1.00)
#define blue2 vec3(0.87,0.98,1.00)
#define blue3 vec3(0.35,0.76,0.83)
#define blue4 vec3(0.953,0.969,0.89)
#define red   vec3(1.00,0.38,0.227)

#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))

uniform float ratio;

float PI = 3.1415926;
uniform float elapsedTime;
uniform vec2 resolution; 
varying vec2 vPosition;
varying vec2 vUV;

float movingLine(vec2 uv, vec2 center, float radius)
{
    //angle of the line
    float theta0 = 90.0 * elapsedTime / 1000.;
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if(r<radius)
    {
        //compute the distance to the line theta=theta0
        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),
                            -sin(theta0*M_PI/180.0));
        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );
        d = normalize(d);
        //compute gradient based on angle difference to theta0
        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);
        float gradient = clamp(1.0-theta/90.0,0.0,1.0);
        return SMOOTH(l,1.0)+0.5*gradient;
    }
    else return 0.0;
}

float circle(vec2 uv, vec2 center, float radius, float width)
{
    float r = length(uv - center);
    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
}

float circle2(vec2 uv, vec2 center, float radius, float width, float opening)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    if( abs(d.y) > opening )
        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
    else
        return 0.0;
}
float circle3(vec2 uv, vec2 center, float radius, float width)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    float theta = 180.0*(atan(d.y,d.x)/M_PI);
    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *
        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *
        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));
}

float triangles(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))
        + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))
        + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))
        + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));
}

float _cross(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    int x = int(d.x);
    int y = int(d.y);
    float r = sqrt( dot( d, d ) );
    if( (r<radius) && ( (x==y) || (x==-y) ) )
        return 1.0;
    else return 0.0;
}
float dots(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if( r <= 2.5 )
        return 1.0;
    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )
        return 1.0;
    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )
        return 0.5;
    else
        return 0.0;
}
float bip1(vec2 uv, vec2 center)
{
    return SMOOTH(length(uv - center),3.0);
}
float bip2(vec2 uv, vec2 center)
{
    float r = length(uv - center);
    float R = 8.0+mod(87.0*elapsedTime / 1000., 80.0);
    return (0.5-0.5*cos(30.0*elapsedTime / 1000.)) * SMOOTH(r,5.0)
        + SMOOTH(6.0,r)-SMOOTH(8.0,r)
        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);
}
void main() { 
    vec2 _uv = vec2(vPosition.x * resolution.x, vPosition.y * resolution.y);
    vec3 finalColor;
    vec2 uv = _uv;
    //center of the image
    vec2 c = vec2(vUV.x / 2.0, vUV.y / 2.0);
    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );
    finalColor += ( circle(uv, c, 100.0, 1.0)
                + circle(uv, c, 165.0, 1.0) ) * blue1;
    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;
    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;
    finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime / 1000.)) * blue2;
    finalColor += movingLine(uv, c, 240.0) * blue3;
    finalColor += circle(uv, c, 10.0, 1.0) * blue3;
    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime / 1000.)) * blue3;
    if( length(uv-c) < 240.0 )
    {
        //animate some bips with random movements
        vec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*elapsedTime / 1000.);
        finalColor += bip1(uv, c+p) * vec3(1,1,1);
        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*elapsedTime / 1000.)+0.15*elapsedTime / 1000.);
        finalColor += bip1(uv, c+p) * vec3(1,1,1);
        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*elapsedTime / 1000.+7.0)+0.2*elapsedTime / 1000.);
        // finalColor += bip2(uv,c+p) * red;
    }

    gl_FragColor = vec4( finalColor, 1.0 );
    // gl_FragColor.a *= finalColor.r;
    
}`,this.transparent=!0,this.side=2,this.depthWrite=!1,Object.assign(this.uniforms,pt.clone(Cw)),jt(this,["isEmissive","elapsedTime"]),this.setValues(t)}}const y_=`#define GLSLIFY 1
#include <common>

varying vec2 vUV;
uniform float size;
varying vec2 vPosition;

#include <logdepthbuf_pars_vertex>
void main() { 
    vUV = uv;
    vec3 transformed = vec3(position);
    vPosition = position.xy;

    transformed *= size;
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( transformed, 1.0 );
    #include <logdepthbuf_vertex>
}`;let co=pt.merge([{speed:{value:1},color:{value:[1,0,0,1]},size:{value:100},isEmissive:{value:!1}}]);class Aw extends sn{constructor(t){super(t),d(this,"type","InstancedFanMaterial"),d(this,"isInstancedFanMaterial",!0),this.depthWrite=!1,jt(this,["speed","isEmissive"]),t.type==="Fan"?(this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform float speed;
uniform bool animationEffect;
uniform float animationEffectPeriod;

varying vec2 vPosition;
varying float vEffectRatio;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {
   
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);
 
    float elapsedTime = elapsedTime * speed * .5;
    #include <mvt_animation_vertex>

    transformed *= size;
  
    #include <mvt_keepsize_vertex>

    // gl_Position = projectionMatrix * modelViewMatrix * 
    //     vec4(instancedPosition + transformed, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
// #include <common>

uniform vec4 color;
uniform float opacity;
uniform bool animationEffect;

varying float vEffectRatio;
varying vec2 vPosition;

// #include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
   
    float bb = atan(vPosition.y, vPosition.x) + 3.15;

    float pi = 3.14 * 1.;
    // bb = mod(bb, 6.28);
    if (bb > pi) {
        discard;
    } else { 
        float aa = mod(bb / pi, 1.0);
        float dis = distance(vPosition, vec2(0, 0));
        if (dis > 0.5) {
            discard;
        } else {
            gl_FragColor = color;
            gl_FragColor.a *= aa;
        }
    }
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    
    // #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
}`):t.type==="Radar"?(co=pt.merge([co,{segmentAngle:{value:.25*Math.PI}}]),jt(this,["segmentAngle"]),this.vertexShader=`#include <common>
precision mediump float;
precision mediump int;
#define GLSLIFY 1
#include <mvt_animation_pars_vertex>
varying vec2 vPosition;
uniform float elapsedTime;
uniform float speed;
attribute float instancedRandomFactor;
uniform float size;

#include <logdepthbuf_pars_vertex>
void main() {   
    vec3 transformed = vec3(position);
    float elapsedTime = elapsedTime * speed * .5;
    #include <mvt_animation_vertex>
    transformed *= size;
    vPosition = position.xy;
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( transformed, 1.0 );
    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
uniform float segmentAngle;
uniform vec4 color;
varying vec2 vPosition;

#define PI 3.1415926
#define radius .5
#include <logdepthbuf_pars_fragment>

float cros(vec2 line1, vec2 line2){
    return line1.x * line2.y - line2.x * line1.y;
}

void main() {
    bool crossNPI = false;
    float wholeAng = abs(mod(segmentAngle , PI * 2.));
    float dis = length(vec2(vPosition.xy - vec2(0.0)));

    // if(wholeAng < -1.0*PI){
    //     crossNPI = true;
    //     wholeAng = 2.0*PI + endAng-startAng;
    // }
    if (dis<radius) {
        vec2 nV = normalize(vPosition.xy);
        float angle = 0.0;
        if(nV.x > 0.0 && abs(nV.y) < 0.01) {
            angle = 0.5*PI;
        }
        else if (nV.x<0.0 && abs(nV.y) < 0.01) {
            angle = -0.5*PI;
        }
        else {
            angle = atan(nV.x,nV.y);
        }

        if (angle<.0) {
            angle = 2. * PI + angle;
        }

        float alpha = 0.1;

        if (angle > 0. && angle < wholeAng) {
            // alpha = 1.1 - (endAng-angle)/wholeAng;
            alpha = 1.1 - (1. - (wholeAng-angle) / wholeAng);
        }
        
        gl_FragColor = color;
        gl_FragColor.a = alpha;
    }
    else {
        discard;
    }
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <logdepthbuf_fragment>
}`):t.type==="RadarLayered"?(co=pt.merge([co,{sideColor:{value:[.87,.98,1,1]}}]),Bs(this,["sideColor"]),this.vertexShader=y_,this.fragmentShader=`#define GLSLIFY 1
#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))
#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )
#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )
#define M_PI 3.1415926535897932384626433832795

// #define blue1 vec4(0.74,0.95,1.00,1.)
// #define blue2 vec4(0.87,0.98,1.00,1.)
// #define blue3 vec4(0.35,0.76,0.83,1.)
// #define blue4 vec4(0.953,0.969,0.89,1.)
// #define red   vec4(1.00,0.38,0.227,1.)

#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))
// #define elapsedTime 0.01
uniform float elapsedTime;
uniform float speed;
varying vec2 vPosition;
uniform vec4 color;
uniform vec4 sideColor;
#include <logdepthbuf_pars_fragment>
float movingLine(vec2 uv, vec2 center, float radius)
{
    //angle of the line
    float theta0 = 90.0 * elapsedTime * speed *.0006;
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if(r<radius)
    {
        //compute the distance to the line theta=theta0
        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),
            -sin(theta0*M_PI/180.0));
        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) )* 500.;
        d = normalize(d);
        //compute gradient based on angle difference to theta0
        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);
        float gradient = clamp(1.0-theta/90.0,0.3,1.0);
        return SMOOTH(l,1.0)+0.5*gradient;
    }
    else return 0.0;
}
    
    float circle(vec2 uv, vec2 center, float radius, float width)
{
    float r = length(uv - center);
    return smoothstep(radius-width,radius,r)-smoothstep(radius,radius+width,r);
    // return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
}

float circle2(vec2 uv, vec2 center, float radius, float width, float opening)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    if( abs(d.y) > opening )
        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
    else
        return 0.0;
}
float circle3(vec2 uv, vec2 center, float radius, float width)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    float theta = 180.0*(atan(d.y,d.x)/M_PI);
    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *
        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *
        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));
}
    
float triangles(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))
         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))
         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))
         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));
}
    
float _cross(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    int x = int(d.x * 100.);
    int y = int(d.y * 100.);
    float r = sqrt( dot( d, d ) );
    if( (r<radius) && ( (x==y) || (x==-y) ) )
        return 1.0;
    else return 0.0;
}

void main() {
    vec4 finalColor = vec4(0.0, .0, .0, .0);
    vec2 uv = vPosition.xy;
    #include <logdepthbuf_fragment>
    //center of the image
    vec2 c = vec2(0.0, 0.0);
    finalColor += 0.3*_cross( vPosition.xy, c, .5);
    finalColor += ( circle(uv, c, .3, .01)
                  + circle(uv, c, .4, .01) ) * color;
    finalColor += (circle(uv, c, .5, .02) ) * sideColor;//+ dots(uv,c,240.0)) * blue4;
    // finalColor += circle3(uv, c, 313.0, 4.0) * blue1;
    // finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime * speed *.0006)) * blue2;
    finalColor += movingLine(uv, c, .5) * color;
    finalColor += circle(uv, c, .05, .01) * color;
    // finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime * speed *.0006)) * blue3;
    if( length(uv-c) < .5 ) {
        if( length(finalColor)<0.2) {
            discard;
        }
    }
    else{
        discard;
    }
    if (finalColor.a <= 0.) {
        discard;
    }
    gl_FragColor = finalColor;
    #include <tonemapping_fragment>
    #include <encodings_fragment>
}`):(this.vertexShader=y_,this.fragmentShader=`#define GLSLIFY 1
#include <common>

varying vec2 vUV;
uniform vec4 color;
uniform float speed;
uniform float elapsedTime;

vec3 RadarPing(in vec2 uv, in vec2 center, in float innerTail, 
    in float frontierBorder, in float timeResetSeconds, 
    in float radarPingSpeed, in float fadeDistance, float t) {
    vec2 diff = center-uv;
    float r = length(diff);
    float time = mod(t, timeResetSeconds) * radarPingSpeed;
    
    float circle;
    circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);
    circle *= smoothstep(fadeDistance, 0.25, r); // fade to 0 after fadeDistance
            
    return vec3(circle);
}
#include <logdepthbuf_pars_fragment>
void main() {
    // gl_FragColor = vec4(1.,.0,.0,1.);
    //normalize coordinates 
    vec2 uv = vUV; //move coordinates to 0..1
    uv = uv.xy*2.; // translate to the center
    uv += vec2(-1.0, -1.0);
    #include <logdepthbuf_fragment>
    vec3 color1;
    // generate some radar pings
    float fadeDistance = 0.8;
    float resetTimeSec = 3.0;
    float radarPingSpeed = 0.2;
    vec2 greenPing = vec2(0.0, 0.0);
    color1 += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,
        radarPingSpeed, fadeDistance, elapsedTime * speed * .0006) * vec3(color.rgb);
    // color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,
    //    radarPingSpeed, fadeDistance, elapsedTime * speed * .0006 + 1.) * uColor;
    color1 += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,
        radarPingSpeed, fadeDistance, elapsedTime * speed * .0006 + 2.) * vec3(color.rgb);
    //return the new color
    if(length(color1)<0.001){
        discard;
    }else{
        gl_FragColor = vec4(color1,clamp(length(color1),0.0,1.0));
    }
    #include <tonemapping_fragment>
    #include <encodings_fragment>
}`),Object.assign(this.uniforms,pt.clone(co)),this.setValues(t)}}const b_=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

varying vec2 vPosition;
varying float vEffectRatio;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>
void main() {
   
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);
 
    #include <mvt_animation_vertex>

    transformed *= size;
  
    #include <mvt_keepsize_vertex>
    
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #include <logdepthbuf_vertex>
}`,Pw=pt.merge([{color:{value:[1,1,0,1]},size:{value:10},duration:{value:2e3},trail:{value:.5},center:{value:.1},radius:{value:.5},radiusDiff:{value:.08},isEmissive:{value:!1}}]);class Rw extends sn{constructor(t){super(t),d(this,"type","InstancedBubbleMaterial"),d(this,"isInstancedBubbleMaterial",!0),this.depthTest=!1,this.depthWrite=!1,t.type=="Breath"?(this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

varying vec2 vPosition;
varying float vEffectRatio;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>
void main() {
   
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);
 
    #include <mvt_animation_vertex>

    transformed *= size;
  
    #include <mvt_keepsize_vertex>

    if (animationEffect) {
        vEffectRatio = mod(elapsedTime, animationEffectPeriod) / animationEffectPeriod;
        if (animationPeriodOffset) {
            vEffectRatio += instancedRandomFactor;
        }
        vEffectRatio = mod(vEffectRatio, 1.0);
        transformed *= vEffectRatio;
    } else {
        vEffectRatio = 1.0;
    }
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform float opacity;
uniform bool animationEffect;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }

    gl_FragColor = color;
    
    gl_FragColor.a *= opacity;
    if (animationEffect) {
        if (vEffectRatio > 0.7) {
            gl_FragColor.a *= (1.0 - vEffectRatio) / 0.3;
        }
    }

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}`):t.type=="Wave"?(this.vertexShader=b_,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform float opacity;
uniform bool animationEffect;
uniform float elapsedTime;
uniform float duration;
uniform float trail;
uniform float radiusDiff;
uniform float center;
uniform float radius;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > radius) {
        discard;
    }
    vec4 vColor = color;
    
    float alpha = sin((radiusDiff - d) / radiusDiff * trail * 2.0  * 3.14 + elapsedTime / duration * 10.);
    // 中心点
    if (d <= center){
      if (d > 0.9 * center && d <= center) {
        if (alpha >= 0.5) {
          vColor.a = 1.0;
        } else {
          vColor.a = 1.0 - smoothstep(center - 0.0001, center, d);
        }
      }
    }
    else {
      if (alpha >= 0.6) {
        vColor.a = 1.0 - d / radius;
        if (alpha >= 0.5 && alpha <= 0.6) {
            vColor.a *= smoothstep(0.0, 0.1, alpha - 0.5);
        }
        
        if (d >= 0.8 * radiusDiff && d <= radiusDiff) {
            vColor.a *= 1.0 - smoothstep(0.9, 1.0, d / radiusDiff);
        }
        
      }
      else {
        vColor.a = 0.0;
      }
    }
    gl_FragColor = vColor;
    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
	  #include <encodings_fragment>
    
}`):(this.vertexShader=b_,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform float opacity;
uniform bool animationEffect;
uniform float elapsedTime;
uniform float duration;
uniform float trail;
uniform float center;
uniform float radius;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }
    vec4 vColor = color;
    float range = mod(elapsedTime, (duration + trail));
    float percent = 0.0;
    if (range <= duration) {
      percent = range / duration * 2.0;
    } else {
      percent = 1.0;
    }
    float r = radius * percent;
    
    // 中心点
    if (d <= center){
      if(d > 0.99 * center && d <= center) {
        vColor.a = 1.0 - smoothstep(0.99 * center, center, d);
      }
    }
    else {
      if (d < r) {
        vColor.a = smoothstep(0.1, 0.9, pow(d / r, 2.0) * 0.9);
        // 边缘抗锯齿
        if (d >= 0.99 * r && d <= r) {
          vColor.a *= 1.0 - smoothstep(0.99, 1.0, d / r);
        }
        // 拖尾渐隐
        if (range > duration) {
          vColor.a *= 1.0 - (range - duration) / trail;
        }
      }
      else {
        vColor.a = 0.0;
      }
      
    }
    gl_FragColor = vColor;
    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
	  #include <encodings_fragment>
    
}`),Object.assign(this.uniforms,pt.clone(Pw)),jt(this,["duration","trail","isEmissive"]),this.setValues(t)}}const uo=new M;new rt;const M_=new rt;new rt;class Dw extends rh{constructor(t){super(t),d(this,"_shapeType","cube"),d(this,"fillNoLine",(e,i,n,r,a)=>{for(let o=0,l=e.length;o<l-2;o+=3)n.push(e[o],e[o+1],e[o+2]),i.push(0),r.push(0),a.push(0)}),d(this,"generateLines",(e,i,n,r,a,o,l)=>{const h=i.length/3;let c,u,p,m,f,g,_,v;for(let x=0,y=e.length;x<y;++x){_=3*e[x][0],v=3*e[x][1],c=i[_],u=i[_+1],p=i[_+2],m=i[v],f=i[v+1],g=i[v+2],i.push(c,u,p,c,u,p,m,f,g,m,f,g),n.push(1,1,1,1),r.push(m,f,g,m,f,g,c,u,p,c,u,p),a.push(1,1,0,0),o.push(1,-1,1,-1);const b=h+4*x;l.push(b,b+1,b+2,b+2,b+1,b+3)}}),d(this,"applyTransformToPositions",(e,i)=>{const n=[];for(let r=0,a=e.length;r<a-2;r+=3)uo.set(e[r],e[r+1],e[r+2]),uo.applyMatrix4(i),n.push(uo.x,uo.y,uo.z);return n}),this.parameters=t,this.shapeType=this.parameters.shapeType}get shapeType(){return this._shapeType}set shapeType(t){this._shapeType=t,this.geometry&&this.geometry.dispose();let e=null,i=null,n=null,r=[],a=[],o=[],l=[];if(t==="cube"){e=new oe(1,1,1),i=Array.from(e.attributes.position.array),n=Array.from(e.index.array),M_.identity().makeTranslation(0,0,.5),i=this.applyTransformToPositions(i,M_),this.fillNoLine(i,r,a,o,l);const h=[];for(let c=0;c<24;c+=4)h.push([c,c+1],[c+3,c+2],[c+2,c]);this.generateLines(h,i,r,a,o,l,n)}else if(t==="octahedron"){i=[0,0,1,-.5,-.5,.5,-.5,.5,.5,.5,.5,.5,.5,-.5,.5,0,0,0],n=[0,1,4,0,4,3,0,3,2,0,2,1,1,5,4,4,5,3,3,5,2,2,5,1],this.fillNoLine(i,r,a,o,l);const h=[[0,1],[0,2],[0,3],[0,4],[1,4],[4,3],[3,2],[2,1],[1,5],[2,5],[3,5],[4,5]];this.generateLines(h,i,r,a,o,l,n)}else if(t==="pyramid"){i=[-.5,-.5,1,-.5,.5,1,.5,.5,1,.5,-.5,1,0,0,0,-.25,-.25,.5,-.25,.25,.5,.25,.25,.5,.25,-.25,.5],n=[0,2,1,0,3,2,1,0,4,0,3,4,3,2,4,2,1,4],this.fillNoLine(i,r,a,o,l);const h=[[0,1],[1,2],[2,3],[3,0],[0,4],[1,4],[2,4],[3,4],[6,5],[5,8],[8,7],[7,6]];this.generateLines(h,i,r,a,o,l,n)}e&&e.dispose(),i&&(this.setAttribute("position",new et(new Float32Array(i),3)),this.setAttribute("isLine",new et(new Float32Array(r),1)),this.setAttribute("adjacentPoint",new et(new Float32Array(a),3)),this.setAttribute("isLineStart",new et(new Float32Array(o),1)),this.setAttribute("lineSide",new et(new Float32Array(l),1)),this.setIndex(n),this.computeBoundingSphere(),console.log(this.boundingSphere))}dispose(){}}const Lw=pt.merge([{lineWidth:{value:2},lineColor:{value:[1,1,0,1]},isCesium:{value:!1},isEmissive:{value:!1}}]);class Iw extends sn{constructor(t){super(),this.type="InstancedShapeMaterial",this.isInstancedShapeMaterial=!0,this.isUseSize3=!0,this.side=ce,this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;
attribute float isLine;
attribute float isLineStart;
attribute float lineSide;
attribute vec3 adjacentPoint;
// attribute mat4 instanceMatrix;

uniform bool isCesium;

uniform float height;
uniform vec3 size3;
uniform float time;
uniform float lineWidth;
varying float vIsLine;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

#define MVT_KEEP_PROJECTION_POSITION

vec3 transformPosition(vec3 p) {
    vec3 transformed = vec3(p);

    #include <mvt_animation_vertex>

    transformed *= size3;
    transformed.z += height;

    #include <mvt_keepsize_vertex>

    return transformed;
}
void main() {
    
    #include <mvt_selective_vertex>
    vec4 mvp_projectPosition;
    if (isLine == 1.0) {
        vIsLine = 1.0;
        mat4 m = projectionMatrix * modelViewMatrix * instanceMatrix;
        vec4 p1 = m * vec4(transformPosition(position), 1.0);
        vec4 p2 = m * vec4(transformPosition(adjacentPoint), 1.0);
        mvp_projectPosition = vec4(p1);
        p1 /= p1.w;
        p2 /= p2.w;
        vec2 dir;
        if (isLineStart == 1.0) {
            dir = normalize(p2.xy - p1.xy);
        } else {
            dir = normalize(p1.xy - p2.xy);
        }
        vec2 _normal = vec2(-dir.y, dir.x);
        // multiply by 2 and then divide by 2
        vec2 offset = _normal * lineSide / resolution * lineWidth;
        gl_Position = p1;
        gl_Position.xy += offset;
    } else {
        vIsLine = 0.0;
        vec3 transformed = transformPosition(position);
        // mat4 tm = mat4(
        //     1,0,0,0,
        //     0,1,0,0,
        //     0,0,1,0,
        //     instanceMatrix[3][0],4826138.4,0,1
        // );
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix *
            vec4(transformed, 1.0);
        // gl_Position = projectionMatrix * viewMatrix *
        //     vec4(transformed.x + 12957564.9, transformed.y + 4826138.4, transformed.z + 0.0, 1.0);
        // vTest.x = instanceMatrix[1][1];
        //  gl_Position = projectionMatrix * viewMatrix * 
        //     vec4(instancedPosition + transformed, 1.0);
        mvp_projectPosition = gl_Position;
    }
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform vec4 lineColor;
uniform float opacity;

varying float vIsLine;

#include <mvt_selective_pars_fragment>

void main() {
    if (vIsLine == 1.0) {
        gl_FragColor = lineColor;
    }
    else {
        gl_FragColor = color;
        // test
        // gl_FragColor.r = vTest.x;
        // gl_FragColor.g = vTest.y;
        // gl_FragColor.b = vTest.z;
        // gl_FragColor.a = 1.0;
        // test end
    }
    gl_FragColor.a *= opacity;
    #include <mvt_selective_fragment>
}`,Object.assign(this.uniforms,pt.clone(Lw)),jt(this,["isEmissive","lineWidth"]),Bs(this,["lineColor"]),this.setValues(t)}}class Ow extends Pt{constructor(t){super(t),this.parameters=t}setData(t){const{vertexSizes:e,vertexColors:i,vertexOffsets:n}=this.parameters,{aPositions:r,aObjectIndices:a,aMapIndexs:o,aColors:l,aSizes:h,aOffsets:c}=t;this.setAttribute("position",new et(r,3)),this.setAttribute("objectIndex",new et(a,1)),this.setAttribute("aMapIndex",new et(o,1)),i&&this.setAttribute("aColor",new et(l,4)),e&&this.setAttribute("aSize",new et(h,1)),n&&this.setAttribute("aOffset",new et(c,2))}}const zw=new Ie,kw=pt.merge([ot.fog,ki,{emissive:{value:[0,0,0]},isEmissive:{value:!1},color:{value:[0,1,1,1]},size:{value:30},uOffset:{value:[0,0]},ulength:{value:0},useCanvasMap:{value:!1},vertexColors:{value:!1},vertexSizes:{value:!1},vertexOffsets:{value:!1},uShapeType:{value:2},opacity:{value:1},map:{value:null},useMap:{value:!1}}]);class Nw extends Be{constructor(t){super(),this.type="IconPointMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float size;
uniform float pixelRatio;
uniform vec2 resolution;

#ifdef MVT_USE_VERTEX_SIZE
    attribute float aSize;
    varying float vSize;
#endif

#ifdef MVT_USE_VERTEX_OFFSET
    attribute vec2 aOffset;
#else
    uniform vec2 uOffset;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
    varying vec4 vColor;
#endif

#ifdef MVT_USE_VERTEX_ICON
    attribute float aMapIndex;
    varying float vMapIndex;
#endif

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 
    #include <mvt_selective_vertex>

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);

    #ifdef MVT_USE_VERTEX_OFFSET
        vec2 offset = aOffset * 2. * pixelRatio * pixelSize;
    #else
        vec2 offset = uOffset * 2. * pixelRatio * pixelSize;
    #endif
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.xy = gl_Position.xy - offset;

    #ifdef MVT_USE_VERTEX_SIZE
        vSize = aSize * pixelRatio;
        gl_PointSize = vSize;
    #else
        gl_PointSize = size * pixelRatio;
    #endif

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #endif

    #ifdef MVT_USE_VERTEX_ICON
        vMapIndex = aMapIndex;
    #endif

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif
uniform vec4 color;
uniform float uShapeType;
uniform float opacity;

#ifdef MVT_USE_VERTEX_SIZE
    varying float vSize;
#else
    uniform float size;
#endif

#ifdef MVT_USE_VERTEX_ICON
    varying float vMapIndex;
    uniform float ulength;
#endif
uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = color;
    #endif

    if (uShapeType == 2.) {
        float d = distance(gl_PointCoord, vec2(0.5, 0.5));
        #ifdef MVT_USE_VERTEX_SIZE
            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);
        #else
            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);
        #endif
        
        if (alpha <= 0.) {
            discard;
        } else {
            gl_FragColor.a *= alpha;
        }
    }
 
    if (useMap) {
        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);
     //    gl_FragColor.a += tColor.a;
        
        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);
        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);
        // gl_FragColor.a += tColor.a;
        // gl_FragColor = tColor;
    }

    #ifdef MVT_USE_VERTEX_ICON
    if(useCanvasMap) {
        vec4 tColor = texture2D(map, vec2(vMapIndex / ulength + 1.0 / ulength * gl_PointCoord.x, 1.0 - gl_PointCoord.y));
        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);
    }
    #endif
    
    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
}`,this.isIconPointMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,pt.clone(kw)),ns(this),jt(this,["size","uShapeType","opacity","emissive","isEmissive"]),Bs(this,["color"]),_i(this,[["offset","uOffset"]]),Qe(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexSizes","MVT_USE_VERTEX_SIZE"],["vertexIcons","MVT_USE_VERTEX_ICON"],["vertexOffsets","MVT_USE_VERTEX_OFFSET"]]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,n=this.userData[this.urlCacheKey],r=this;if(n!==e){if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[this.urlCacheKey];zw.load(e,function(a){a.wrapS=a.wrapT=ue,r.uniforms.map.value=a,r.userData[r.urlCacheKey]=e,r.uniforms.useMap.value=!0,r.uniforms.useCanvasMap.value=!1})}}},mapTexture:{get:function(){return this.uniforms.map.value},set:function(e){if(!e)return this.uniforms.map.value=null,void(this.uniforms.useCanvasMap.value=!1);e.wrapS=e.wrapT=ue,this.uniforms.map.value=e,this.uniforms.useMap.value=!1,this.uniforms.useCanvasMap.value=!0,delete this.userData[this.urlCacheKey]}}}),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class po extends __{constructor(t){super(t),d(this,"canvas"),d(this,"ctx"),d(this,"oldMapTextureRes"),d(this,"geometry"),d(this,"material"),d(this,"color"),d(this,"vertexColors"),d(this,"size"),d(this,"vertexSizes"),d(this,"mapSrc"),d(this,"vertexIcons"),d(this,"opacity"),d(this,"getTextureAndHash",(e,i,n,r)=>{const a=new Map;if(!r&&this.oldMapTextureRes)return this.oldMapTextureRes;if(!e[0]||!e[0][i])return{texture:this.texture,iconUrlHash:a};const o=this;let l=0;for(let h=0;h<e.length;h++){const c=e[h][i];a.get(c)===void 0&&(a.set(c,l),l++)}return this.canvas.width=a.size*n,this.canvas.height=n,this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),Array.from(a).forEach((h,c)=>{let u=new Image;u.setAttribute("crossOrigin","Anonymous"),u.onload=function(){o.ctx.drawImage(u,c*n,0,n,n),o.texture.needsUpdate=!0},u.src=h[0]}),this.texture.dispose(),this.texture=new Le(this.canvas),this.oldMapTextureRes={texture:this.texture,iconUrlHash:a},{texture:this.texture,iconUrlHash:a}}),this.parameters=t,this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),this.texture=new Le(this.canvas),this.defineMaterialProxyProperties(["color","size","offset","uShapeType","opacity","vertexColors","vertexSizes","vertexOffsets","vertexIcons","mapSrc","mapTexture"])}initObject(){this.geometry=new Ow(this.parameters),this.material=new Nw(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}collisionTest(t){let e=0;return e=this.parameters.vertexSizes&&t.size?t.size:this.size,{width:e,height:e}}setData(){const t=this.dataSource.data,{vertexIcons:e,vertexColors:i,vertexSizes:n,vertexOffsets:r,inconPropName:a="icon",size:o=30}=this.parameters;let l=[];l=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData;const h=[],c=[];let u="",p={};const m=[],f=[],g=[],_=[];if(e){const v=this.getTextureAndHash(l,a,o,!0);u=v.texture,p=v.iconUrlHash,this.material.mapTexture=u,this.material.uniforms.ulength.value=p.size}for(let v=0;v<l.length;v++){const x=l[v].position,y=l[v].position,b=t.color?l[v].color:this.parameters.color,S=t.size?l[v].size:this.parameters.size,w=t.offset?l[v].offset:this.parameters.offset;if(h.push(...x),c.push(y),e&&m.push(p.get(l[v][a])),i){let C=es(b);f.push(...C.toArray())}n&&g.push(S),r&&_.push(w)}this.geometry.setData({aPositions:h,aObjectIndices:c,aMapIndexs:m,aColors:f,aSizes:g,aOffsets:_}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,h),this.needsUpdate=!1}onDispose(){this.texture&&this.texture.dispose()}}const Uw=new Ie,Fw=pt.merge([ot.fog,ki,Ic,{emissive:{value:[0,0,0]},isEmissive:{value:!1},width:{value:12},height:{value:12},offset:{value:[0,0]},ulength:{value:1},useCanvasMap:{value:!1},vertexIcons:{value:!1},opacity:{value:1},map:{value:null},useMap:{value:!1},uScale:{value:1},uFlat:{value:!1},keepSize:{value:!0}}]);class Bw extends Be{constructor(t){super(),this.type="IconMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute float pIndex;
attribute float aMapIndex;

uniform float pixelRatio;
uniform float width;
uniform float height;
uniform float uScale;
uniform float ulength;
uniform vec2 resolution;
uniform vec2 offset;
uniform bool uFlat;
uniform bool keepSize;

varying vec2 vUv;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 
    #include <mvt_selective_vertex>

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);
    if (uFlat) {
        float hw = width * 0.5;
        float hh = height * 0.5;
        if (keepSize) {
            hw *= pixelSize;
            hh *= pixelSize;
        }
        if (pIndex == 1.0) {
            hw = -hw;
        } else if (pIndex == 2.0) {
            
        } else if (pIndex == 3.0) {
            hh = -hh;
        } else {
            hw = -hw;
            hh = -hh;
        }
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        float w = gl_Position.w;
        gl_Position /= w;

        float hw = width / resolution.x * uScale;
        float hh = height / resolution.y * uScale;
        vec2 o = offset;
        if (!keepSize) {
            hw /= pixelSize;
            hh /= pixelSize;
            o /= pixelSize;
        }

        gl_Position.x += o.x * 2. / resolution.x;
        gl_Position.y -= o.y * 2. / resolution.y;

        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }

        gl_Position *= w;
    }

    vUv = uv;

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform float opacity;

uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;
uniform float width;
uniform float height;

varying vec2 vUv;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vec2(vUv.x, vUv.y));
    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);

    if (gl_FragColor.a <= 0.) {
        discard;
    }
    gl_FragColor.a *= opacity;

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
    #include <tonemapping_fragment>
	#include <encodings_fragment>
}`,this.isIconMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,pt.clone(Fw)),Oc(this),ns(this),jt(this,["width","height","offset","opacity","emissive","isEmissive"]),_i(this,[["scale","uScale"],["flat","uFlat"]]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,n=this.userData[this.urlCacheKey],r=this;if(n!==e){if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[this.urlCacheKey];Uw.load(e,function(a){a.wrapS=a.wrapT=ue,a.encoding=3001,r.uniforms.map.value=a,r.userData[r.urlCacheKey]=e,r.uniforms.useMap.value=!0,r.uniforms.useCanvasMap.value=!1})}}},mapTexture:{get:function(){return this.uniforms.map.value},set:function(e){if(!e)return this.uniforms.map.value=null,void(this.uniforms.useCanvasMap.value=!1);e.wrapS=e.wrapT=ue,e.encoding=3001,this.uniforms.map.value=e,this.uniforms.useMap.value=!1,this.uniforms.useCanvasMap.value=!0,delete this.userData[this.urlCacheKey]}}}),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class Vw extends Pt{constructor(t){super(t),this.parameters=t}setData(t){const{aPositions:e,aObjectIndices:i,aUvs:n,pIndices:r,indices:a}=t;this.setAttribute("position",new et(e,3)),this.setAttribute("pIndex",new et(r,1)),this.setAttribute("objectIndex",new et(i,1)),this.setAttribute("uv",new et(n,2)),this.setIndex(a)}}const Vu=new M,rn=new Lt,oh=new rt;class w_ extends as{constructor(t){super(t),d(this,"isEventEntitySupported",!0),d(this,"_padding"),d(this,"oldMapTextureRes",new Map),d(this,"texture"),d(this,"geometry"),d(this,"material"),d(this,"canvas"),d(this,"ctx"),d(this,"iconUrlHash",new Map),d(this,"getTextureAndHash",(i,n,r,a,o)=>{const l=this,h=this.engine.rendering.pixelRatio,c=this.iconUrlHash;if(!o&&this.oldMapTextureRes)return this.oldMapTextureRes;if(!i[0]||!i[0][n])return{texture:this.texture,iconUrlHash:c};let u=c.size,p=c.size,m=new Map;for(let x=0;x<i.length;x++){const y=i[x][n];c.get(y)===void 0&&(c.set(y,u),m.set(y,u),u++)}if(p===c.size)return this.oldMapTextureRes;let f=this.canvas.toDataURL();const g=c.size*(r+this.padding[0]),_=a+this.padding[1];this.canvas.width=g*h,this.canvas.height=_*h,this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);let v=new Image;return v.setAttribute("crossOrigin","Anonymous"),v.onload=function(){l.ctx.save(),l.ctx.scale(h,h),l.ctx.drawImage(v,0,0,p*(r+l.padding[0]),a+l.padding[1]),l.ctx.restore(),l.texture.dispose(),l.texture=new Le(l.canvas),l.oldMapTextureRes={texture:l.texture,iconUrlHash:c},l.material.mapTexture=l.texture},v.src=f,Array.from(m).forEach((x,y)=>{let b=new Image;b.setAttribute("crossOrigin","Anonymous"),b.onload=function(){l.ctx.save(),l.ctx.scale(h,h),l.ctx.drawImage(b,0,0,b.width,b.height,x[1]*r+l.padding[0]*(x[1]+.5),l.padding[1]/2,r,a),l.ctx.restore(),l.texture.dispose(),l.texture=new Le(l.canvas),l.oldMapTextureRes={texture:l.texture,iconUrlHash:c},l.material.mapTexture=l.texture},b.src=x[0]}),this.texture.dispose(),this.texture=new Le(this.canvas),this.oldMapTextureRes={texture:this.texture,iconUrlHash:c},{texture:this.texture,iconUrlHash:c}}),this.parameters=t,this._padding=this.parameters.padding!==void 0?this.parameters.padding:[2,2];const e=this.canvas=document.createElement("canvas");e.width=e.height=1,this.ctx=e.getContext("2d"),this.texture=new Le(e),this.defineMaterialProxyProperties(["width","height","offset","map","opacity","flat","keepSize"])}initObject(){let{vertexIcons:t,...e}=this.parameters;this.geometry=new Vw(this.parameters),this.material=new Bw(e),this.material.setCommonUniforms(this.engine.rendering.uniforms)}getDefaultParams(){return{width:12,height:12}}collisionTest(t){return{width:this.width,height:this.height}}setData(){const{vertexIcons:t,inconPropName:e="icon",width:i,height:n}=this.parameters;let r=[];r=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData;const a=[],o=[],l=[],h=[],c=[];let u="",p={};if(t){const m=this.getTextureAndHash(r,e,i,n,!0);u=m.texture,p=m.iconUrlHash||{},this.material.mapTexture=u,this.material.uniforms.ulength.value=p.size;for(let f=0;f<r.length;f++){const g=r[f].position,_=r[f].index;for(let x=0;x<4;x++)a.push(...g),o.push(x),l.push(_);t?h.push(p.get(r[f][e])/p.size,0,p.get(r[f][e])/p.size,1,(p.get(r[f][e])+1)/p.size,1,(p.get(r[f][e])+1)/p.size,0):h.push(0,0,0,1,1,1,1,0);const v=4*f;c.push(v,v+2,v+1,v,v+3,v+2)}}else for(let m=0;m<r.length;m++){const f=r[m].position,g=r[m].index;for(let v=0;v<4;v++)a.push(...f),o.push(v),l.push(g);h.push(0,0,0,1,1,1,1,0);const _=4*m;c.push(_,_+2,_+1,_,_+3,_+2)}this.geometry.setData({aPositions:a,pIndices:o,aObjectIndices:l,aUvs:h,indices:c}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,a),this.needsUpdate=!1}getEntityByIndex(t){const e=this.dataSource,i={index:t,value:e.getOriginData(t),itemIndex:e.getOriginDataIndex(t),pairs:{}},n=e.data;for(const r of Object.keys(n))i.pairs[r]=n[r][t];return i}raycast(t,e){if(this.flat)return;const i=this.geometry,n=i.getAttribute("position");if(!n||!n.array||!n.array.length===0)return;const r=i.getAttribute("offset");let a=[];r&&(a=r.array);const o=t.camera,l=t.mouse,h=this.material.uniforms.resolution.value,c=l.x,u=l.y,p=this.width/h[0],m=this.height/h[0];let f=0,g=0,_=0,v=0,x=0,y=0;oh.multiplyMatrices(o.projectionMatrix,o.matrixWorldInverse),oh.multiplyMatrices(oh,this.matrixWorld);const b=n.array;let S=0;for(let w=0,C=b.length-11;w<C;w+=12)if(rn.set(b[w],b[w+1],b[w+2],1),rn.applyMatrix4(oh),rn.divideScalar(rn.w),this.parameters.vertexOffsets?(S=w/12*8,x=a[S]||0,y=a[S+1]||0):(x=this.parameters.offset&&this.parameters.offset[0]||0,y=this.parameters.offset&&this.parameters.offset[1]||0),rn.x+=2*x/h[0],rn.y-=2*y/h[1],f=rn.x-p,_=rn.x+p,g=rn.y-m,v=rn.y+m,f<=c&&_>=c&&g<=u&&v>=u){Vu.set(b[w],b[w+1],b[w+2]),Vu.applyMatrix4(this.matrixWorld);const L={instanceId:w/12,object:this,distance:Vu.distanceTo(o.position)};e.push(L)}}onDispose(){this.texture&&this.texture.dispose()}set padding(t){this._padding=t}get padding(){return this._padding}}const Ti=new Lt,ms=new rt,da=new j;class mo extends Sn{constructor(t){super(t),d(this,"isDomPoints",!0),d(this,"frustumCulled",!1),d(this,"onBeforeScenePrepareRenderHook",(e,i,n)=>{this.container=e.map.container;let r=e.renderer;const a=this.points,o=this.nodes;r.getSize(da),ms.multiplyMatrices(n.matrixWorldInverse,this.matrixWorld),ms.multiplyMatrices(n.projectionMatrix,ms);for(let l=0;l<a.length;l++){Ti.set(a[l][0],a[l][1],a[l][2],1),Ti.applyMatrix4(ms),Ti.divideScalar(Ti.w);const h=(Ti.x+1)/2*da.x,c=(1-Ti.y)/2*da.y;if(!o[l])return;o[l].style.left=h+this.offset[0]+"px",o[l].style.top=c+this.offset[1]+"px"}}),this.points=[],this.nodes=[],this.offset=[0,0],this.parameters=t}renderItem(t,e){const i=document.createElement("div");return i.style.position="absolute",i.style.width="60px",i.style.height="40px",i.style.background="#FFFFFF",i}setData(){const t=this.engine,e=t.camera,i=t.renderer,{offset:n}=this.parameters;for(let o=0;o<this.nodes.length;o++)this.nodes[o].remove();this.nodes=[],this.points=[];const r=this.dataSource;if(!r)return;r.needsUpdate&&r.update(),i.getSize(da),ms.multiplyMatrices(e.matrixWorldInverse,this.matrixWorld),ms.multiplyMatrices(e.projectionMatrix,ms);const a=r.data&&r.data.position||[];for(let o=0,l=r.size;o<l;o++){const h=a[o];this.points.push(h);const c=this.renderItem(r.getOriginData(o));Ti.set(h[0],h[1],h[2],1),Ti.applyMatrix4(ms),Ti.divideScalar(Ti.w);const u=(Ti.x+1)/2*da.x,p=(1-Ti.y)/2*da.y;xt(c,`${te}-dom-points`),c.style.left=u+n[0]+"px",c.style.top=p+n[1]+"px",this.nodes.push(c),this.container.appendChild(c)}this.offset=n,this.needsUpdate=!1,this.engine&&this.engine.requestRender()}onDispose(){this.nodes&&this.nodes.length&&this.nodes.forEach(t=>{t.remove()})}set visible(t){let e=t?"":"hidden";this.nodes&&this.nodes.length&&this.nodes.forEach(i=>{i.style.visibility=e})}get visible(){return!this.nodes||!this.nodes.length||this.nodes[0].style.visibility!=="hidden"}}const Hw=new Ie,jw=pt.merge([ot.fog,ki,Ic,{emissive:{value:[0,0,0]},isEmissive:{value:!1},width:{value:12},height:{value:12},offset:{value:[0,0]},ulength:{value:1},useCanvasMap:{value:!1},vertexIcons:{value:!1},opacity:{value:1},map:{value:null},useMap:{value:!1},uFlat:{value:!1},keepSize:{value:!0}}]);class Gw extends Be{constructor(t){super(),this.type="LabelMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute float pIndex;
attribute float aMapIndex;

uniform float pixelRatio;
uniform float width;
uniform float height;
uniform float ulength;
uniform vec2 resolution;
uniform vec2 offset;
uniform bool uFlat;
uniform bool keepSize;

varying vec2 vUv;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 
    #include <mvt_selective_vertex>

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);
    if (uFlat) {
        float hw = width * 0.5;
        float hh = height * 0.5;
        vec2 o = offset;
        if (keepSize) {
            hw *= pixelSize;
            hh *= pixelSize;
            o *= pixelSize;
        }
        if (pIndex == 1.0) {
            hw = -hw;
        } else if (pIndex == 2.0) {
            
        } else if (pIndex == 3.0) {
            hh = -hh;
        } else {
            hw = -hw;
            hh = -hh;
        }
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        float w = gl_Position.w;
        gl_Position /= w;

        float hw = width / resolution.x;
        float hh = height / resolution.y;
        vec2 o = offset;
        if (!keepSize) {
            hw /= pixelSize;
            hh /= pixelSize;
            o /= pixelSize;
        }

        gl_Position.x += o.x * 2. / resolution.x;
        gl_Position.y -= o.y * 2. / resolution.y;

        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }

        gl_Position *= w;
    }

    vUv = uv;

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform float opacity;

uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;
uniform float width;
uniform float height;

varying vec2 vUv;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));
    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);

    if (gl_FragColor.a <= 0.) {
        discard;
    }
    gl_FragColor.a *= opacity;

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
}`,this.isLabelMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,pt.clone(jw)),Oc(this),ns(this),_i(this,[["flat","uFlat"]]),jt(this,["width","height","offset","opacity","emissive","isEmissive"]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,n=this.userData[this.urlCacheKey],r=this;if(n!==e){if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[this.urlCacheKey];Hw.load(e,function(a){a.wrapS=a.wrapT=ue,a.encoding=3001,r.uniforms.map.value=a,r.userData[r.urlCacheKey]=e,r.uniforms.useMap.value=!0,r.uniforms.useCanvasMap.value=!1})}}},mapTexture:{get:function(){return this.uniforms.map.value},set:function(e){if(!e)return this.uniforms.map.value=null,void(this.uniforms.useCanvasMap.value=!1);e.wrapS=e.wrapT=ue,e.encoding=3001,this.uniforms.map.value=e,this.uniforms.useMap.value=!1,this.uniforms.useCanvasMap.value=!0,delete this.userData[this.urlCacheKey]}}}),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class Ww extends Pt{constructor(t){super(t),this.parameters=t}setData(t){const{aPositions:e,aObjectIndices:i,aUvs:n,pIndices:r,indices:a}=t;this.setAttribute("position",new et(e,3)),this.setAttribute("pIndex",new et(r,1)),this.setAttribute("objectIndex",new et(i,1)),this.setAttribute("uv",new et(n,2)),this.setIndex(a)}}const Hu=new M,an=new Lt,lh=new rt;class S_ extends as{constructor(t){super(t),d(this,"isEventEntitySupported",!0),d(this,"geometry"),d(this,"material"),d(this,"canvas"),d(this,"ctx"),d(this,"texture"),d(this,"iconUrlHash",new Map),d(this,"labelHash",new Map),d(this,"boxHash",new Map),d(this,"gap",[2,2]),d(this,"_padding"),d(this,"_fillStyle"),d(this,"oldMapTextureRes",{}),d(this,"getTextureAndHash",async(i,n,r,a,o)=>{const l=this.ctx,h=this.labelHash,c=this.iconUrlHash;if(!o&&this.oldMapTextureRes)return this.oldMapTextureRes;if(!i[0]||!i[0][a])return{texture:this.texture,labelHash:h};let u=h.size,p=h.size,m=new Map;for(let g=0;g<i.length;g++){const _=this.parameters.vertexBackgrounds?i[g][r]:n,v=i[g][a],x=JSON.stringify({icon:_,text:v});c.get(_)===void 0&&(c.set(_,_),m.set(_,_)),h.get(x)===void 0&&(h.set(x,u),u++)}if(p===h.size)return this.oldMapTextureRes;let f=Array.from(c.entries()).filter(g=>typeof g[1]=="string").map(([g,_])=>new Promise((v,x)=>{this.url2canvas(g,y=>{c.set(g,y),v(g)})}));return await Promise.all(f).then(g=>{if(!this.canvas)return this.oldMapTextureRes;for(let[y,b]of h){const S=JSON.parse(y).icon,w=JSON.parse(y).text,C=c.get(S);if(typeof C=="string")continue;const L=this.boxes.findIndex(B=>B.key===y);if(L>0){const B=this.boxes.splice(L,1);this.boxes.unshift(B[0]);continue}const T=C.width,E=C.height,I=T+this.gap[0],z=E+this.gap[1];this.boxes.unshift({w:I,h:z,width:T,height:E,key:y,icon:C,text:w}),this.boxes.length>this.boxSize&&this.boxes.splice(this.boxSize)}const _=nf(this.boxes);for(let y=0;y<this.boxes.length;y++){const b=this.boxes[y];this.boxHash.set(b.key,b)}const v=_.w,x=_.h;this.canvas.width=v||1,this.canvas.height=x||1,l.save();for(let y=0;y<this.boxes.length;y++){const b=this.boxes[y],S=b.icon,w=b.text;l.drawImage(S,b.x+this.gap[0],b.y+this.gap[1],b.width,b.height);let C=this.parameters.fontSize;C==="auto"&&(C=this.getFontSize(w,b.width,b.height)),l.font=`${C}px Microsoft Yahei`,l.fillStyle=this._fillStyle,l.textBaseline="top",l.fillText(w,b.x+this.gap[0]/2+this.padding[3],b.y+this.gap[1]/2+this.padding[0])}return l.restore(),this.texture.dispose(),this.texture=new Le(this.canvas),this.oldMapTextureRes={texture:this.texture,labelHash:h},{texture:this.texture,labelHash:h}})}),this.parameters=t,this._padding=[0,0,0,0],this.parameters.padding&&(this.padding=this.parameters.padding),this._fillStyle=this.parameters.fillStyle||"#fff";const e=this.canvas=document.createElement("canvas");e.width=e.height=1,(this.ctx=e.getContext("2d")).textAlign="start",this.texture=new Le(e),this.defineMaterialProxyProperties(["width","height","offset","opacity","flat","keepSize"]),this.boxes=[],this.boxSize=t.boxSize||10}initObject(){const{background:t,vertexBackgrounds:e,fontSize:i,padding:n,fillStyle:r,...a}=this.parameters;this.geometry=new Ww(this.parameters),this.material=new Gw(a),this.material.setCommonUniforms(this.engine.rendering.uniforms)}getDefaultParams(){return{width:12,height:12,fontSize:14}}collisionTest(t){return{width:this.width,height:this.height}}async setData(){const{vertexBackgrounds:t,background:e,bgPropName:i="background",textPropName:n="text"}=this.parameters;let r=[];r=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData;const a=await this.getTextureAndHash(r,e,i,n,!0);if(!a||!a.texture||!a.labelHash)return;let o=a.texture,l=a.labelHash;this.material.mapTexture=o,this.material.uniforms.ulength.value=l.size;const h=[],c=[],u=[],p=[],m=[];for(let f=0;f<r.length;f++){const g=r[f].position,_=r[f].index,v=JSON.stringify({icon:t?r[f][i]:e,text:r[f][n]}),x=this.boxHash.get(v);if(!x)continue;for(let L=0;L<4;L++)h.push(...g),c.push(L),u.push(_);const y=x.x/this.canvas.width,b=(x.x+x.w)/this.canvas.width,S=(x.y+x.h)/this.canvas.height,w=x.y/this.canvas.height;p.push(y,S,y,w,b,w,b,S);const C=4*f;m.push(C,C+2,C+1,C,C+3,C+2)}this.geometry.setData({aPositions:h,pIndices:c,aObjectIndices:u,aUvs:p,indices:m}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,h),this.needsUpdate=!1,this.engine.requestRender()}url2canvas(t,e){if(typeof t=="object")e(t);else{let i=new Image;i.crossOrigin="anonymous",i.onload=function(){let n=i.width,r=i.height,a=document.createElement("canvas");a.width=n,a.height=r,a.getContext("2d").drawImage(i,0,0,n,r),e(a)},i.onerror=function(){let n=document.createElement("canvas");n.width=20,n.height=40;let r=n.getContext("2d");r.fillStyle="red",r.beginPath(),r.lineTo(0,0),r.lineTo(20,0),r.lineTo(10,40),r.closePath(),r.fill(),e(n)},i.src=t}}getFontSize(t,e,i,n=1){const r=this.ctx,a=this.padding;return r.font=`${n}px Microsoft Yahei`,r.textBaseline="top",r.measureText(t).width+a[1]+a[3]>=e||n+a[0]+a[2]>=i?n-1:this.getFontSize(t,e,i,n+1)}getEntityByIndex(t){const e=this.dataSource,i={index:t,value:e.getOriginData(t),itemIndex:e.getOriginDataIndex(t),pairs:{}},n=e.data;for(const r of Object.keys(n))i.pairs[r]=n[r][t];return i}raycast(t,e){if(this.flat)return;const i=this.geometry,n=i.getAttribute("position");if(!n||!n.array||!n.array.length===0)return;const r=i.getAttribute("offset");let a=[];r&&(a=r.array);const o=t.camera,l=t.mouse,h=this.material.uniforms.resolution.value,c=l.x,u=l.y,p=this.width/h[0],m=this.height/h[0];let f=0,g=0,_=0,v=0,x=0,y=0;lh.multiplyMatrices(o.projectionMatrix,o.matrixWorldInverse),lh.multiplyMatrices(lh,this.matrixWorld);const b=n.array;let S=0;for(let w=0,C=b.length-11;w<C;w+=12)if(an.set(b[w],b[w+1],b[w+2],1),an.applyMatrix4(lh),an.divideScalar(an.w),this.parameters.vertexOffsets?(S=w/12*8,x=a[S]||0,y=a[S+1]||0):(x=this.parameters.offset&&this.parameters.offset[0]||0,y=this.parameters.offset&&this.parameters.offset[1]||0),an.x+=2*x/h[0],an.y-=2*y/h[1],f=an.x-p,_=an.x+p,g=an.y-m,v=an.y+m,f<=c&&_>=c&&g<=u&&v>=u){Hu.set(b[w],b[w+1],b[w+2]),Hu.applyMatrix4(this.matrixWorld);const L={instanceId:w/12,object:this,distance:Hu.distanceTo(o.position)};e.push(L)}}set padding(t){t.length===2?this._padding=[t[0],t[1],t[0],t[1]]:t.length===3?this._padding=[t[0],t[1],t[2],t[1]]:t.length>=4&&(this._padding=[t[0],t[1],t[2],t[3]])}get padding(){return this._padding}onDispose(){this.texture&&this.texture.dispose(),this.canvas&&(this.canvas=null),this.iconUrlHash.clear(),this.labelHash.clear(),this.boxHash.clear()}}function ju(s,t,e,i,n,r){if(n-i<=e)return;const a=i+n>>1;T_(s,t,a,i,n,r%2),ju(s,t,e,i,a-1,r+1),ju(s,t,e,a+1,n,r+1)}function T_(s,t,e,i,n,r){for(;n>i;){if(n-i>600){const h=n-i+1,c=e-i+1,u=Math.log(h),p=.5*Math.exp(2*u/3),m=.5*Math.sqrt(u*p*(h-p)/h)*(c-h/2<0?-1:1);T_(s,t,e,Math.max(i,Math.floor(e-c*p/h+m)),Math.min(n,Math.floor(e+(h-c)*p/h+m)),r)}const a=t[2*e+r];let o=i,l=n;for(fo(s,t,i,e),t[2*n+r]>a&&fo(s,t,i,n);o<l;){for(fo(s,t,o,l),o++,l--;t[2*o+r]<a;)o++;for(;t[2*l+r]>a;)l--}t[2*i+r]===a?fo(s,t,i,l):(l++,fo(s,t,l,n)),l<=e&&(i=l+1),e<=l&&(n=l-1)}}function fo(s,t,e,i){Gu(s,e,i),Gu(t,2*e,2*i),Gu(t,2*e+1,2*i+1)}function Gu(s,t,e){const i=s[t];s[t]=s[e],s[e]=i}function C_(s,t,e,i){const n=s-e,r=t-i;return n*n+r*r}const Xw=s=>s[0],qw=s=>s[1];class E_{constructor(t,e=Xw,i=qw,n=64,r=Float64Array){this.nodeSize=n,this.points=t;const a=t.length<65536?Uint16Array:Uint32Array,o=this.ids=new a(t.length),l=this.coords=new r(2*t.length);for(let h=0;h<t.length;h++)o[h]=h,l[2*h]=e(t[h]),l[2*h+1]=i(t[h]);ju(o,l,n,0,o.length-1,0)}range(t,e,i,n){return function(r,a,o,l,h,c,u){const p=[0,r.length-1,0],m=[];let f,g;for(;p.length;){const _=p.pop(),v=p.pop(),x=p.pop();if(v-x<=u){for(let S=x;S<=v;S++)f=a[2*S],g=a[2*S+1],f>=o&&f<=h&&g>=l&&g<=c&&m.push(r[S]);continue}const y=Math.floor((x+v)/2);f=a[2*y],g=a[2*y+1],f>=o&&f<=h&&g>=l&&g<=c&&m.push(r[y]);const b=(_+1)%2;(_===0?o<=f:l<=g)&&(p.push(x),p.push(y-1),p.push(b)),(_===0?h>=f:c>=g)&&(p.push(y+1),p.push(v),p.push(b))}return m}(this.ids,this.coords,t,e,i,n,this.nodeSize)}within(t,e,i){return function(n,r,a,o,l,h){const c=[0,n.length-1,0],u=[],p=l*l;for(;c.length;){const m=c.pop(),f=c.pop(),g=c.pop();if(f-g<=h){for(let b=g;b<=f;b++)C_(r[2*b],r[2*b+1],a,o)<=p&&u.push(n[b]);continue}const _=Math.floor((g+f)/2),v=r[2*_],x=r[2*_+1];C_(v,x,a,o)<=p&&u.push(n[_]);const y=(m+1)%2;(m===0?a-l<=v:o-l<=x)&&(c.push(g),c.push(_-1),c.push(y)),(m===0?a+l>=v:o+l>=x)&&(c.push(_+1),c.push(f),c.push(y))}return u}(this.ids,this.coords,t,e,i,this.nodeSize)}}const Yw={minZoom:0,maxZoom:16,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:s=>s};class Zw{constructor(t){this.options=go(Object.create(Yw),t),this.trees=new Array(this.options.maxZoom+1)}load(t){const{log:e,minZoom:i,maxZoom:n,nodeSize:r}=this.options;e&&console.time("total time");const a=`prepare ${t.length} points`;e&&console.time(a),this.points=t;let o=[];for(let l=0;l<t.length;l++){const h=t[l];(Array.isArray(h)||h.geometry)&&o.push(Kw(h,l))}this.trees[n+1]=new E_(o,R_,D_,r,Float32Array),e&&console.timeEnd(a);for(let l=n;l>=i;l--){const h=+Date.now();o=this._cluster(o,l),this.trees[l]=new E_(o,R_,D_,r,Float32Array),e&&console.log("z%d: %d clusters in %dms",l,o.length,+Date.now()-h)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let i=((t[0]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,t[1]));let r=t[2]===180?180:((t[2]+180)%360+360)%360-180;const a=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)i=-180,r=180;else if(i>r){const c=this.getClusters([i,n,180,a],e),u=this.getClusters([-180,n,r,a],e);return c.concat(u)}const o=this.trees[this._limitZoom(e)],l=o.range(Wu(i),Xu(a),Wu(r),Xu(n)),h=[];for(const c of l){const u=o.points[c];h.push(u.numPoints?A_(u):this.points[u.index])}return h}getChildren(t){const e=this._getOriginId(t),i=this._getOriginZoom(t),n="No cluster with the specified id.",r=this.trees[i];if(!r)throw new Error(n);const a=r.points[e];if(!a)throw new Error(n);const o=this.options.radius/(this.options.extent*Math.pow(2,i-1)),l=r.within(a.x,a.y,o),h=[];for(const c of l){const u=r.points[c];u.parentId===t&&h.push(u.numPoints?A_(u):this.points[u.index])}if(h.length===0)throw new Error(n);return h}getLeaves(t,e,i){e=e||10,i=i||0;const n=[];return this._appendLeaves(n,t,e,i,0),n}getTile(t,e,i){const n=this.trees[this._limitZoom(t)],r=Math.pow(2,t),{extent:a,radius:o}=this.options,l=o/a,h=(i-l)/r,c=(i+1+l)/r,u={features:[]};return this._addTileFeatures(n.range((e-l)/r,h,(e+1+l)/r,c),n.points,e,i,r,u),e===0&&this._addTileFeatures(n.range(1-l/r,h,1,c),n.points,r,i,r,u),e===r-1&&this._addTileFeatures(n.range(0,h,l/r,c),n.points,-1,i,r,u),u.features.length?u:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const i=this.getChildren(t);if(e++,i.length!==1)break;t=i[0].properties.cluster_id}return e}_appendLeaves(t,e,i,n,r){const a=this.getChildren(e);for(const o of a){const l=o.properties;if(l&&l.cluster?r+l.point_count<=n?r+=l.point_count:r=this._appendLeaves(t,l.cluster_id,i,n,r):r<n?r++:t.push(o),t.length===i)break}return r}_addTileFeatures(t,e,i,n,r,a){for(const o of t){const l=e[o],h=l.numPoints,c={type:1,geometry:[[Math.round(this.options.extent*(l.x*r-i)),Math.round(this.options.extent*(l.y*r-n))]],tags:h?P_(l):this.points[l.index].properties};let u;h?u=l.id:this.options.generateId?u=l.index:this.points[l.index].id&&(u=this.points[l.index].id),u!==void 0&&(c.id=u),a.features.push(c)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(t,this.options.maxZoom+1))}_cluster(t,e){const i=[],{radius:n,extent:r,reduce:a}=this.options,o=n/(r*Math.pow(2,e));for(let l=0;l<t.length;l++){const h=t[l];if(h.zoom<=e)continue;h.zoom=e;const c=this.trees[e+1],u=c.within(h.x,h.y,o);let p=h.numPoints||1,m=h.x*p,f=h.y*p,g=a&&p>1?this._map(h,!0):null;const _=(l<<5)+(e+1)+this.points.length;for(const v of u){const x=c.points[v];if(x.zoom<=e)continue;x.zoom=e;const y=x.numPoints||1;m+=x.x*y,f+=x.y*y,p+=y,x.parentId=_,a&&(g||(g=this._map(h,!0)),a(g,this._map(x)))}p===1?i.push(h):(h.parentId=_,i.push(Jw(m/p,f/p,_,p,g)))}return i}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e){if(t.numPoints)return e?go({},t.properties):t.properties;const i=this.points[t.index].properties,n=this.options.map(i);return e&&n===i?go({},n):n}}function Jw(s,t,e,i,n){return{x:s,y:t,zoom:1/0,id:e,parentId:-1,numPoints:i,properties:n}}function Kw(s,t){const[e,i]=Array.isArray(s)?s:s.geometry.coordinates;return{x:Wu(e),y:Xu(i),zoom:1/0,index:t,parentId:-1}}function A_(s){return{type:"Feature",id:s.id,properties:P_(s),geometry:{type:"Point",coordinates:[(t=s.x,360*(t-.5)),Qw(s.y)]}};var t}function P_(s){const t=s.numPoints,e=t>=1e4?`${Math.round(t/1e3)}k`:t>=1e3?Math.round(t/100)/10+"k":t;return go(go({},s.properties),{cluster:!0,cluster_id:s.id,point_count:t,point_count_abbreviated:e})}function Wu(s){return s/360+.5}function Xu(s){const t=Math.sin(s*Math.PI/180),e=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return e<0?0:e>1?1:e}function Qw(s){const t=(180-360*s)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function go(s,t){for(const e in t)s[e]=t[e];return s}function R_(s){return s.x}function D_(s){return s.y}class L_ extends Sn{constructor(){super(...arguments),d(this,"isEventEntitySupported",!0)}addComponent(t){if(!t.isGeoObject)return void console.warn("Only GeoObject can be added");t.__eventProxyByParent=!0,this.add(t),t.afterAddToEngine(this.engine);const e=this.getChildDataSource(t);return e&&(t.dataSource=e),this.needsUpdate=!0,t}removeComponent(t){this.remove(t),t.__eventProxyByParent=!1,t.dataSource=null,t.beforeRemoveFromEngine(this.engine),this.needsUpdate=!0}getChildDataSource(t){return this.dataSource}onBeforeScenePrepareRender(t,e,i,n){super.onBeforeScenePrepareRender&&super.onBeforeScenePrepareRender(t,e,i,n);for(const r of this.children)r.onBeforeScenePrepareRender&&r.onBeforeScenePrepareRender(t,e,i,n)}onBeforeSceneRender(t,e,i,n){super.onBeforeSceneRender&&super.onBeforeSceneRender(t,e,i,n);for(const r of this.children)r.onBeforeSceneRender&&r.onBeforeSceneRender(t,e,i,n)}setDataSource(t){super.setDataSource(t);for(const e of this.children)e.setDataSource(this.getChildDataSource(e))}setData(){for(const t of this.children)t.needsUpdate&&t.setData();this.needsUpdate=!1}dispose(){for(const t of this.children)t.dispose()}}const $w={width:30,height:30,mapSrc:"https://bj.bcebos.com/v1/yanpan-screen-attachment/resources/image/yinlianPOC/djiudian.png"},tS={collides:!1,fillStyle:"#ccc",fontSize:16,flat:!1},eS={maxZoom:18,minZoom:5,radius:50},iS=pt.merge([{emissive:{value:[0,0,0]},isEmissive:{value:!1}}]);class nS extends sn{constructor(t){super(),this.type="InstancedEffectModelMaterial",this.isInstancedEffectModelMaterial=!0,this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float height;
#if defined(USE_SIZE3)
uniform vec3 size3;
#else
uniform float size;
#endif

uniform float elapsedTime;
attribute float instancedRandomFactor;

#if defined(VERTEX_COLOR4)
    attribute vec4 color;
    varying vec4 vColor;
#elif defined(VERTEX_COLOR3)
    attribute vec3 color;
    varying vec3 vColor;
#endif

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

#define MVT_KEEP_PROJECTION_POSITION

#include <logdepthbuf_pars_vertex>
vec3 transformPosition(vec3 p) {
    vec3 transformed = vec3(p);

    #include <mvt_animation_vertex>

    #if defined(USE_SIZE3)
        transformed *= size3;
    #else
        transformed *= size;
    #endif
    transformed.z += height;

    #include <mvt_keepsize_vertex>

    return transformed;
}
void main() {
    
    #if defined(VERTEX_COLOR4)
        vColor = vec4(color);
    #elif defined(VERTEX_COLOR3)
        vColor = vec3(color);
    #endif

    #include <mvt_selective_vertex>
    vec4 mvp_projectPosition;

    vec3 transformed = transformPosition(position);
    
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix *
        vec4(transformed, 1.0);
    
    mvp_projectPosition = gl_Position;

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#if defined(VERTEX_COLOR4)
    varying vec4 vColor;
#elif defined(VERTEX_COLOR3)
    varying vec3 vColor;
#else
    uniform vec4 color;
#endif

uniform float opacity;
uniform vec3 emissive;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#define MVT_EMISSIVE_SHADER
void main() {

    #include <logdepthbuf_fragment> 

    #if defined(VERTEX_COLOR4)
        gl_FragColor = vColor;
    #elif defined(VERTEX_COLOR3)
        gl_FragColor = vec4(vColor, 1.0);
    #else
        gl_FragColor = color;
    #endif
      
    gl_FragColor.a *= opacity;
    vec4 out_emissive = vec4(emissive, 1.0);
    #include <mvt_selective_fragment>

    #include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Object.assign(this.uniforms,pt.clone(iS)),this.defines={},jt(this,["emissive","isEmissive"]),this.setValues(t)}get vertexColors4(){return this.defines.VERTEX_COLOR4=!0}set vertexColors4(t){t!==this.defines.VERTEX_COLOR4&&(this.defines.VERTEX_COLOR4=!!t,this.needsUpdate=!0)}get vertexColors3(){return this.defines.VERTEX_COLOR3=!0}set vertexColors3(t){t!==this.defines.VERTEX_COLOR3&&(this.defines.VERTEX_COLOR3=!!t,this.needsUpdate=!0)}}const sS={normalize:!0,rotateToZUp:!0,keepSize:!0};class rS extends Sn{constructor(){super(...arguments),d(this,"isLine",!0),d(this,"isLineSegments",!0)}}class aS extends Pt{constructor(t){super(t),this.parameters=t}setData(t){const{vertexColors:e,vertexHeights:i}=this.parameters,{aPositions:n,indices:r,aColors:a,aHeights:o,aLengths:l}=t;this.setAttribute("position",new et(n,3)),this.setAttribute("aLength",new et(l,1)),e&&this.setAttribute("aColor",new et(a,4)),i&&this.setAttribute("aHeight",new et(o,1)),this.setIndex(r)}}const oS=pt.merge([ot.fog,ki,is,{isEmissive:{value:!1},color:{value:[1,1,0,1]},height:{value:100},vertexColors:{value:!1},vertexHeights:{value:!1},tailLength:{value:50},speed:{value:1},idle:{value:2e3}}]);class lS extends Be{constructor(t){super(),this.type="SparkMaterial",this.isSparkMaterial=!0,this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute float aLength;

uniform float elapsedTime;
uniform float tailLength;
uniform float speed;
uniform float idle;

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec4 color;
#endif

#ifdef MVT_USE_VERTEX_HEIGHT
    attribute float aHeight;
#else
    uniform float height;
#endif

varying float vOpacity;
varying vec4 vColor;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() {
    #include <mvt_selective_vertex>

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = color;
    #endif

    #include <begin_vertex>
    #include <project_vertex>

    #ifdef MVT_USE_VERTEX_HEIGHT
        float total = aHeight + tailLength;
    #else
        float total = height + tailLength;
    #endif
    float currentHeight = mod(elapsedTime * speed, total + idle * speed);
    vOpacity = (aLength - (currentHeight - tailLength)) / tailLength;
    // vOpacity = 1.;

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

varying vec4 vColor;
varying float vOpacity;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    if (vOpacity > 1.0 || vOpacity < 0.0) {
        discard;
    }
    gl_FragColor = vec4(vColor.rgb, vColor.a * vOpacity);

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
}
`,this.transparent=!0,Object.assign(this.uniforms,pt.clone(oS)),ns(this),jt(this,["isEmissive","height","tailLength","speed","idle"]),Bs(this,["color"]),Qe(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexHeights","MVT_USE_VERTEX_HEIGHT"]]),ss(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}}let qu=pt.merge([is,{color:{value:[1,.5,0,1]},borderColor:{value:[0,1,0,1]},opacity:{value:1},radius:{value:.5},borderWidth:{value:1},isEmissive:{value:!1}}]);class hS extends sn{constructor(t){super(),d(this,"type","CircleMaterial"),d(this,"isCircleMaterial",!0),this.depthTest=!1,this.depthWrite=!1,t.vertexSizes||(qu=pt.merge([qu,{size:{value:100}}])),Object.assign(this.uniforms,pt.clone(qu)),jt(this,["borderWidth","opacity","isEmissive"]),Bs(this,["borderColor"]),Qe(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexSizes","MVT_USE_VERTEX_SIZE"]]),ss(this),this.vertexShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif

#ifndef MVT_USE_VERTEX_SIZE
    uniform float size;
#endif

varying vec2 vPosition;
varying float vScale;

#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {
   
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    
    vec3 transformed = vec3(position);
    #ifdef MVT_USE_VERTEX_SIZE
        vScale = instanceMatrix[0][0];
    #else
        vScale = size;
        transformed *= size;
    #endif

    #include <mvt_keepsize_vertex>

    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #include <logdepthbuf_vertex>

    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)
        vColor.xyz = instanceColor.xyz;
        vColor.a = 1.0;
    #endif
}`,t.type==="Gradient"?this.fragmentShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec4 color;
#endif
uniform float radius;

varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }
    #ifdef MVT_USE_VERTEX_COLOR
        vec4 fillColor = vColor;
    #else
        vec4 fillColor = color;
    #endif
    
    fillColor.a = smoothstep(0.0, 1.0, pow(d / radius, 2.0));
    // 边缘抗锯齿
    if(d >- 0.99 * radius) {
        fillColor.a *= 1.0 - smoothstep(0.99, 1.0, d / radius); 
    }
    gl_FragColor = fillColor;

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment>   
}`:this.fragmentShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec4 color;
#endif
uniform vec4 borderColor;
uniform float opacity;
uniform float radius;
uniform float borderWidth;

varying vec2 vPosition;
varying float vScale;

#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {
    float dis = distance(vPosition, vec2(0, 0));

    // 用来保持边框的宽度不会随着缩放而变化
    float radius2 = radius - (borderWidth / vScale) * radius;

    // 用于抗锯齿
    float blur = 0.001;
    float pct = (1.0 - smoothstep(radius - blur, radius + blur, dis));
    #ifdef MVT_USE_VERTEX_COLOR
        vec4 currentColor = mix(vColor, borderColor, smoothstep( radius2 - blur,radius2 + blur, dis));
    #else
        vec4 currentColor = mix(color, borderColor, smoothstep( radius2 - blur,radius2 + blur, dis));
    #endif
    
    // 设置的自身颜色的透明度优先级高于设置的opacity优先级
    if(currentColor.a == 1.0) {
        gl_FragColor = vec4(currentColor.rgb, pct * opacity);
    } else {
        gl_FragColor = vec4(currentColor.rgb, pct * currentColor.a);
    }

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
}`,this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}}class Yu extends Si{constructor(t){super(t),d(this,"geometry"),d(this,"material"),d(this,"color"),d(this,"size"),d(this,"opacity"),d(this,"type"),d(this,"borderColor"),d(this,"borderWidth"),d(this,"getInstanceLocalMatrix",(e,i,n)=>{const{vertexSizes:r}=this.parameters,{size:a}=this.dataSource.data;if(r&&a){const o=new rt;return o.makeScale(a[n],a[n],a[n]),o}return null}),d(this,"addCustomAttributes",()=>{const{vertexColors:e}=this.parameters,{color:i}=this.dataSource.data,n=[];e&&i&&i.forEach(r=>{const a=Xm(r);n.push(...a.toArray())}),this.instanceColor=new Xi(new Float32Array(n),3)}),this.parameters=t,this.defineMaterialProxyProperties(["color","size","size3","opacity","borderWidth","borderColor","radius","keepSize"])}initObject(){this.geometry=new ah,this.material=new hS(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}collisionTest(t){let e=0;return this.material.keepSize&&(e=this.parameters.vertexSizes&&t.size?t.size:this.size),{width:e,height:e}}}const cS=pt.merge([ot.fog,{heatmap:{value:null},heatmapDepth:{value:null},gradientMap:{value:null},opacity:{value:1}}]);class uS extends Be{constructor(t){super(t),this.type="HeatmapMaterial",this.isHeatmapMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D heatmap;
uniform sampler2D gradientMap;
uniform sampler2D heatmapDepth;
uniform float opacity;
uniform vec2 resolution;

varying vec2 vUv;

#include <packing>

#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
#endif

void main() {
    vec4 color = texture2D(heatmap, vUv);
    
    if (color.a <= 0.) {
        discard;
    }
    gl_FragColor = texture2D(gradientMap, vec2(color.a, 0.5));
    float addAlpha = 1.0;
    if (color.a < 0.3) {
        addAlpha = color.a * 3.3;
    }
    // if (color.a < 0.3) {
    //     gl_FragColor.a = color.a * 3.3;
    // } else {
    //     gl_FragColor.a = 1.0;
    // }
    gl_FragColor.a *= color.a;
    gl_FragColor.a *= opacity;

    vec4 depthColor = texture2D(heatmapDepth, vUv);

    #if defined( USE_LOGDEPTHBUF ) 
        gl_FragDepthEXT = unpackRGBAToDepth(depthColor);
    #endif
    // gl_FragColor = depthColor;
    // #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
    //    int r = int(color.r * 255.0);
    //    int g = int(color.g * 255.0);
    //    int b = int(color.b * 255.0);
    //    int d = r << 16 + g << 8 + b;
    //    float z = float(d) / 16581375.0;
    //    gl_FragDepthEXT = z;
        //gl_FragDepthEXT = color.r;
       // gl_FragColor = vec4(1.0, 0, 0, color.r);
       // gl_FragDepthEXT = log2( color.r ) * logDepthBufFC * 0.5;
       // gl_FragDepthEXT = 1.0;

    //    float depth = dot( vec2(color.r, color.g), 1.0 / vec2(1.0, 256.0) );
    //    gl_FragDepthEXT = depth * (256.0*256.0) / (256.0*256.0 - 1.0);
// gl_FragColor = vec4(gl_FragDepthEXT, gl_FragDepthEXT, 0, 1.0);
    // #endif
    // gl_FragColor.a = color.a * 0.8;
    // gl_FragColor = vec4(vUv, 0, 1.0);
    // gl_FragColor = vec4(1.0, 0,0, 0.8);
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
uniform sampler2D gradientMap;

varying vec2 vUv;

void main() { 
    
    gl_Position = vec4(position, 1.0);
    // vUv = position.xy;
    vUv = vec2((position.x + 1.0) * 0.5, (position.y + 1.0) * 0.5);
    // vec4 gray = texture2D(gradientMap, vUv);

    // vec4 m0 = matrixWorldInverse * vec4(gl_Position.xy, 0.0, 1.0);
    // vec4 m1 = matrixWorldInverse * vec4(gl_Position.xy, 1.0, 1.0);
    // m0 /= m0.w;
    // m1 /= m1.w;
    // vec4 pixel = m0 + (-m0.z / (m1.z - m0.z)) * (m1 - m0);
    // pixel.z = 100. * gray.a;

    // gl_Position = projectionMatrix * pixelToViewMatrix * vec4(pixel.xyz, 1.0);
}`,Object.assign(this.uniforms,pt.clone(cS)),jt(this,["opacity","resolution"]),_i(this,[]),Qe(this,[]),this._cachedGradient=null,Object.defineProperties(this,{gradient:{get:function(){return this._cachedGradient},set:function(e){this._cachedGradient=e,this.updateGradientMap()}}}),this.createGradientMap(),this.uniforms.gradientMap.value=this._cachedGradientMap,this.setValues(t)}createGradientMap(){let t=document.createElement("canvas");t.width=64,t.height=2;let e=t.getContext("2d"),i=e.createLinearGradient(0,0,64,0);i.addColorStop(0,"rgba(0,0,255,1)"),i.addColorStop(.3,"rgba(0,255,0,1)"),i.addColorStop(.6,"rgba(255,255,0,1)"),i.addColorStop(1,"rgba(255,0,0,1)"),e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap=new Le(t)}updateGradientMap(){let t=this._cachedGradient;if(Object.prototype.toString.call(t)!=="[object Object]")return;let e=this._cachedGradientMap.image.getContext("2d");e.clearRect(0,0,64,2);let i=e.createLinearGradient(0,0,64,0);for(const n in t)Object.hasOwnProperty.call(t,n)&&i.addColorStop(n,t[n]);e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap.needsUpdate=!0}dispose(){this._cachedGradientMap&&this._cachedGradientMap.dispose(),super.dispose()}}const dS=pt.merge([ot.fog,{radius:{value:30},circleMap:{value:null},minValue:{value:0},maxValue:{value:100},keepSize:{value:!1},attenuateMValueFactor:{value:0}}]);class pS extends Be{constructor(t){super(t),this.type="HeatmapTextureMaterial",this.isHeatmapTextureMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.depthTest=!1,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D circleMap;

varying vec2 vUv;
varying float vWeight;
varying float vZDepth;
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    gl_FragColor.a = texture2D(circleMap, vUv).a * vWeight;
    // gl_FragColor.a = 1.;
    //#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
        // gl_FragColor = vec4(vec3(gl_FragDepthEXT), 1.0);
        // int d = int(gl_FragDepthEXT * 16581375.0);
        // gl_FragColor.r = float((d & 0xff0000) >> 16) / 255.0;
        // gl_FragColor.g = float((d & 0x00ff00) >> 8) / 255.0;
        // gl_FragColor.b = float(d & 0x0000ff) / 255.0;
        // gl_FragColor.r = gl_FragDepthEXT; // a
        // gl_FragColor.g = mod(gl_FragDepthEXT * 10.0, 1.0);
        // gl_FragColor.b = mod(gl_FragDepthEXT * 1000.0, 1.0);
        // int d = int(gl_FragDepthEXT * 10000000.0);
        // gl_FragColor.r = (d & 0xff000 >> 16) / 255.0; 
        // gl_FragColor.g = (d & 0x00ff00 >> 8) / 255.0; 
        // gl_FragColor.b = (d & 0x0000ff ) / 255.0; 
        // gl_FragColor.r = gl_FragDepthEXT;
        // gl_FragColor.r = gl_FragCoord.z;

        // float depthVal = gl_FragCoord.z * (256.0*256.0 - 1.0) / (256.0*256.0);
        // vec3 encode = fract( depthVal * vec3(1.0, 256.0, 256.0*256.0) );
        // encode.xy = encode.xy - encode.yz / 256.0 + 1.0/512.0;
        // gl_FragColor.rgb = encode;

    // #else 
    //     gl_FragColor.r = gl_FragCoord.z;
    // #endif
    // gl_FragColor.r = 1.0;
    // gl_FragColor.a = gl_FragCoord.z;
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute float instancedWeight;

uniform float radius;
uniform float maxValue;
uniform float minValue;
uniform bool keepSize;
uniform float attenuateMValueFactor;
uniform float pixelRatio;
uniform vec2 resolution;

varying vec2 vUv;
varying float vWeight;

#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 

    float range = (maxValue - minValue) * attenuateMValueFactor;

    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));
    float pixelSize = getPixelSize(worldPosition.xyz);

    if (keepSize) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize, 1.0);
        range *= pixelSize;
    } else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius, 1.0);
    }
    
    // gl_Position = vec4(position, 1.0);
    // vZDepth = (gl_Position.z / gl_Position.w + 1.0) * 0.5;
   
    vUv = vec2(position.x + 0.5, position.y + 0.5);
    
    vWeight = (instancedWeight - minValue) / (maxValue + range - minValue);

    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,pt.clone(dS)),jt(this,["radius","minValue","maxValue","keepSize","attenuateMValueFactor"]),_i(this,[]),Qe(this,[]);const e=this.createCircleMap();this.uniforms.circleMap.value=e,this.setValues(t),this.blending=md,this.blendSrc=Po,this.blendDst=_d,this.blendSrcAlpha=Po,this.blendDstAlpha=Po}createCircleMap(){let t=document.createElement("canvas");t.width=64,t.height=64;let e=t.getContext("2d"),i=e.createRadialGradient(32,32,0,32,32,32);return i.addColorStop(0,"rgba(0,0,0,1)"),i.addColorStop(1,"rgba(0,0,0,0)"),e.fillStyle=i,e.arc(32,32,32,0,2*Math.PI,!1),e.fill(),new Le(t)}dispose(){this.uniforms.circleMap.value&&this.uniforms.circleMap.value.dispose(),super.dispose()}}const mS=pt.merge([ot.fog,{radius:{value:30},circleMap:{value:null},minValue:{value:0},maxValue:{value:100},keepSize:{value:!1},attenuateMValueFactor:{value:0}}]);class fS extends Be{constructor(t){super(t),this.type="HeatmapDepthTextureMaterial",this.isHeatmapDepthTextureMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.depthTest=!1,this.fragmentShader=`#define GLSLIFY 1
#include <common>
#include <packing>
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>

    #if defined( USE_LOGDEPTHBUF ) 
    
        gl_FragColor = packDepthToRGBA(gl_FragDepthEXT);
    #else
        gl_FragColor = packDepthToRGBA(gl_FragCoord.z);
    #endif
    
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
attribute vec3 instancedPosition;

uniform float radius;
uniform bool keepSize;
uniform float pixelRatio;
uniform vec2 resolution;

#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 

    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));
    float pixelSize = getPixelSize(worldPosition.xyz);
    if (keepSize) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize * 1.1, 1.0);
    } else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * 1.1, 1.0);
    }
    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,pt.clone(mS)),jt(this,["radius","minValue","maxValue","keepSize","attenuateMValueFactor"]),_i(this,[]),Qe(this,[]),this.setValues(t)}}class gS extends vm{constructor(){super();const t=this.geometry=new Rs;this.setAttribute("position",t.attributes.position),this.setAttribute("uv",t.attributes.uv),this.setIndex(t.index)}dispose(){this.geometry.dispose()}}const _S=pt.merge([ot.fog,{heightRatio:{value:100},opacity:{value:1},map:{value:null}}]);class vS extends Be{constructor(t){super(t),this.type="HeatmapMaterial",this.isHeatmapMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.depthWrite=!0,this.depthTest=!0,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D map;
uniform float opacity;
uniform vec2 resolution;

varying vec2 vUv;
#include <logdepthbuf_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vUv);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment> 

}`,this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float heightRatio;
uniform sampler2D map;

varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() { 

    vUv = vec2(uv.x, 1. - uv.y);
	#include <begin_vertex>

    transformed.z = texture2D(map, vUv).a * heightRatio;

	#include <project_vertex>
    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,pt.clone(_S)),jt(this,["heightRatio","resolution","opacity","map"]),this.setValues(t)}}var I_={exports:{}};(function(s){function t(e){if(!(this instanceof t))return new t(e);this._canvas=e=typeof e=="string"?document.getElementById(e):e,this._ctx=e.getContext("2d"),this._width=e.width,this._height=e.height,this._max=1,this._data=[]}s.exports=t,t.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(e){return this._data=e,this},max:function(e){return this._max=e,this},add:function(e){return this._data.push(e),this},clear:function(){return this._data=[],this},radius:function(e,i){i=i===void 0?15:i;var n=this._circle=this._createCanvas(),r=n.getContext("2d"),a=this._r=e+i;return n.width=n.height=2*a,r.shadowOffsetX=r.shadowOffsetY=2*a,r.shadowBlur=i,r.shadowColor="black",r.beginPath(),r.arc(-a,-a,e,0,2*Math.PI,!0),r.closePath(),r.fill(),this},resize:function(){this._width=this._canvas.width,this._height=this._canvas.height},gradient:function(e){var i=this._createCanvas(),n=i.getContext("2d"),r=n.createLinearGradient(0,0,0,256);for(var a in i.width=1,i.height=256,e)r.addColorStop(+a,e[a]);return n.fillStyle=r,n.fillRect(0,0,1,256),this._grad=n.getImageData(0,0,1,256).data,this},draw:function(e){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var i=this._ctx;i.clearRect(0,0,this._width,this._height);for(var n,r=0,a=this._data.length;r<a;r++)n=this._data[r],i.globalAlpha=Math.max(n[2]/this._max,e===void 0?.05:e),i.drawImage(this._circle,n[0]-this._r,n[1]-this._r);var o=i.getImageData(0,0,this._width,this._height);return this._colorize(o.data,this._grad),i.putImageData(o,0,0),this},_colorize:function(e,i){for(var n,r=0,a=e.length;r<a;r+=4)(n=4*e[r+3])&&(e[r]=i[n],e[r+1]=i[n+1],e[r+2]=i[n+2])},_createCanvas:function(){return typeof document<"u"?document.createElement("canvas"):new this._canvas.constructor}}})(I_);const xS=I_.exports;function yS(s,t){let e=document.createElement("canvas");return s&&(e.width=s),t&&(e.height=t),e}class bS extends Pt{constructor(){super(...arguments),d(this,"_volumeSegmentLines",(t,e,i,n,r,a,o,l,h,c,u)=>{let p=0,m=new j;const f=[o[0],o[1]];let g=Ye([a[0],a[1]],f);if(u&&(m=Ze(g),this._volumeExtrusions(t,e,n,i,a,m,h)),l){let _=Ye(f,[l[0],l[1]]),v=new j;v.addVectors(g,_),v.normalize();const x=f_(g,_),y=Ze(g),b=Math.min(h,h/x.dot(y));this._volumeExtrusions(t,e,n,i,o,x,b),p+=2}else m=Ze(g),this._volumeExtrusions(t,e,n,i,o,m,h),p+=2;return p}),d(this,"_volumeExtrusions",(t,e,i,n,r,a,o)=>{i.push(a.x,a.y,0,-a.x,-a.y,0),t.push(r[0]+a.x*o/2,r[1]+a.y*o/2,r[2]),e.push(r[0]-a.x*o/2,r[1]-a.y*o/2,r[2]),n.push(o,o)})}createVolumeGeometry(t,e){let i=this.parameters.lineWidth*e,n=[];for(let r=0;r<t.length;r++){const{vertices:a}=this.lineToShadowVolumeMesh(t[r],i);n.push([a])}return n}lineToShadowVolumeMesh(t,e){let i=0,n=null,r=null,a=null,o=null;const l=[],h=[],c=[],u=[],p=[],m=[];let f=!0;for(let v=1,x=t.length-1;v<=x;v++){if(n=o||t[v-1],r=t[v],a=t[v+1],a&&oo(r,a)){o=n;continue}const y=this._volumeSegmentLines(p,m,u,h,c,n,r,a,e,i,f);y!==-1&&(i+=y,o=null),f=!1}const g=this.conversion(p,3),_=this.conversion(m,3);return l.push(...g.concat(_.reverse())),l.push(l[0]),{vertices:l,indices:c,normals:h,widths:u}}conversion(t,e){let i=t.length,n=i%e==0?i/e:Math.floor(i/e+1),r=[];for(let a=0;a<n;a++){let o=t.slice(a*e,a*e+e);r.push(o)}return r}}class MS extends bS{constructor(t){super(),d(this,"isFatLineGeometry",!0),d(this,"_segmentLines",(e,i,n,r,a,o,l,h,c,u,p,m,f,g)=>{let _=0,v=new j,x=new j,y=new j;const b=this.parameters.lineCap==="square",S=this.parameters.lineCap==="round",w=this.parameters.lineJoin==="bevel",C=this.parameters.lineJoin==="round",L=[u[0],u[1]],T=[c[0],c[1]];let E=Ye(T,L),I=0;if(this._needsCounter&&(I=ds(L,T),this._flags.totalDistance+=I),this._flags.normal||(this._flags.normal=new j,this._flags.normal=Ze(E)),!this._flags.started)if(this._flags.started=!0,b){const z=new j,B=new j;z.addVectors(this._flags.normal,E),B.subVectors(this._flags.normal,E),o.push(B.x,B.y,0,-z.x,-z.y,0),e.push(c[0],c[1],c[2],c[0],c[1],c[2]),i.push(this._flags.totalDistance-I,0,this._flags.totalDistance-I,1),n.push(this._flags.totalDistance-I,this._flags.totalDistance-I),a.push(m,m),r.push(0,0),this.parameters.vertexColors&&l.push(f[0],f[1],f[2],f[3],f[0],f[1],f[2],f[3])}else if(S){const z=E.clone();z.negate();const B=new j;B.subVectors(this._flags.normal,E),B.normalize();const O=new j;O.addVectors(this._flags.normal,E),O.normalize();const F=this._flags.normal.clone(),Q=this._flags.normal.clone();Q.negate(),o.push(z.x,z.y,0),o.push(B.x,B.y,0),o.push(-O.x,-O.y,0),o.push(F.x,F.y,0),o.push(Q.x,Q.y,0);for(let k=0;k<5;k++)e.push(c[0],c[1],c[2]),a.push(m),i.push(this._flags.totalDistance-I,0),n.push(this._flags.totalDistance-I),r.push(0),this.parameters.vertexColors&&l.push(f[0],f[1],f[2],f[3]);h.push(g+0,g+2,g+1,g+1,g+2,g+3,g+3,g+2,g+4),_+=3,g+=3}else this._extrusions(e,o,i,n,r,a,l,c,this._flags.normal,this._flags.totalDistance-I,m,f);if(h.push(...this._flags.lastFlip===-1?[g+0,g+1,g+2]:[g+1,g+0,g+2]),p){x=Ye(L,[p[0],p[1]]),y.addVectors(E,x),y.normalize();const z=f_(E,x),B=Ze(E),O=m/z.dot(B);let F=y.dot(this._flags.normal)>0?-1:1,Q=w;if(!Q&&this.parameters.lineJoin==="miter"&&(Math.abs(O)>this.parameters.miterLimit||2*m)&&(Q=!0),Q){const k=Math.min(2*m,Math.abs(O));o.push(this._flags.normal.x*F,this._flags.normal.y*F,0),o.push(-z.x*F,-z.y*F,0),e.push(u[0],u[1],u[2],u[0],u[1],u[2]),a.push(m,k),n.push(this._flags.totalDistance,this._flags.totalDistance),r.push(0,0),h.push(...this._flags.lastFlip===-F?this._flags.lastFlip===-1?[g+2,g+1,g+3]:[g+1,g+2,g+3]:this._flags.lastFlip===-1?[g+0,g+2,g+3]:[g+2,g+0,g+3]),v=Ze(x),this._flags.normal.copy(v),o.push(this._flags.normal.x*F,this._flags.normal.y*F,0),e.push(u[0],u[1],u[2]),a.push(m),n.push(this._flags.totalDistance),r.push(0),h.push(...F===1?[g+2,g+3,g+4]:[g+3,g+2,g+4]),this._flipedUV(i,this._flags.totalDistance,F,!0),this.parameters.vertexColors&&l.push(f[0],f[1],f[2],f[3],f[0],f[1],f[2],f[3],f[0],f[1],f[2],f[3]),_+=3}else if(C){const k=Math.min(2*m,Math.abs(O));o.push(this._flags.normal.x*F,this._flags.normal.y*F,0),e.push(u[0],u[1],u[2]),a.push(m),n.push(this._flags.totalDistance),r.push(0),o.push(z.x*F,z.y*F,0),e.push(u[0],u[1],u[2]),a.push(m),n.push(this._flags.totalDistance),r.push(0),o.push(-z.x*F,-z.y*F,0),e.push(u[0],u[1],u[2]),a.push(k),n.push(this._flags.totalDistance),r.push(0),h.push(...this._flags.lastFlip===-F?this._flags.lastFlip===-1?[g+2,g+1,g+4,g+2,g+4,g+3]:[g+1,g+2,g+4,g+4,g+2,g+3]:this._flags.lastFlip===-1?[g+0,g+2,g+4,g+2,g+3,g+4]:[g+2,g+0,g+4,g+3,g+2,g+4]),v=Ze(x),this._flags.normal.copy(v),o.push(this._flags.normal.x*F,this._flags.normal.y*F,0),e.push(u[0],u[1],u[2]),a.push(m),n.push(this._flags.totalDistance),r.push(0),h.push(...F===-1?[g+4,g+3,g+5]:[g+3,g+4,g+5]),this._flipedUV(i,this._flags.totalDistance,F,!1),this.parameters.vertexColors&&l.push(f[0],f[1],f[2],f[3],f[0],f[1],f[2],f[3],f[0],f[1],f[2],f[3],f[0],f[1],f[2],f[3]),_+=4}else this._extrusions(e,o,i,n,r,a,l,u,z,this._flags.totalDistance,O,f),h.push(...this._flags.lastFlip===-1?[g+2,g+1,g+3]:[g+2,g+0,g+3]),F=-1,this._flags.normal.copy(z),_+=2;this._flags.lastFlip=F}else{if(this._flags.normal=Ze(E),b){const z=new j,B=new j;z.addVectors(E,this._flags.normal),B.subVectors(E,this._flags.normal),o.push(z.x,z.y,0,B.x,B.y,0),e.push(u[0],u[1],u[2],u[0],u[1],u[2]),a.push(m,m),i.push(this._flags.totalDistance,0,this._flags.totalDistance,1),n.push(this._flags.totalDistance,this._flags.totalDistance),r.push(0,0),this.parameters.vertexColors&&l.push(f[0],f[1],f[2],f[3],f[0],f[1],f[2],f[3])}else this._extrusions(e,o,i,n,r,a,l,u,this._flags.normal,this._flags.totalDistance,m,f);if(h.push(...this._flags.lastFlip===-1?[g+2,g+1,g+3]:[g+2,g+0,g+3]),_+=2,S){const z=new j;z.addVectors(E,this._flags.normal),z.normalize();const B=new j;B.subVectors(E,this._flags.normal),B.normalize();const O=E.clone();o.push(z.x,z.y,0),o.push(B.x,B.y,0),o.push(O.x,O.y,0);for(let F=0;F<3;F++)e.push(u[0],u[1],u[2]),a.push(m),i.push(this._flags.totalDistance,0),n.push(this._flags.totalDistance),r.push(0),this.parameters.vertexColors&&l.push(f[0],f[1],f[2],f[3]);h.push(g+2,g+3,g+4,g+4,g+3,g+5,g+4,g+5,g+6),_+=3}}return _}),d(this,"_extrusions",(e,i,n,r,a,o,l,h,c,u,p,m)=>{i.push(c.x,c.y,0,-c.x,-c.y,0),e.push(h[0],h[1],h[2],h[0],h[1],h[2]),o.push(p,p),n.push(u,0,u,1),r.push(u,u),a.push(0,0),this.parameters.vertexColors&&l.push(m[0],m[1],m[2],m[3],m[0],m[1],m[2],m[3])}),this.parameters=t,this._needsUpdate=!1,this._needsCounter=!1,this._flags={lastFlip:-1,started:!1,normal:null,totalDistance:0}}setData(t){this._needsUpdate=!0,(this.parameters.dashed||this.parameters.enableAnimation||this.parameters.mapSrc||this.parameters.map)&&(this._needsCounter=!0),this.updateGeometry(t)}updateGeometry(t){const e=[],i=[],n=[],r=[],a=[],o=[],l=[],h=[],c=[],u=[],p=[];let m=0;for(let f=0;f<t.position.length;f++){const g=t.position[f],_=t.index[f],v=this.parameters.vertexWidths?t.lineWidth[f]:this.parameters.lineWidth,x=this.parameters.vertexColors?Yi(t.color[f]):Yi(this.parameters.color);this._flags={lastFlip:-1,started:!1,normal:null,totalDistance:0};const y=g.length;let b=e.length/3,S=null,w=Math.random();u.push(w,w),n.push(0,0),p.push(_,_);for(let C=1;C<y;C++){const L=S||g[C-1],T=g[C],E=C<y-1?g[C+1]:null;if(E&&oo(T,E)){S=L;continue}const I=this._segmentLines(e,i,o,c,a,h,l,r,L,T,E,v,x,b);I!==-1&&(b+=I,S=null);for(let z=0;z<I;z++)n.push(C/y),this._needsCounter&&this.parameters.enableAnimationChaos&&u.push(w),p.push(_);m=Math.max(this._flags.totalDistance,m)}if(this._needsCounter)for(let C=0;C<c.length;C++)c[C]=m}this.cachedPositions=e,this.setAttribute("position",new et(e,3)),this.setAttribute("uv",new et(i,2)),this.setAttribute("normal",new et(h,3)),this.setAttribute("aWidth",new et(a,1)),this.setAttribute("counter",new et(n,1)),this.setAttribute("objectIndex",new et(p,1)),this._needsCounter&&(this.setAttribute("lengths",new et(o,1)),this.setAttribute("totalLength",new et(c,1)),this.setAttribute("randomFactor",new et(u,1))),this.parameters.vertexColors&&this.setAttribute("aColor",new et(l,4)),this.setIndex(r),this.computeBoundingSphere(),this._needsUpdate=!1}_flipedUV(t,e,i,n){n?i===-1?t.push(e,1,e,0,e,1):t.push(e,0,e,1,e,0):i===-1?t.push(e,1,e,1,e,0,e,1):t.push(e,0,e,0,e,1,e,0)}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}const wS=new Ie,SS=pt.merge([ot.fog,ki,is,{lineWidth:{value:100},keepSize:{value:!1},map:{value:null},useMap:{value:!1},mapGap:{value:50},uColor:{value:[0,1,1,1]},height:{value:0},opacity:{value:1},resolution:{value:new j(1,1)},sizeAttenuation:{value:1},dashArray:{value:20},dashOffset:{value:0},dashRatio:{value:.5},alphaTest:{value:0},repeat:{value:new j(1,1)},vertexColors:{value:!1},vertexZIndex:{value:!1},maxLayerIndex:{value:0},elapsedTime:{value:0},enableAnimation:{value:!1},enableAnimationChaos:{value:!1},animationInterval:{value:0},animationSpeed:{value:1},animationTailType:{value:1},animationTailRatio:{value:.2},animationTailLength:{value:100},animationIdle:{value:1e3},isEmissive:{value:!1}}]);class TS extends Be{constructor(t){super(),this.type="FatLineMaterial",this.isFatLineMaterial=!0,this.fog=!0,this.transparent=!0,this.fragmentShader=`#define GLSLIFY 1
#include <common>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

varying vec3 vLightFront;
varying vec3 vIndirectFront;

uniform sampler2D map;
uniform bool useMap;
uniform bool keepSize;
uniform float lineWidth;
uniform float mapGap;
uniform float opacity;
uniform float alphaTest;
uniform float elapsedTime;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vLength;
varying float vTotalLength;
varying float vZoomUnits;

#ifdef USE_ANIMATION
uniform float animationInterval;
varying float vAnimationOpacity;
#endif

#ifdef USE_DASH
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
varying float vDashOpacity;
#endif

void main() {

   vec4 c = vColor;

    if(useMap) {
        // icon之间的间隔，经验值为间隔50倍宽度，比较稀疏且好看
        float margin = lineWidth * mapGap;
        float halfMargin = margin / 2.0;
        float texWidth = lineWidth;
        if (keepSize) {
            margin *= vZoomUnits;
            texWidth *= vZoomUnits;
        }
        float delta = mod(vUV.x, texWidth + margin);
        if (delta >= halfMargin && delta <= halfMargin + texWidth) {
            float uvx = (delta - halfMargin) / texWidth;
            vec4 texture = texture2D(map, vec2(uvx, vUV.y));
            c = texture.a >= 0.5 ? texture : c;
        }
    }

    #ifdef USE_ANIMATION
        float animationAlpha = vAnimationOpacity;
        if (animationInterval > 0.0) {
            animationAlpha = mod(vAnimationOpacity, animationInterval);
        }
        if (animationAlpha > 1.0 || animationAlpha < 0.0) {
            discard;
        }
        c.a *= animationAlpha;
    #endif

    #ifdef USE_DASH
        float darray = dashArray;
        if (keepSize) {
            darray *= vZoomUnits;
        }
        c.a *= step(mod(vLength + dashOffset, darray), (darray * dashRatio));
    #endif

    if (c.a < alphaTest) {
        discard;
    }

    gl_FragColor = c;
    
    gl_FragColor.a *= opacity;

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>

#ifdef USE_A_COLOR
attribute vec4 aColor;
#endif

attribute float totalLength;
attribute float aWidth;
attribute float lengths;
attribute float randomFactor;

uniform float elapsedTime;
uniform bool vertexColors;
uniform vec4 uColor;
uniform float lineWidth;
uniform float height;
uniform float opacity;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vLength;
varying float vTotalLength;
varying float vZoomUnits;

#ifdef USE_ANIMATION
uniform float animationSpeed;
uniform float animationTailType;
uniform float animationTailRatio;
uniform float animationTailLength;
uniform float animationIdle;
varying float vAnimationOpacity;
#endif

#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

#ifdef MVT_USE_VERTEX_ZINDEX
attribute float layerIndex;
uniform float maxLayerIndex;

#define WORLD_DISTANCE_NEAR 100000.0
#define WORLD_DISTANCE_MID 1500000.0
#define WORLD_DISTANCE_FAR 6000000.0
#define LAYER_INDEX (maxLayerIndex - layerIndex)
// 在mid和far交接那块，因为线数据特别碎，导致layerIndex很多，地面会陷很深，还没找到比较好的函数来解决这个case

float y1(float x) {
    return pow(LAYER_INDEX * log2(x * 5.), 1.5);
}

float y2(float x) {
    float xx = x - WORLD_DISTANCE_NEAR;
    return LAYER_INDEX * log2(xx) + y1(WORLD_DISTANCE_NEAR);
}

float y3(float x) {
    float xx = x - WORLD_DISTANCE_MID;
    return log2(LAYER_INDEX * xx) + y2(WORLD_DISTANCE_MID);
}

float y4(float x) {
    return 110. * LAYER_INDEX + y3(WORLD_DISTANCE_FAR);
}

/**
y1 = pow(x, 2)                  x: (0, near]
y2 = (x - near) + y1(near)      x: (near, mid]
y3 = sqrt(x - mid) + y2(mid)    x: (mid, far]
y4 = n + y3(far)                x: (far, +∞)
*/
float y(float x) {
    if (x <= WORLD_DISTANCE_NEAR) {
        return y1(x);
    }
    if (x > WORLD_DISTANCE_NEAR && x <= WORLD_DISTANCE_MID) {
        return y2(x);
    }
    else if (x > WORLD_DISTANCE_MID && x <= WORLD_DISTANCE_FAR) {
        return y3(x);
    }
    else if (x > WORLD_DISTANCE_FAR) {
        return y4(x);
    }
}
#endif

void main() {

    #ifdef USE_A_COLOR
        vColor = aColor;
    #else
        vColor = uColor;
    #endif

    vUV = uv;
    // vCounter = counter;
    vLength = lengths;
    vTotalLength = totalLength;

    #include <begin_vertex>

    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);
    vZoomUnits = pixelSize;

    vec2 extrude = normal.xy * aWidth / 2.0;
    if (keepSize) {
        extrude *= pixelSize;
    }
    worldPosition.xy += extrude;
    worldPosition.z += height;

    #ifdef MVT_USE_VERTEX_ZINDEX
        vec3 worldToEye = cameraPosition - worldPosition.xyz;
        float dis = length(worldToEye);
        float layerGap = maxLayerIndex - layerIndex;
        // float zOffset = log2(layerGap * dis + 1.0);
        // float zOffset = exp(layerGap * log2(dis * 10.0));
        // float zOffset = pow(layerGap * log2(dis * 5.0), 1.5);
        float zOffset = y(dis);
        worldPosition.z -= zOffset;
    #endif
    
    #ifdef USE_ANIMATION
        float tailLength = animationTailType == 1.0 ? vTotalLength * animationTailRatio : animationTailLength;

        #ifdef ANIMATION_CHAOS
            float currentTime = elapsedTime + randomFactor * 1000.0 * 3600.;
        #else
            float currentTime = elapsedTime;
        #endif
        float currentLength = mod(currentTime * animationSpeed, vTotalLength + tailLength + animationIdle * animationSpeed);
        vAnimationOpacity = (vLength - (currentLength - tailLength)) / tailLength;
    #endif

    gl_Position = projectionMatrix * viewMatrix * worldPosition;

    // #ifdef MVT_USE_VERTEX_ZINDEX
    //     float depth = layerGap * 10.0;
    //     gl_Position.z = gl_Position.z + depth;
    // #endif

    #include <beginnormal_vertex>
    #include <fog_vertex>
    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,pt.clone(SS)),jt(this,["map","mapGap","lineWidth","keepSize","height","opacity","dashArray","dashOffset","dashRatio","alphaTest","maxLayerIndex","animationInterval","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","isEmissive"]),_i(this,[["color","uColor",es]]),Qe(this,[["vertexColors","USE_A_COLOR"],["vertexZIndex","MVT_USE_VERTEX_ZINDEX"],["enableAnimation","USE_ANIMATION"],["enableAnimationChaos","ANIMATION_CHAOS"],["dashed","USE_DASH"]]),ss(this),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,n="url_map";if(this.userData[n]===e)return;if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[n];const r=wS.load(e);r.wrapS=r.wrapT=ue,this.uniforms.map.value=r,this.userData[n]=e,this.uniforms.useMap.value=!0}}}),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}var pa={exports:{}};function hh(s,t,e){e=e||2;var i,n,r,a,o,l,h,c=t&&t.length,u=c?t[0]*e:s.length,p=O_(s,0,u,e,!0),m=[];if(!p||p.next===p.prev)return m;if(c&&(p=function(g,_,v,x){var y,b,S,w=[];for(y=0,b=_.length;y<b;y++)(S=O_(g,_[y]*x,y<b-1?_[y+1]*x:g.length,x,!1))===S.next&&(S.steiner=!0),w.push(IS(S));for(w.sort(RS),y=0;y<w.length;y++)v=DS(w[y],v);return v}(s,t,p,e)),s.length>80*e){i=r=s[0],n=a=s[1];for(var f=e;f<u;f+=e)(o=s[f])<i&&(i=o),(l=s[f+1])<n&&(n=l),o>r&&(r=o),l>a&&(a=l);h=(h=Math.max(r-i,a-n))!==0?32767/h:0}return _o(p,m,e,i,n,h,0),m}function O_(s,t,e,i,n){var r,a;if(n===Ku(s,t,e,i)>0)for(r=t;r<e;r+=i)a=N_(r,s[r],s[r+1],a);else for(r=e-i;r>=t;r-=i)a=N_(r,s[r],s[r+1],a);return a&&ch(a,a.next)&&(xo(a),a=a.next),a}function nr(s,t){if(!s)return s;t||(t=s);var e,i=s;do if(e=!1,i.steiner||!ch(i,i.next)&&pe(i.prev,i,i.next)!==0)i=i.next;else{if(xo(i),(i=t=i.prev)===i.next)break;e=!0}while(e||i!==t);return t}function _o(s,t,e,i,n,r,a){if(s){!a&&r&&function(c,u,p,m){var f=c;do f.z===0&&(f.z=Zu(f.x,f.y,u,p,m)),f.prevZ=f.prev,f.nextZ=f.next,f=f.next;while(f!==c);f.prevZ.nextZ=null,f.prevZ=null,function(g){var _,v,x,y,b,S,w,C,L=1;do{for(v=g,g=null,b=null,S=0;v;){for(S++,x=v,w=0,_=0;_<L&&(w++,x=x.nextZ);_++);for(C=L;w>0||C>0&&x;)w!==0&&(C===0||!x||v.z<=x.z)?(y=v,v=v.nextZ,w--):(y=x,x=x.nextZ,C--),b?b.nextZ=y:g=y,y.prevZ=b,b=y;v=x}b.nextZ=null,L*=2}while(S>1)}(f)}(s,i,n,r);for(var o,l,h=s;s.prev!==s.next;)if(o=s.prev,l=s.next,r?ES(s,i,n,r):CS(s))t.push(o.i/e|0),t.push(s.i/e|0),t.push(l.i/e|0),xo(s),s=l.next,h=l.next;else if((s=l)===h){a?a===1?_o(s=AS(nr(s),t,e),t,e,i,n,r,2):a===2&&PS(s,t,e,i,n,r):_o(nr(s),t,e,i,n,r,1);break}}}function CS(s){var t=s.prev,e=s,i=s.next;if(pe(t,e,i)>=0)return!1;for(var n=t.x,r=e.x,a=i.x,o=t.y,l=e.y,h=i.y,c=n<r?n<a?n:a:r<a?r:a,u=o<l?o<h?o:h:l<h?l:h,p=n>r?n>a?n:a:r>a?r:a,m=o>l?o>h?o:h:l>h?l:h,f=i.next;f!==t;){if(f.x>=c&&f.x<=p&&f.y>=u&&f.y<=m&&ma(n,o,r,l,a,h,f.x,f.y)&&pe(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function ES(s,t,e,i){var n=s.prev,r=s,a=s.next;if(pe(n,r,a)>=0)return!1;for(var o=n.x,l=r.x,h=a.x,c=n.y,u=r.y,p=a.y,m=o<l?o<h?o:h:l<h?l:h,f=c<u?c<p?c:p:u<p?u:p,g=o>l?o>h?o:h:l>h?l:h,_=c>u?c>p?c:p:u>p?u:p,v=Zu(m,f,t,e,i),x=Zu(g,_,t,e,i),y=s.prevZ,b=s.nextZ;y&&y.z>=v&&b&&b.z<=x;){if(y.x>=m&&y.x<=g&&y.y>=f&&y.y<=_&&y!==n&&y!==a&&ma(o,c,l,u,h,p,y.x,y.y)&&pe(y.prev,y,y.next)>=0||(y=y.prevZ,b.x>=m&&b.x<=g&&b.y>=f&&b.y<=_&&b!==n&&b!==a&&ma(o,c,l,u,h,p,b.x,b.y)&&pe(b.prev,b,b.next)>=0))return!1;b=b.nextZ}for(;y&&y.z>=v;){if(y.x>=m&&y.x<=g&&y.y>=f&&y.y<=_&&y!==n&&y!==a&&ma(o,c,l,u,h,p,y.x,y.y)&&pe(y.prev,y,y.next)>=0)return!1;y=y.prevZ}for(;b&&b.z<=x;){if(b.x>=m&&b.x<=g&&b.y>=f&&b.y<=_&&b!==n&&b!==a&&ma(o,c,l,u,h,p,b.x,b.y)&&pe(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function AS(s,t,e){var i=s;do{var n=i.prev,r=i.next.next;!ch(n,r)&&z_(n,i,i.next,r)&&vo(n,r)&&vo(r,n)&&(t.push(n.i/e|0),t.push(i.i/e|0),t.push(r.i/e|0),xo(i),xo(i.next),i=s=r),i=i.next}while(i!==s);return nr(i)}function PS(s,t,e,i,n,r){var a=s;do{for(var o=a.next.next;o!==a.prev;){if(a.i!==o.i&&OS(a,o)){var l=k_(a,o);return a=nr(a,a.next),l=nr(l,l.next),_o(a,t,e,i,n,r,0),void _o(l,t,e,i,n,r,0)}o=o.next}a=a.next}while(a!==s)}function RS(s,t){return s.x-t.x}function DS(s,t){var e=function(n,r){var a,o=r,l=n.x,h=n.y,c=-1/0;do{if(h<=o.y&&h>=o.next.y&&o.next.y!==o.y){var u=o.x+(h-o.y)*(o.next.x-o.x)/(o.next.y-o.y);if(u<=l&&u>c&&(c=u,a=o.x<o.next.x?o:o.next,u===l))return a}o=o.next}while(o!==r);if(!a)return null;var p,m=a,f=a.x,g=a.y,_=1/0;o=a;do l>=o.x&&o.x>=f&&l!==o.x&&ma(h<g?l:c,h,f,g,h<g?c:l,h,o.x,o.y)&&(p=Math.abs(h-o.y)/(l-o.x),vo(o,n)&&(p<_||p===_&&(o.x>a.x||o.x===a.x&&LS(a,o)))&&(a=o,_=p)),o=o.next;while(o!==m);return a}(s,t);if(!e)return t;var i=k_(e,s);return nr(i,i.next),nr(e,e.next)}function LS(s,t){return pe(s.prev,s,t.prev)<0&&pe(t.next,s,s.next)<0}function Zu(s,t,e,i,n){return(s=1431655765&((s=858993459&((s=252645135&((s=16711935&((s=(s-e)*n|0)|s<<8))|s<<4))|s<<2))|s<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*n|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function IS(s){var t=s,e=s;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==s);return e}function ma(s,t,e,i,n,r,a,o){return(n-a)*(t-o)>=(s-a)*(r-o)&&(s-a)*(i-o)>=(e-a)*(t-o)&&(e-a)*(r-o)>=(n-a)*(i-o)}function OS(s,t){return s.next.i!==t.i&&s.prev.i!==t.i&&!function(e,i){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==i.i&&n.next.i!==i.i&&z_(n,n.next,e,i))return!0;n=n.next}while(n!==e);return!1}(s,t)&&(vo(s,t)&&vo(t,s)&&function(e,i){var n=e,r=!1,a=(e.x+i.x)/2,o=(e.y+i.y)/2;do n.y>o!=n.next.y>o&&n.next.y!==n.y&&a<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next;while(n!==e);return r}(s,t)&&(pe(s.prev,s,t.prev)||pe(s,t.prev,t))||ch(s,t)&&pe(s.prev,s,s.next)>0&&pe(t.prev,t,t.next)>0)}function pe(s,t,e){return(t.y-s.y)*(e.x-t.x)-(t.x-s.x)*(e.y-t.y)}function ch(s,t){return s.x===t.x&&s.y===t.y}function z_(s,t,e,i){var n=dh(pe(s,t,e)),r=dh(pe(s,t,i)),a=dh(pe(e,i,s)),o=dh(pe(e,i,t));return n!==r&&a!==o||!(n!==0||!uh(s,e,t))||!(r!==0||!uh(s,i,t))||!(a!==0||!uh(e,s,i))||!(o!==0||!uh(e,t,i))}function uh(s,t,e){return t.x<=Math.max(s.x,e.x)&&t.x>=Math.min(s.x,e.x)&&t.y<=Math.max(s.y,e.y)&&t.y>=Math.min(s.y,e.y)}function dh(s){return s>0?1:s<0?-1:0}function vo(s,t){return pe(s.prev,s,s.next)<0?pe(s,t,s.next)>=0&&pe(s,s.prev,t)>=0:pe(s,t,s.prev)<0||pe(s,s.next,t)<0}function k_(s,t){var e=new Ju(s.i,s.x,s.y),i=new Ju(t.i,t.x,t.y),n=s.next,r=t.prev;return s.next=t,t.prev=s,e.next=n,n.prev=e,i.next=e,e.prev=i,r.next=i,i.prev=r,i}function N_(s,t,e,i){var n=new Ju(s,t,e);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function xo(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function Ju(s,t,e){this.i=s,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Ku(s,t,e,i){for(var n=0,r=t,a=e-i;r<e;r+=i)n+=(s[a]-s[r])*(s[r+1]+s[a+1]),a=r;return n}pa.exports=hh,pa.exports.default=hh,hh.deviation=function(s,t,e,i){var n=t&&t.length,r=n?t[0]*e:s.length,a=Math.abs(Ku(s,0,r,e));if(n)for(var o=0,l=t.length;o<l;o++){var h=t[o]*e,c=o<l-1?t[o+1]*e:s.length;a-=Math.abs(Ku(s,h,c,e))}var u=0;for(o=0;o<i.length;o+=3){var p=i[o]*e,m=i[o+1]*e,f=i[o+2]*e;u+=Math.abs((s[p]-s[f])*(s[m+1]-s[p+1])-(s[p]-s[m])*(s[f+1]-s[p+1]))}return a===0&&u===0?0:Math.abs((u-a)/a)},hh.flatten=function(s){for(var t=s[0][0].length,e={vertices:[],holes:[],dimensions:t},i=0,n=0;n<s.length;n++){for(var r=0;r<s[n].length;r++)for(var a=0;a<t;a++)e.vertices.push(s[n][r][a]);n>0&&(i+=s[n-1].length,e.holes.push(i))}return e};const ph=[1,1,0,1];class zS extends Pt{constructor(t){super(),d(this,"isPolygonGeometry",!0),d(this,"_useUV",!1),d(this,"_useNormal",!1),d(this,"_sideUVNormalized",!1),d(this,"_sideUVReversed",!1),d(this,"_sideUVUseHeight",!1),d(this,"addGeoPolygonToVertices",(e,i,n=0,r=0,a,o,l,h,c,u,p,m,f=!1)=>{const g=e.vertices,_=e.dimensions;Array.isArray(u)||(u=ph);let v=1/0,x=1/0;for(let b=0,S=g.length-_+1;b<S;b+=_)v=g[b]<v?g[b]:v,x=g[b+1]<x?g[b+1]:x;for(let b=0,S=g.length-_+1;b<S;b+=_)_===2?a.push(g[b],g[b+1],0+n):a.push(g[b],g[b+1],g[b+2]+n),l.push(0,0,1),c.push(u[0],u[1],u[2],u[3]),h.push(g[b]-v,g[b+1]-x),p.push(m);let y=[];for(let b=0,S=i.length;b<S;++b)y.push(i[b]+r);f?o.push(...y.reverse()):o.push(...y)}),d(this,"isClockWise",e=>{let i=e.length,n=0;for(let r=i-1,a=0;a<i;r=a++)n+=e[r][0]*e[a][1]-e[a][0]*e[r][1];return n<0}),d(this,"addSideFace",(e,i,n,r,a,o,l,h,c,u,p)=>{let m=e[0],f=n;m.length,this.isClockWise(m)&&(m=m.reverse()),Array.isArray(c)||(c=ph);let g=0,_=0,v=0;for(let x=0,y=m.length-1;x<y;x++){r.push(m[x][0],m[x][1],this._zOffset,m[x][0],m[x][1],this._zOffset+i,m[x+1][0],m[x+1][1],this._zOffset+i,m[x+1][0],m[x+1][1],this._zOffset),f=n+4*x,a.push(f,f+2,f+1,f,f+3,f+2);let b=m[x+1][0]-m[x][0],S=m[x+1][1]-m[x][1];const w=Math.sqrt(b*b+S*S);b/=w,S/=w,o.push(S,-b,0,S,-b,0,S,-b,0,S,-b,0),this._sideUVUseHeight?(_=1*i,v=1*i):(_=0,v=1*i,this._sideUVNormalized&&(v=1),this._sideUVReversed&&(_=v,v=0)),l.push(1*g,_,1*g,v),g+=w,l.push(1*g,v,1*g,_),h.push(c[0],c[1],c[2],c[3],c[0],c[1],c[2],c[3],c[0],c[1],c[2],c[3],c[0],c[1],c[2],c[3]),u.push(p,p,p,p)}}),this.parameters=t,this._needsUpdate=!1,this._extrude=t.extrude||!1,this._extrudeValue=t.extrudeValue||0,this._enableBottomFace=t.enableBottomFace||!1,this._zOffset=t.zOffset||0,this.cachedPositions=[],this.cachedObjectIndices=[]}setData(t){this._needsUpdate=!0,this.cachedData=t,this.updateGeometry()}updateGeometry(){let t=this.cachedData,e=null,i=null;const n=[],r=[],a=[],o=[];let l=[];const h=[];for(let u=0;u<t.position.length;u++){const p=t.position[u],m=t.index[u],f=t.color?Yi(t.color[u]):ph,g=this.parameters.vertexHeights?t.height[u]:this.extrudeValue;e=pa.exports.flatten(p),i=pa.exports(e.vertices,e.holes,e.dimensions),this.extrude&&this._enableBottomFace&&this.addGeoPolygonToVertices(e,i,this._zOffset,n.length/3,n,l,r,a,h,f,o,m,!0),this.addGeoPolygonToVertices(e,i,this._zOffset+g,n.length/3,n,l,r,a,h,f,o,m)}const c=l.length;if(this.extrude)for(let u=0;u<t.position.length;u++){const p=t.position[u],m=t.index[u],f=t.color?Yi(t.color[u]):ph,g=this.parameters.vertexHeights?t.height[u]:this.extrudeValue;g>0&&this.addSideFace(p,g,n.length/3,n,l,r,a,h,f,o,m)}this.cachedPositions=n,this.cachedObjectIndices=o,this.setAttribute("position",new et(n,3)),this.parameters.vertexColors&&this.setAttribute("aColor",new et(h,4)),this._useUV?this.setAttribute("uv",new et(a,2)):this.deleteAttribute("uv"),this._useNormal?this.setAttribute("normal",new et(r,3)):this.deleteAttribute("normal"),this.setIndex(l),this.clearGroups(),this.addGroup(0,c,1),this.extrude&&this.addGroup(c,l.length-c,0),this.computeBoundingSphere(),this._needsUpdate=!1}get extrude(){return this._extrude}set extrude(t){const e=!!t;e!==this._extrude&&(this._extrude=e,this._needsUpdate=!0)}get extrudeValue(){return this._extrudeValue}set extrudeValue(t){!isNaN(t)&&t>=0&&t!==this._extrudeValue&&(this._extrudeValue=t,this._needsUpdate=!0)}get sideUVNormalized(){return this._sideUVNormalized}set sideUVNormalized(t){t!==this._sideUVNormalized&&(this._extrude&&(this._needsUpdate=!0),this._sideUVNormalized=t)}get sideUVReversed(){return this._sideUVReversed}set sideUVReversed(t){t!==this._sideUVReversed&&(this._extrude&&(this._needsUpdate=!0),this._sideUVReversed=t)}get sideUVUseHeight(){return this._sideUVUseHeight}set sideUVUseHeight(t){t!==this._sideUVUseHeight&&(this._extrude&&(this._needsUpdate=!0),this._sideUVUseHeight=t)}get useUV(){return this._useUV}set useUV(t){t!==this._useUV&&(this._needsUpdate=!0,this._useUV=t)}get useNormal(){return this._useNormal}set useNormal(t){t!==this._useNormal&&(this._needsUpdate=!0,this._useNormal=t)}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}const kS=new Ie,NS=pt.merge([ot.fog,ki,is,{isEmissive:{value:!1},opacity:{value:1},color:{value:[0,1,1,1]},vertexColors:{value:!1},map:{value:void 0},mapLength:{value:new j},mapSrc:{value:""},mapScale:{value:1}}]);class US extends Be{constructor(t){super(),this.type="PolygonMaterial",this.isPolygonMaterial=!0,this.fog=!0,this.transparent=!0,this.depthWrite=!0,this.depthTest=!0,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#ifdef USE_MAP
    varying vec2 vUv;
    uniform sampler2D map;
    uniform vec2 mapLength;
#else
    #ifdef MVT_USE_VERTEX_COLOR
        varying vec4 vColor;
    #endif
#endif

uniform vec4 color;
uniform float opacity;

#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {
    #ifdef USE_MAP
        gl_FragColor = texture2D(map, vec2(mod(vUv.x, mapLength.x) / mapLength.x, mod(vUv.y, mapLength.y) / mapLength.y));
    #else
        #ifdef MVT_USE_VERTEX_COLOR
            gl_FragColor = vColor;
        #else
            gl_FragColor = color;
        #endif
    #endif

    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #include <mvt_selective_fragment>
    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    
}

`,this.vertexShader=`#define GLSLIFY 1
#include <common>
#include <fog_pars_vertex>

#ifdef USE_MAP
    varying vec2 vUv;
    uniform float mapScale;
#else
    #ifdef MVT_USE_VERTEX_COLOR
        attribute vec4 aColor;
        varying vec4 vColor;
    #endif
#endif

#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>

void main() {

    #include <mvt_selective_vertex>

    #ifdef USE_MAP
        vUv = uv / mapScale;
    #else
        #ifdef MVT_USE_VERTEX_COLOR
            vColor = aColor;
        #endif
    #endif

    #include <begin_vertex>
    #include <project_vertex>

    #include <fog_vertex>
    #include <logdepthbuf_vertex>

}

`,Object.defineProperty(this,"mapSrc",{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,n=this.userData[this.urlCacheKey],r=this;if(n!==e){if(i&&i.dispose(),!e)return this.uniforms.map.value=null,delete this.defines.USE_MAP,void delete this.userData[this.urlCacheKey];kS.load(e,function(a){a.encoding=3001,r.uniforms.map.value=a,r.uniforms.mapLength.value=new j(a.image.naturalWidth,a.image.naturalHeight),r.userData[r.urlCacheKey]=e,r.defines.USE_MAP=!0,r.needsUpdate=!0})}}}),Object.assign(this.uniforms,pt.clone(NS)),t.mapSrc&&(this.mapSrc=t.mapSrc,delete t.mapSrc),jt(this,["opacity","mapScale","isEmissive"]),Bs(this,["color"]),Qe(this,[["vertexColors","MVT_USE_VERTEX_COLOR"]]),ns(this),ss(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class fs extends as{constructor(t){super(),d(this,"isEventEntitySupported",!0),d(this,"geometry"),d(this,"material"),d(this,"extrude"),d(this,"extrudeValue"),d(this,"color"),d(this,"vertexColors"),d(this,"emissive"),d(this,"opacity"),d(this,"mapSrc"),d(this,"mapScale"),this.parameters=t,this.defineGeometryProxyProperties(["extrude","extrudeValue","vertexHeights","enableBottomFace","zOffset"]),this.defineMaterialProxyProperties(["opacity","color","vertexColors","emissive","mapSrc","mapScale","side","depthWrite","colorWrite","stencilWrite","stencilFunc","stencilZFail","stencilZPass"])}initObject(){const{extrude:t,extrudeValue:e,vertexHeights:i,enableBottomFace:n,zOffset:r,...a}=this.parameters;this.geometry=new zS(this.parameters),(this.material=new US(a)).setCommonUniforms(this.engine.rendering.uniforms)}setData(){let t=this.dataSource.data;this.geometry.setData(t),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.needsUpdate=!1}afterGeometryUpdate(){this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox()}getEntityIndexByFace(t,e){return this.geometry.cachedObjectIndices[e]}raycast(t,e){lt.prototype.raycast.call(this,t,e)}}const U_=new rt,Qu=new vr,mh=new mi;class sr extends as{constructor(t){super(),d(this,"isEventEntitySupported",!0),d(this,"_dataSource",new ee),d(this,"geometry"),d(this,"material"),d(this,"lineJoin"),d(this,"lineCap"),d(this,"miterLimit"),d(this,"keepSize"),d(this,"color"),d(this,"vertexColors"),d(this,"emissive"),d(this,"map"),d(this,"opacity"),d(this,"alphaTest"),d(this,"dashed"),d(this,"dashArray"),d(this,"dashOffset"),d(this,"dashRatio"),d(this,"enbaleAnimation"),d(this,"enableAnimationChaos"),d(this,"animationSpeed"),d(this,"animationTailType"),d(this,"animationTailRatio"),d(this,"animationTailLength"),d(this,"animationIdle"),this.parameters=t,this.defineGeometryProxyProperties(["lineJoin","lineCap","miterLimit"]),this.defineMaterialProxyProperties(["map","mapGap","height","keepSize","opacity","alphaTest","dashed","dashArray","dashOffset","dashRatio","enableAnimation","enableAnimationChaos","animationInterval","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","color","vertexColors","vertexWidths","emissive"])}createVolumeDataSource(){const{data:t,userData:e,_attributeMap:i}=this.dataSource;let n=1;if(this.keepSize){const l=this.engine.map.getZoomUnits();l===Math.min()||Number.isNaN(l)||(n=l)}const r={position:this.geometry.createVolumeGeometry(t.position,n),index:t.index,payload:e},a=new ee;let o=i.keys();for(let l of o){const h=i.get(l);typeof h=="string"?a.setAttribute(l,h):a.setAttribute(l)}return a.setData(r),a}specifiedVolumeClass(){this._VolumeClass=fs}getDefaultParams(){return{lineWidth:4}}initObject(){const{lineJoin:t,lineCap:e,...i}=this.parameters;this.geometry=new MS(this.parameters),(this.material=new TS(i)).setCommonUniforms(this.engine.rendering.uniforms)}setData(){const t=this.dataSource.data;this.geometry.setData(t),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.needsUpdate=!1}get lineWidth(){return this.parameters.lineWidth}set lineWidth(t){this.parameters.lineWidth=t}raycast(t,e){const i=this.geometry,n=this.matrixWorld,r=t.params.Line.threshold,a=i.drawRange;let o=this.lineWidth/2;if(this.material.keepSize&&(o*=this.material.uniforms.zoomUnits.value),i.boundingSphere===null&&i.computeBoundingSphere(),mh.copy(i.boundingSphere),mh.applyMatrix4(n),mh.radius+=o,t.ray.intersectsSphere(mh)===!1)return;U_.copy(n).invert(),Qu.copy(t.ray).applyMatrix4(U_);const l=o/((this.scale.x+this.scale.y+this.scale.z)/3),h=l*l,c=new M,u=new M,p=new M,m=new M;if(i.isBufferGeometry){const f=i.index,g=i.attributes,_=g.position,v=g.objectIndex;if(f!==null)for(let x=Math.max(0,a.start),y=Math.min(f.count,a.start+a.count)-1;x<y;x+=2){const b=f.getX(x),S=f.getX(x+1);if(c.fromBufferAttribute(_,b),u.fromBufferAttribute(_,S),Qu.distanceSqToSegment(c,u,m,p)>h)continue;m.applyMatrix4(this.matrixWorld);const w=t.ray.origin.distanceTo(m);w<t.near||w>t.far||e.push({distance:w,point:p.clone().applyMatrix4(this.matrixWorld),index:v.getX(b),face:null,faceIndex:null,object:this})}else for(let x=Math.max(0,a.start),y=Math.min(_.count,a.start+a.count)-1;x<y;x+=2){if(c.fromBufferAttribute(_,x),u.fromBufferAttribute(_,x+1),Qu.distanceSqToSegment(c,u,m,p)>h)continue;m.applyMatrix4(this.matrixWorld);const b=t.ray.origin.distanceTo(m);b<t.near||b>t.far||e.push({distance:b,point:p.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}t.params.Line.threshold=r}}class FS extends Pt{constructor(t){super(),d(this,"isWallGeometry",!0),d(this,"_needsUpdate",!1),this.parameters=t}setData(t){this._needsUpdate=!0,this.cachedData=t,this.updateGeometry()}updateGeometry(){let t=this.cachedData;const e=[],i=[],n=[],r=[],a=[],o=[],l=[];for(let h=0;h<t.position.length;h++){const c=t.position[h];t.index[h];const u=this.parameters.vertexColors?Yi(t.color[h]):Yi(this.parameters.color),p=this.parameters.vertexHeights?t.height[h]:this.parameters.height;let m=0;const f=c.length;let g=e.length/3;for(let _=0;_<f;_++){const v=c[_],x=[c[_][0],c[_][1],c[_][2]+p],y=_<f-1?c[_+1]:null;if((!y||!oo(v,y))&&(e.push(...v,...x),o.push(...u,...u),n.push(_/(f-1),_/(f-1)),a.push(m,m),i.push(m,0,m,1),_<f-1)){m+=ds(v,y);let b=g+2*_;r.push(b,b+2,b+1,b+1,b+2,b+3)}}for(let _=0;_<f;_++)l.push(m,m);g+=2*f}this.cachedPositions=e,this.setAttribute("position",new et(e,3)),this.setAttribute("uv",new et(i,2)),this.setAttribute("counter",new et(n,1)),this.setAttribute("distances",new et(a,1)),this.setAttribute("totalDistance",new et(l,1)),this.parameters.vertexColors&&this.setAttribute("aColor",new et(o,4)),this.setIndex(r),this.computeBoundingSphere(),this._needsUpdate=!1}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}const BS=new Ie,VS=pt.merge([ot.fog,ki,is,{map:{value:null},useMap:{value:!1},uColor:{value:[0,1,1,1]},minOpacity:{value:0},maxOpacity:{value:1},opacity:{value:1},vertexColors:{value:!1},elapsedTime:{value:0},enableAnimation:{value:!1},animationSpeed:{value:1},animationTailType:{value:3},animationTailRatio:{value:.2},animationTailLength:{value:100},animationIdle:{value:1e3},animationRatio:{value:.5},animationBales:{value:5},isEmissive:{value:!1}}]);class HS extends Be{constructor(t){super(),this.type="WallMaterial",this.isWallMaterial=!0,this.fog=!0,this.transparent=!0,this.depthWrite=!1,this.side=ce,this.fragmentShader=`#define GLSLIFY 1
#include <common>
#include <bsdfs>
#include <fog_pars_fragment>

#include <logdepthbuf_pars_fragment>
varying vec3 vLightFront;
varying vec3 vIndirectFront;

uniform sampler2D map;
uniform bool useMap;
uniform float minOpacity;
uniform float maxOpacity;
uniform float opacity;
uniform float elapsedTime;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vDistance;
varying float vTotalDistance;

#ifdef USE_ANIMATION
uniform float animationRatio;
uniform float animationBales;
uniform float animationSpeed;
varying float vAnimationOpacity;
varying float vAnimationTailType;
#endif

void main() {

    vec4 c = vColor;

    if(useMap) {
        vec4 texture = texture2D(map, vec2(vUV.x / vTotalDistance, vUV.y));
        c *= texture;
    }

    #ifdef USE_ANIMATION
        if (vAnimationOpacity > 1.0 || vAnimationOpacity < 0.0) {
            c.a = 0.0;
        }

        if(vAnimationTailType == 4.) {
            float ratio = animationRatio;
            float bales = animationBales;
            if(animationRatio > 1.) {
                ratio = 1.;
            }
            if(animationRatio < .0) {
                ratio = .0;
            }
            if(animationBales < 1.) {
                bales = 1.;
            }
            if(mod((vUV.y - elapsedTime * animationSpeed * .0001), 1./bales) < ratio / bales) {
                c.a = (1. - vUV.y) * maxOpacity;
            } else {
                c.a = minOpacity;
            }
        } else {
            c.a *= vAnimationOpacity;
        }
    #endif

    gl_FragColor = c;
    gl_FragColor.a *= opacity;

    if (maxOpacity > minOpacity) {
        gl_FragColor.a = clamp(gl_FragColor.a, minOpacity, maxOpacity);
    }

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
#include <bsdfs>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#ifdef USE_A_COLOR
attribute vec4 aColor;
#endif

attribute float counter;
attribute float totalDistance;
attribute float distances;

uniform float elapsedTime;
uniform bool vertexColors;
uniform vec4 uColor;
uniform float opacity;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vDistance;
varying float vTotalDistance;

#ifdef USE_ANIMATION
uniform float animationSpeed;
uniform float animationTailType;
varying float vAnimationTailType;
uniform float animationTailRatio;
uniform float animationTailLength;
uniform float animationIdle;
varying float vAnimationOpacity;
#endif

void main() {

    #ifdef USE_A_COLOR
        vColor = aColor;
    #else
        vColor = uColor;
    #endif

    vUV = uv;
    vCounter = counter;
    vDistance = distances;
    vTotalDistance = totalDistance;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    #ifdef USE_ANIMATION
        if (animationTailType < 3.0) {
            float tailLength = animationTailType == 1.0 ? totalDistance * animationTailRatio : animationTailLength;
            float currentLength = mod(elapsedTime * animationSpeed, totalDistance + tailLength + animationIdle * animationSpeed);
            vAnimationOpacity = (distances - (currentLength - tailLength)) / tailLength;
        }
        else if (animationTailType == 3.0) {
            vAnimationOpacity = 1.0 - mod(elapsedTime * animationSpeed / 1000.0, 1.0) + uv.y;
        } 
        else if (animationTailType == 4.0) {
            vAnimationTailType = animationTailType;
        }
    #endif

    #include <beginnormal_vertex>
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    #include <fog_vertex>

    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,pt.clone(VS)),jt(this,["map","minOpacity","maxOpacity","opacity","elapsedTime","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","animationBales","animationRatio","isEmissive"]),_i(this,[["color","uColor",es]]),Qe(this,[["vertexColors","USE_A_COLOR"],["enableAnimation","USE_ANIMATION"]]),ss(this),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,n="url_map";if(this.userData[n]===e)return;if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[n];const r=BS.load(e);r.wrapS=r.wrapT=ue,this.uniforms.map.value=r,this.userData[n]=e,this.uniforms.useMap.value=!0}}}),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class F_ extends as{constructor(t){super(),d(this,"geometry"),d(this,"material"),d(this,"height"),d(this,"color"),d(this,"vertexColors"),d(this,"emissive"),d(this,"map"),d(this,"opacity"),d(this,"minOpacity"),d(this,"maxOpacity"),d(this,"enableAnimation"),d(this,"animationSpeed"),d(this,"animationTailType"),d(this,"animationTailRatio"),d(this,"animationTailLength"),d(this,"animationIdle"),d(this,"animationRatio"),d(this,"animationBales"),this.parameters=t,this.defineGeometryProxyProperties(["height"]),this.defineMaterialProxyProperties(["color","vertexColors","emissive","map","opacity","minOpacity","maxOpacity","enableAnimation","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","animationBales","animationRatio"])}getDefaultParams(){return{height:100}}initObject(){const{height:t,...e}=this.parameters;this.geometry=new FS(this.parameters),(this.material=new HS(e)).setCommonUniforms(this.engine.rendering.uniforms)}setData(){const t=this.dataSource.data;this.geometry.setData(t),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.needsUpdate=!1}}class jS extends rh{constructor(t){super(t),d(this,"isLightSphereGeometry",!0),d(this,"_needsUpdate",!1),d(this,"setModelData",()=>{this._needsUpdate=!0,this.updateGeometry()}),this.type="LightSphereGeometry",this.parameters=t,this.setModelData()}updateGeometry(){const t=[],e=[],i=[],n=[];let r=this.parameters.radius||10,a=this.parameters.widthSegments||32,o=this.parameters.heightSegments||16,l=this.parameters.phiStart||0,h=this.parameters.phiLength||2*Math.PI,c=this.parameters.thetaStart||0,u=this.parameters.thetaLength||Math.PI;this.parameters.widthSegments=Math.max(3,Math.floor(a)),this.parameters.heightSegments=Math.max(2,Math.floor(o));const p=Math.min(c+u,Math.PI);let m=0;const f=[],g=new M,_=new M;for(let v=0;v<=o;v++){const x=[],y=v/o;let b=0;v===0&&c===0?b=.5/a:v===o&&p===Math.PI&&(b=-.5/a);for(let S=0;S<=a;S++){const w=S/a;g.x=-r*Math.cos(l+w*h)*Math.sin(c+y*u),g.y=r*Math.cos(c+y*u),g.z=r*Math.sin(l+w*h)*Math.sin(c+y*u),e.push(g.x,g.y,g.z),_.copy(g).normalize(),i.push(_.x,_.y,_.z),n.push(w+b,1-y),x.push(m++)}f.push(x)}for(let v=0;v<o;v++)for(let x=0;x<a;x++){const y=f[v][x+1],b=f[v][x],S=f[v+1][x],w=f[v+1][x+1];(v!==0||c>0)&&t.push(y,b,w),(v!==o-1||p<Math.PI)&&t.push(b,S,w)}this.setIndex(t),this.setAttribute("position",new et(e,3)),this.setAttribute("normal",new et(i,3)),this.setAttribute("uv",new et(n,2)),this._needsUpdate=!1}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}const GS=pt.merge([{color:{value:[0,.7,1,1]},isEmissive:{value:!1}}]);class WS extends sn{constructor(t){super(t),d(this,"type","LightSphereMaterial"),d(this,"isLightSphereMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

varying vec3 vNormal;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

void main() {
    vNormal = normalize(normalMatrix * normal); // 顶点的法向量执行插值计算
    if (animationEffect) {
        float scaleRatio = mod(elapsedTime, animationEffectPeriod) / animationEffectPeriod;
        float t = sin(scaleRatio * 2.0 * PI) * 0.5 + 0.5;
        vec3 newPosition = mix(position, position * 2.0, t);
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(newPosition, 1.0);
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
    }
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

varying vec3 vNormal;
uniform vec4 color;

void main() {
    vec3 z = vec3(0.0, 0.0, 1.0); // z轴方向单位向量
    float x = abs(dot(vNormal, z)); // 点乘结果余弦值绝对值范围[0,1]
    float alpha = pow(1.0 - x, 2.0);
    gl_FragColor = vec4(vec3(color[0], color[1], color[2]), alpha);
}`,Object.assign(this.uniforms,pt.clone(GS)),jt(this,["maxHeight","isEmissive"]),this.setValues(t)}}class $u extends rh{constructor(t){super(t),d(this,"_needsUpdate",!1),d(this,"setModelData",()=>{this._needsUpdate=!0,this.updateGeometry()}),this.parameters={...t,radiusTop:t.radiusTop||t.radius||6,radiusBottom:t.radiusBottom||t.radius||6,height:t.height||50,openEnded:t.openEnded||!1,color:t.color||[80,20,170,.8],isLight:t.isLight||!0,lightPos:t.lightPos||60},this.parameters.radialSegments=t.radialSegments?Math.floor(t.radialSegments):4,this.parameters.heightSegments=t.heightSegments?Math.floor(t.heightSegments):1,this.setModelData()}updateGeometry(){const t=[],e=[],i=[],n=[],r=[];let a={index:0,indexArray:[],halfHeight:0,groupStart:0};this.generateTorso(t,e,i,n,r,a),this.parameters.openEnded===!1&&(this.parameters.radiusTop>0&&this.generateCap(!0,t,e,i,n,r,a),this.parameters.radiusBottom>0&&this.generateCap(!1,t,e,i,n,r,a)),this.addCustomGeometry(t,e,i,n,r,a),this.setIndex(t),this.setAttribute("position",new et(e,3)),this.setAttribute("normal",new et(i,3)),this.setAttribute("uv",new et(n,2)),this.addCustomAttribute(r),this._needsUpdate=!1}addCustomGeometry(){}addCustomAttribute(){}generateCap(t,e,i,n,r,a,o){}generateTorso(t,e,i,n,r,a){}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}class XS extends $u{constructor(t){super(t),this.type="GridGeometry",this.parameters.multiColor=t.multiColor||[],this.parameters.isMultiColor=t.isMultiColor||!1}generateTorso(t,e,i,n,r,a){const o=new M,l=new M;let h=0;const c=(this.parameters.radiusBottom-this.parameters.radiusTop)/this.parameters.height;for(let u=0;u<=this.parameters.heightSegments;u++){const p=[],m=u/this.parameters.heightSegments,f=(1-m)*this.parameters.radiusBottom+m*this.parameters.radiusTop;for(let g=0;g<=this.parameters.radialSegments;g++){const _=g/this.parameters.radialSegments,v=2*_*Math.PI,x=Math.sin(v),y=Math.cos(v);l.x=f*x,l.y=f*y,l.z=m*this.parameters.height,e.push(l.x,l.y,l.z),this.parameters.isMultiColor&&Array.isArray(this.parameters.multiColor)&&this.addMultiColors("torso",r,l.z),o.set(x,y,c).normalize(),i.push(o.x,o.y,o.z),n.push(_,m),p.push(a.index++)}a.indexArray.push(p)}for(let u=0;u<this.parameters.radialSegments;u++)for(let p=0;p<this.parameters.heightSegments;p++){const m=a.indexArray[p][u],f=a.indexArray[p+1][u],g=a.indexArray[p+1][u+1],_=a.indexArray[p][u+1];t.push(m,f,_),t.push(f,g,_),h+=6}this.addGroup(a.groupStart,h,0),a.groupStart+=h}generateCap(t,e,i,n,r,a,o){const l=o.index,h=new j,c=new M;let u=0;const p=t===!0?this.parameters.radiusTop:this.parameters.radiusBottom,m=t===!0?1:0,f=t?1:-1;for(let _=1;_<=this.parameters.radialSegments;_++)this.parameters.isMultiColor&&Array.isArray(this.parameters.multiColor)&&this.addMultiColors("cap",a,this.parameters.height*m),i.push(0,0,this.parameters.height*m),n.push(0,0,f),r.push(.5,.5),o.index++;const g=o.index;for(let _=0;_<=this.parameters.radialSegments;_++){const v=2*(_/this.parameters.radialSegments)*Math.PI,x=Math.cos(v),y=Math.sin(v);c.x=p*y,c.y=p*x,c.z=this.parameters.height*m,i.push(c.x,c.y,c.z),this.parameters.isMultiColor&&Array.isArray(this.parameters.multiColor)&&this.addMultiColors("cap",a,c.z),n.push(0,0,f),h.x=.5*x+.5,h.y=.5*y*m+.5,r.push(h.x,h.y),o.index++}for(let _=0;_<this.parameters.radialSegments;_++){const v=l+_,x=g+_;t===!0?e.push(x,x+1,v):e.push(x+1,x,v),u+=3}this.addGroup(o.groupStart,u,t===!0?1:2),o.groupStart+=u}addCustomAttribute(t){this.parameters.isMultiColor&&this.setAttribute("mColor",new et(t,4))}addMultiColors(t,e,i){const n=this.parameters.multiColor.map(r=>Yi(r));if(t==="cap")i===this.parameters.height?e.push(...n[n.length-1]):e.push(...n[0]);else if(t==="torso"&&this.parameters.heightSegments<=n.length){const r=this.parameters.height/this.parameters.heightSegments;for(let a=0;a<=this.parameters.heightSegments;a++)i===r*a&&e.push(...n[a])}}}const qS=pt.merge([{color:{value:[0,.7,.9,1]},lightPos:{value:60},isEmissive:{value:!1}}]);class YS extends sn{constructor(t){super(t),d(this,"type","GridMaterial"),d(this,"isGridMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec4 mColor;

varying vec3 vPosition;
varying vec4 vColor;
uniform vec4 color;

void main() {

    #ifdef USE_MULTICOLOR
        vColor = mColor;
    #else
        vColor = color;
    #endif

    vPosition = position;

    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

varying vec3 vPosition;
uniform vec4 color;
uniform float lightPos;
varying vec4 vColor;

void main() {

    #ifdef USE_LIGHT
        float a = 1.0 - vPosition.z / lightPos;
        if (a <= 0.) {
            discard;
        }
    #else
        float a = 1.0;
    #endif
    
    gl_FragColor = vec4(vec3(vColor[0], vColor[1], vColor[2]), a);
}`,this.side=ce,this.transparent=!0,Object.assign(this.uniforms,pt.clone(qS)),jt(this,["lightPos","isEmissive"]),Qe(this,[["isMultiColor","USE_MULTICOLOR"],["isLight","USE_LIGHT"]]),this.setValues(t)}}class ZS extends $u{constructor(t){super(t),this.type="PillarGeometry"}generateTorso(t,e,i,n,r,a){const o=new M,l=new M;let h=0;for(let c=0;c<=this.parameters.heightSegments;c++){const u=[],p=c/this.parameters.heightSegments,m=this.parameters.radius;for(let f=0;f<=this.parameters.radialSegments;f++){const g=f/this.parameters.radialSegments,_=2*g*Math.PI,v=Math.sin(_),x=Math.cos(_);l.x=m*v,l.y=m*x,this.parameters.vertexHeights?l.z=p:l.z=p*this.parameters.height,e.push(l.x,l.y,l.z),o.set(v,x,0).normalize(),i.push(o.x,o.y,o.z),n.push(g,p),u.push(a.index++)}a.indexArray.push(u)}for(let c=0;c<this.parameters.radialSegments;c++)for(let u=0;u<this.parameters.heightSegments;u++){const p=a.indexArray[u][c],m=a.indexArray[u+1][c],f=a.indexArray[u+1][c+1],g=a.indexArray[u][c+1];t.push(p,m,g),t.push(m,f,g),h+=6}this.addGroup(a.groupStart,h,0),a.groupStart+=h}generateCap(t,e,i,n,r,a,o){const l=o.index,h=new M;let c=0;const u=this.parameters.radius,p=t===!0?1:0,m=t?1:-1;for(let g=1;g<=this.parameters.radialSegments;g++)this.parameters.vertexHeights?i.push(0,0,p):i.push(0,0,p*this.parameters.height),n.push(0,0,m),r.push(.5,p),o.index++;const f=o.index;for(let g=0;g<=this.parameters.radialSegments;g++){const _=2*(g/this.parameters.radialSegments)*Math.PI,v=Math.cos(_),x=Math.sin(_);h.x=u*x,h.y=u*v,this.parameters.vertexHeights?h.z=p:h.z=p*this.parameters.height,i.push(h.x,h.y,h.z),n.push(0,0,m),r.push(.5,p),o.index++}for(let g=0;g<this.parameters.radialSegments;g++){const _=l+g,v=f+g;t===!0?e.push(v,v+1,_):e.push(v+1,v,_),c+=3}this.addGroup(o.groupStart,c,t===!0?1:2),o.groupStart+=c}}const JS=pt.merge([{color:{value:[0,.7,.9,1]},lightPos:{value:60},gradientMap:{value:null},maxHeight:{value:50},vertexHeights:{value:!1},isEmissive:{value:!1}}]);class KS extends sn{constructor(t){super(t),d(this,"type","PillarMaterial"),d(this,"isGridMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float maxHeight;
varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);

    #ifdef MVT_USE_VERTEX_HEIGHT
        float instanceHeight = instanceMatrix[2][2];
        vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));
    #else
        vUv = uv;
    #endif

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D gradientMap;
uniform float opacity;

varying vec2 vUv;

#include <logdepthbuf_pars_fragment>
void main() {
    gl_FragColor = texture2D(gradientMap, vUv.yx);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment>
}`,this.side=ce,this.transparent=!0,jt(this,["maxHeight","isEmissive"]),Qe(this,[["vertexHeights","MVT_USE_VERTEX_HEIGHT"]]),Object.assign(this.uniforms,pt.clone(JS)),this._cachedGradient=null,Object.defineProperties(this,{gradient:{get:function(){return this._cachedGradient},set:function(e){this._cachedGradient=e,this.updateGradientMap()}}}),this.createGradientMap(),this.uniforms.gradientMap.value=this._cachedGradientMap,this.setValues(t)}createGradientMap(){let t=document.createElement("canvas");t.width=64,t.height=2;let e=t.getContext("2d"),i=e.createLinearGradient(0,0,64,0);i.addColorStop(0,"rgba(0,0,255,1)"),i.addColorStop(.3,"rgba(0,255,0,1)"),i.addColorStop(.6,"rgba(255,255,0,1)"),i.addColorStop(1,"rgba(255,0,0,1)"),e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap=new Le(t)}updateGradientMap(){let t=this._cachedGradient;if(Object.prototype.toString.call(t)!=="[object Object]")return;let e=this._cachedGradientMap.image.getContext("2d");e.clearRect(0,0,64,2);let i=e.createLinearGradient(0,0,64,0);for(const n in t)Object.hasOwnProperty.call(t,n)&&i.addColorStop(n,t[n]);e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap.needsUpdate=!0}dispose(){this._cachedGradientMap&&this._cachedGradientMap.dispose(),super.dispose()}}class QS extends $u{constructor(t){super(t),this.type="PillarGeometry"}addRadiusFunc(t){return 1-Math.sqrt(t)}generateTorso(t,e,i,n,r,a){const o=new M;let l=0;for(let h=0;h<=this.parameters.heightSegments;h++){const c=[],u=h/this.parameters.heightSegments;let p=this.addRadiusFunc(u);this.parameters.vertexSizes||(p*=this.parameters.size);for(let m=0;m<=this.parameters.radialSegments;m++){const f=m/this.parameters.radialSegments,g=2*f*Math.PI,_=Math.sin(g),v=Math.cos(g);o.x=p*_,o.y=p*v,this.parameters.vertexHeights?o.z=u:o.z=u*this.parameters.height,e.push(o.x,o.y,o.z),n.push(f,u),c.push(a.index++)}a.indexArray.push(c)}for(let h=0;h<this.parameters.radialSegments;h++)for(let c=0;c<this.parameters.heightSegments;c++){const u=a.indexArray[c][h],p=a.indexArray[c+1][h],m=a.indexArray[c+1][h+1],f=a.indexArray[c][h+1];t.push(u,p,f),t.push(p,m,f),l+=6}this.addGroup(a.groupStart,l,0),a.groupStart+=l}generateCap(t,e,i,n,r,a,o){if(t)return;const l=o.index,h=new M;let c=0;const u=this.parameters.vertexSizes?1:this.parameters.size,p=t===!0?1:0;for(let f=1;f<=this.parameters.radialSegments;f++)this.parameters.vertexHeights?i.push(0,0,p):i.push(0,0,p*this.parameters.height),r.push(.5,p),o.index++;const m=o.index;for(let f=0;f<=this.parameters.radialSegments;f++){const g=2*(f/this.parameters.radialSegments)*Math.PI,_=Math.cos(g),v=Math.sin(g);h.x=u*v,h.y=u*_,this.parameters.vertexHeights?h.z=p:h.z=p*this.parameters.height,i.push(h.x,h.y,h.z),r.push(.5,p),o.index++}for(let f=0;f<this.parameters.radialSegments;f++){const g=l+f,_=m+f;t===!0?e.push(_,_+1,g):e.push(_+1,_,g),c+=3}this.addGroup(o.groupStart,c,t===!0?1:2),o.groupStart+=c}generateTopSphere(t,e,i,n,r,a){this.parameters.sphereIndex=a.index;const o=new M,l=a.indexArray.length;let h=0;for(let c=0;c<=16;c++){const u=c*Math.PI/16,p=Math.sin(u),m=Math.cos(u),f=[];for(let g=0;g<=32;g++){const _=2*g*Math.PI/32,v=Math.sin(_),x=Math.cos(_);o.x=10*v*p,o.y=10*x*p,o.z=10*m,this.parameters.vertexHeights||(o.z+=this.parameters.height),e.push(o.x,o.y,o.z),n.push(.5,1),f.push(a.index++)}a.indexArray.push(f)}for(let c=0;c<16;c++)for(let u=0;u<32;u++){const p=l+c,m=a.indexArray[p][u+1],f=a.indexArray[p][u],g=a.indexArray[p+1][u],_=a.indexArray[p+1][u+1];t.push(m,f,_),t.push(f,g,_),h+=6}this.addGroup(a.groupStart,h,0),a.groupStart+=h}addCustomGeometry(t,e,i,n,r,a){this.generateTopSphere(t,e,i,n,r,a)}}const $S=pt.merge([{isEmissive:{value:!1},color:{value:[0,.7,.9,1]},gradientMap:{value:null},maxHeight:{value:50},sphereIndex:{value:0},vertexHeights:{value:!1}}]);class t2 extends sn{constructor(t){super(t),d(this,"type","PillarMaterial"),d(this,"isGridMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float maxHeight;
uniform int sphereIndex;
varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() {
    // 球体和非球体部分使用不同的规则
    if(gl_VertexID < sphereIndex) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
    } else {
        float xOffset = instanceMatrix[3][0];
        float yOffset = instanceMatrix[3][1];
        float height = instanceMatrix[2][2];
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + xOffset
        , position.y + yOffset
        , position.z + height, 1.0);
    }
    
    #ifdef MVT_USE_VERTEX_HEIGHT
        float instanceHeight = instanceMatrix[2][2];
        vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));
    #else
        vUv = uv;
    #endif

    #include <logdepthbuf_vertex>
}
`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D gradientMap;
uniform float opacity;

varying vec2 vUv;

#include <logdepthbuf_pars_fragment>
void main() {
    gl_FragColor = texture2D(gradientMap, vUv.yx);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment>
}`,this.side=Fn,this.transparent=!0,jt(this,["maxHeight","sphereIndex","isEmissive"]),Qe(this,[["vertexHeights","MVT_USE_VERTEX_HEIGHT"]]),Object.assign(this.uniforms,pt.clone($S)),this._cachedGradient=null,Object.defineProperties(this,{gradient:{get:function(){return this._cachedGradient},set:function(e){this._cachedGradient=e,this.updateGradientMap()}}}),this.createGradientMap(),this.uniforms.gradientMap.value=this._cachedGradientMap,this.setValues(t)}createGradientMap(){let t=document.createElement("canvas");t.width=64,t.height=2;let e=t.getContext("2d"),i=e.createLinearGradient(0,0,64,0);i.addColorStop(0,"rgba(0,0,255,1)"),i.addColorStop(.3,"rgba(0,255,0,1)"),i.addColorStop(.6,"rgba(255,255,0,1)"),i.addColorStop(1,"rgba(255,0,0,1)"),e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap=new Le(t)}updateGradientMap(){let t=this._cachedGradient;if(Object.prototype.toString.call(t)!=="[object Object]")return;let e=this._cachedGradientMap.image.getContext("2d");e.clearRect(0,0,64,2);let i=e.createLinearGradient(0,0,64,0);for(const n in t)Object.hasOwnProperty.call(t,n)&&i.addColorStop(n,t[n]);e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap.needsUpdate=!0}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const B_=new Us,e2=new ai(new M(0,0,1),0),fh=new M;class td extends St{constructor(t={}){super(t),d(this,"_container"),d(this,"_point"),d(this,"_dom"),d(this,"_div"),d(this,"_visible"),d(this,"_offset"),d(this,"_stopPropagation",!1),d(this,"_enableDragging"),d(this,"handleMouseDown",e=>{const i=this.engine.rendering.canvas.getBoundingClientRect();this._sub=new j().set(this._screenPos.x-e.x+i.left,this._screenPos.y-e.y+i.top),(this.stopPropagation||this.enableDragging)&&e.stopPropagation(),this.dom.addEventListener(vt.MOVE,this.handleMouseMove)}),d(this,"handleMouseUp",e=>{this.dom.removeEventListener(vt.MOVE,this.handleMouseMove)}),d(this,"handleMouseMove",e=>{e.preventDefault();const i=this.engine,n=i.rendering.canvas.getBoundingClientRect(),r=e.clientX+this._sub.x-n.left,a=e.clientY+this._sub.y-n.top,o=r/n.width*2-1,l=1-2*a/n.height;B_.setFromCamera({x:o,y:l},i.rendering.camera),B_.ray.intersectPlane(e2,fh);const h=[fh.x,fh.y,fh.z],c=i.map.unprojectPointArr(h);this.point=[c[0],c[1],this.point[2]]}),d(this,"handleWheel",e=>{(this.stopPropagation||this.enableDragging)&&e.stopPropagation()}),this.isDOMOverlay=!0,this.parameters=t,this._point=t.point||[],this._offset=t.offset||[0,0],this._className=t.className||"",this._enableDragging=t.enableDragging||!1,this._visible=!("visible"in t)||t.visible,this._div=document.getElementById(`${te}-overlay`),this._div||(this._div=document.createElement("div"),this._div.id=`${te}-overlay`,xt(this._div,`${te}-overlay-pane`))}afterAddToEngine(t){this.engine=t;const e=t.container,i=e instanceof HTMLElement||e&&typeof e=="object"&&e.nodeType===1&&typeof e.nodeName=="string";this._container=i?e:e.container||e._container,document.getElementById(`${te}-overlay`)||this._container.appendChild(this._div),this.dom=this.initDom(),this.point=this._point,this.offset=this._offset,this.className=this._className,this.enableDragging=this._enableDragging,this.visible=this._visible,this.afterInit()}beforeRemoveFromEngine(t){this.dispose()}initDom(){if(this.parameters.dom)return this.parameters.dom;console.warn("`DOMOverlay` must contain a property `dom`.")}afterInit(){}onBeforeScenePrepareRender(t,e,i){if(this.dom&&this.visible){this.camera=i,this.renderer=t.renderer;let n=new j;t.renderer.getSize(n);const r=this.position.clone().project(i),a=(1+r.x)*n.x/2,o=(1-r.y)*n.y/2,l=this.dom.clientWidth,h=this.dom.clientHeight;let c,u,p=a-l/2+this.offset[0],m=a+l/2+this.offset[0];if(this.isPopup?(c=o-h+this.offset[1],u=o+this.offset[1]):(c=o-h/2+this.offset[1],u=o+h/2+this.offset[1]),m<0||p>n.x||u<0||c>n.y)return void(this.dom.style.visibility!=="hidden"&&(this.dom.style.visibility="hidden"));if(this.dom.style.position="absolute",this.dom.style.visibility==="hidden"&&(this.dom.style.visibility="visible"),this.dom.style.left=p+"px",this.dom.style.top=c+"px",this.enableDragging){const f=new M(this.position.x,this.position.y,0).clone().project(i),g=(1+f.x)*n.x/2,_=(1-f.y)*n.y/2;this._screenPos=new j().set(g,_)}}}onDispose(){}dispose(){this.onDispose(),this.enableDragging&&(this.dom.removeEventListener(vt.DOWN,this.handleMouseDown),this.dom.removeEventListener(vt.UP,this.handleMouseUp)),this.dom.removeEventListener("wheel",this.handleWheel),this.dom.remove(),this._div.childElementCount===0&&this._div.remove()}get dom(){return this._dom}set dom(t){if(this._dom&&(this.enableDragging&&(this._dom.removeEventListener(vt.DOWN,this.handleMouseDown),this._dom.removeEventListener(vt.UP,this.handleMouseUp)),this._div.removeChild(this._dom)),typeof t=="string"){const e=document.createElement("div");xt(e,`${te}-dom-overlay-custom`);const i=new DOMParser().parseFromString(t,"text/html").body.children;for(let n=0;n<i.length;n++)e.appendChild(i.item(n));this._dom=e}else this._dom=t;this._div.appendChild(this._dom),this._dom.style.visibility=this.visible?"visble":"hidden",this.enableDragging&&(this._dom.addEventListener(vt.DOWN,this.handleMouseDown),this._dom.addEventListener(vt.UP,this.mouseup),this._dom.style.cursor="pointer"),this._dom.addEventListener("wheel",this.handleWheel)}get point(){return this._point}set point(t){Array.isArray(t)&&t.length>1&&(this._point=t,this.engine&&this.position.set(...this.engine.map.projectPointArr(t)))}get visible(){return this._visible}set visible(t){t!==this._visible&&(this._visible=t,this.dom&&(this.dom.style.visibility=t?"visible":"hidden"))}get offset(){return this._offset}set offset(t){this._offset=t}get stopPropagation(){return this._stopPropagation}set stopPropagation(t){this._stopPropagation=t}get enableDragging(){return this._enableDragging}set enableDragging(t){this._enableDragging!==t&&(this._enableDragging=t,this.dom&&(t?(this.dom.addEventListener(vt.DOWN,this.handleMouseDown),this.dom.addEventListener(vt.UP,this.handleMouseUp),this.dom.style.cursor="pointer"):(this.dom.removeEventListener(vt.DOWN,this.handleMouseDown),this.dom.removeEventListener(vt.UP,this.handleMouseUp),this.dom.style.cursor="auto")))}get className(){return this._className}set className(t){t!==this._className&&(this.dom&&(this._className&&function(e,i){if(i)if(e.className===i)e.removeAttribute("class");else{const n=e.className.split(/ +/),r=n.indexOf(i);r!==-1&&(n.splice(r,1),e.className=n.join(" "))}else e.className=void 0}(this.dom,this._className),xt(this.dom,t)),this._className=t)}}const i2={pars:`
        uniform float minAltitude;
        uniform float maxAltitude;
        #ifdef USE_NOISE_MAP
            varying vec2 vWorldXy;
        #endif
    `,main_after:`
        vUv.x = (clamp(position.y, minAltitude, maxAltitude) - minAltitude) / (maxAltitude - minAltitude);
        vUv.y = 0.5;
        #ifdef USE_NOISE_MAP
            vWorldXy = worldPosition.xy;
        #endif
    `},n2={pars:`
        #ifdef USE_NOISE_MAP
            uniform sampler2D noiseMap;
            uniform float noiseUvScale;
            uniform float noiseScale;
            uniform float noiseBais;
            varying vec2 vWorldXy;
        #endif
    `,main_before:`
        #ifdef USE_NOISE_MAP
            vec2 noiseUv = mod(vWorldXy, 1000.0) * noiseUvScale;
            uv.x = clamp(uv.x + noiseScale * (texture2D(noiseMap, noiseUv).y + noiseBais), 0.0, 1.0);
        #endif
    `,color_after:`
    // diffuseColor.x = uv.x;
    // diffuseColor.y = 0.0;
    // diffuseColor.z = 0.0;
    `},fa=new Wi(0,0,0,"ZXY"),ga=new M,s2={type:"change"},r2={type:"lock"},a2={type:"unlock"},V_=Math.PI/2;class o2 extends pn{constructor(t,e){super(),e===void 0&&(console.warn('THREE.PointerLockControls: The second parameter "domElement" is now mandatory.'),e=document.body),this.domElement=e,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1;const i=this;function n(o){if(i.isLocked===!1)return;const l=o.movementX||o.mozMovementX||o.webkitMovementX||0,h=o.movementY||o.mozMovementY||o.webkitMovementY||0;fa.setFromQuaternion(t.quaternion),fa.z-=.002*l*i.pointerSpeed,fa.x-=.002*h*i.pointerSpeed,fa.x=Math.max(V_-i.maxPolarAngle,Math.min(V_-i.minPolarAngle,fa.x)),t.quaternion.setFromEuler(fa),i.dispatchEvent(s2)}function r(){i.domElement.ownerDocument.pointerLockElement===i.domElement?(i.dispatchEvent(r2),i.isLocked=!0):(i.dispatchEvent(a2),i.isLocked=!1)}function a(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}this.connect=function(){i.domElement.ownerDocument.addEventListener("mousemove",n),i.domElement.ownerDocument.addEventListener("pointerlockchange",r),i.domElement.ownerDocument.addEventListener("pointerlockerror",a)},this.disconnect=function(){i.domElement.ownerDocument.removeEventListener("mousemove",n),i.domElement.ownerDocument.removeEventListener("pointerlockchange",r),i.domElement.ownerDocument.removeEventListener("pointerlockerror",a)},this.dispose=function(){this.disconnect()},this.getObject=function(){return t},this.getDirection=function(){const o=new M(0,0,-1);return function(l){return l.copy(o).applyQuaternion(t.quaternion)}}(),this.moveForward=function(o){ga.setFromMatrixColumn(t.matrix,0),ga.crossVectors(t.up,ga),t.position.addScaledVector(ga,o)},this.moveRight=function(o){ga.setFromMatrixColumn(t.matrix,0),t.position.addScaledVector(ga,o)},this.lock=function(){this.domElement.requestPointerLock()},this.unlock=function(){i.domElement.ownerDocument.exitPointerLock()},this.connect()}}const H_="follow",l2="lock",h2="unlock",c2="keyFrame",u2="activeFrame";class yo extends St{constructor(){super(...arguments),d(this,"_enabled",!1),d(this,"_drawedGraph",[]),d(this,"_transformBox",null),d(this,"_trnasformIndex",null),d(this,"_completedDataSource",null),d(this,"_completedElement",null),d(this,"_selectedIndex",-1),d(this,"_stage",0),d(this,"_isAdd",!1)}afterAddToEngine(){this.initObjects()}initObjects(){}initEvents(){}reset(){this.clearBuffers(),this._trnasformIndex=null,this._transformBox=null,this._stage=0}clearAll(){this.complete(),this._drawedGraph=[],this._completedDataSource.setData(),this._engine.requestRender()}attachTransform(t,e="z"){const i=new oe(1,1,1),n=new ae;this._transformBox=new lt(i,n),this._transformBox.position.set(...t);let r=this._getNodeNormal(this._transformIndex).angle();this._transformBox.rotation[e]=r,this._transformBox.scale.set(2,2,2),this._engine.add(this._transformBox),this._transformBox.visible=!1,this._engine.selection.attachTransform(this._transformBox)}detachTransform(){this._transformBox&&(this._engine.selection.transformControl.removeEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.removeEventListener("mouseUp",this._handleTransformChanged),this._engine.selection.detachTransform(),this._engine.remove(this._transformBox),this._transformBox=null)}_getTransformBoxState(){const t=this._transformBox,e=new M,i=new M,n=new Ht,r=new Wi;t.matrixWorld.decompose(e,n,i),r.setFromQuaternion(n);const a=this._engine,o=[e.x,e.y,e.z],l=a.map.unprojectPointArr(o),h=[r.x,r.y,r.z],c=i.x,u=i.y;return{point:l,position:o,width:c,height:i.z,length:u,angle:h}}clearBuffers(){}unbindEvents(){}_getNodeNormal(){return new j(0,0)}complete(){if(this._stage!==1&&this._enabled){if(this._isAdd){const t=this.graphInfo(this.drawedGraph.length);this._drawedGraph.push(t)}else if(this._selectedIndex!==-1){const t=this.graphInfo(this._selectedIndex);this._drawedGraph.splice(this._selectedIndex,1,t)}this._completedDataSource.setData();for(let t=0;t<this._drawedGraph.length;t++)this._completedDataSource.add(this._drawedGraph[t].dataItem);this.detachTransform(),this.reset(),this.clearBuffers(),this.clearObjects(),this._engine.event.unbind(this._helpers,"click",this._handleNodeClick),this.initEvents(),this._isAdd=!1,this._selectedIndex=-1,this._engine.requestRender()}}graphInfo(){}get drawedGraph(){return this._drawedGraph}get selectedIndex(){return this._selectedIndex}get enabled(){return this._enabled}set enabled(t){t!==this._enabled&&(t?(this._selectedIndex=-1,this.reset(),this.initEvents()):(this.complete(),this.detachTransform(),this.unbindEvents(),this.clearObjects()),this._enabled=t)}exportToGeoJSON(){const t=[];let e;if(this.drawedGraph.length>0){const i=this.drawedGraph[0].dataItem.position;e=this._completedDataSource._getDataTypeByCoordinates(i)}for(let i=0;i<this.drawedGraph.length;i++){const{attributes:n}=this.drawedGraph[i].dataItem;let r;Array.isArray(n)?(r=n.map(a=>a.point),e==="Polygon"&&(r=[r])):r=n.point,t.push({type:"Feature",geometry:{type:e,coordinates:r},properties:this._getProperties(n)})}return{type:"FeatureCollection",features:t}}_getProperties(t){return{}}}class ed extends yo{constructor(t,e={}){super(),d(this,"_virtualLineBuffer",{position:[[]],index:[],payload:[]}),d(this,"_splineBuffer",{position:[[]],index:[],payload:[]}),d(this,"_helpersBuffer",{position:[],index:[],payload:[]}),d(this,"_engine"),d(this,"_options"),d(this,"_virtualLine"),d(this,"_virtualLineDataSource"),d(this,"_helpers"),d(this,"_helpersDataSource"),d(this,"_spline"),d(this,"_splineDataSource"),d(this,"_completedDataSource"),d(this,"_completedElement"),d(this,"_isAdd"),d(this,"_selectedIndex"),d(this,"_stage"),d(this,"_transformIndex"),d(this,"_lastDataItem"),d(this,"_handleCompleteClick",i=>{if(this._stage!==1){this.complete(),this._selectedIndex=i.entity.value.index,this._engine.event.unbind("click",this._handleAddClick),this._lastDataItem=this._drawedGraph.slice(this._selectedIndex,this._selectedIndex+1),this._stage=2,this._completedDataSource.setData();for(let n=0;n<this._drawedGraph.length;n++)n!==this._selectedIndex&&this._completedDataSource.add(this._drawedGraph[n].dataItem);this._splineBuffer=this._lastDataItem[0].splineBuffer,this._splineDataSource.setData(this._splineBuffer),this._helpersBuffer=this._lastDataItem[0].helpersBuffer,this._helpersDataSource.setData(this._helpersBuffer),this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.requestRender()}}),d(this,"_handleAddClick",i=>{this._isAdd=!0;let n=this.length;if(this._stage===0||this._stage===1){if(this._stage=1,this.length>2&&oo(i.position,this._helpersBuffer.position.slice(-1)[0]))return this.addNode(n,i.position,i.point),void this._handleAddFinish();this.addNode(n,i.position,i.point),this.dispatchEvent({type:"addNode",value:this.data}),this._engine.event.bind("mousemove",this._handleAddMove)}this._engine.requestRender()}),d(this,"_handleAddMove",i=>{let n=this._helpersBuffer.position[this.length-1],r=i.position;this._virtualLineBuffer.position[0]=[n,r],this._virtualLineBuffer.index=[0],this._virtualLineDataSource.setData(this._virtualLineBuffer),this.dispatchEvent({type:"moveNode",value:r})}),d(this,"_handleAddFinish",i=>{if(this.length!==2){if(this._stage===1){this._stage=2;let n=this.length-1;this._virtualLineDataSource.setData(),this.removeNode(n);for(let r=0;r<this.length;r++)this._splineBuffer.payload[r].angle=this._getNodeNormal(r).angle();this.dispatchEvent({type:"change",value:this.data})}this._engine.requestRender(),this._engine.event.unbind("click",this._handleAddClick),this._engine.event.unbind("mousemove",this._handleAddMove),this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit)}}),d(this,"_handleNodeClick",i=>{i.domEvent?i.event.domEvent.preventDefault():i.event.preventDefault(),!i.entity||this._stage!==2&&this._stage!==3||(this._transformIndex=i.entity.index,this.attachTransform(i.entity.position),this._stage=3,this._engine.selection.transformControl.addEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.addEventListener("mouseUp",this._handleTransformChanged))}),d(this,"_handleTransformChanging",i=>{let n=this._getTransformBoxState();if(this._stage===3)if(this._transformIndex===0){let r=n.position,a=this._helpersBuffer.position[this._transformIndex+1];this._virtualLineBuffer.position[0]=[r,a],this._virtualLineBuffer.index=[0],this._virtualLineDataSource.setData(this._virtualLineBuffer)}else if(this._transformIndex===this.length-1){let r=this._helpersBuffer.position[this._transformIndex-1],a=n.position;this._virtualLineBuffer.position[0]=[r,a],this._virtualLineBuffer.index=[0],this._virtualLineDataSource.setData(this._virtualLineBuffer)}else{let r=this._helpersBuffer.position[this._transformIndex-1],a=n.position,o=this._helpersBuffer.position[this._transformIndex+1];this._virtualLineBuffer.position[0]=[r,a,o],this._virtualLineBuffer.index=[0,1],this._virtualLineDataSource.setData(this._virtualLineBuffer)}this._stage!==3&&this._stage!==4||(this.updateNode(this._transformIndex,n),this.dispatchEvent({type:"change",value:this.data}),this._stage=4)}),d(this,"_handleTransformChanged",i=>{let n=this._getTransformBoxState();this._stage===4&&(this.updateNode(this._transformIndex,n),this._virtualLineDataSource.setData(),this.dispatchEvent({type:"change",value:this.data}),this._stage=3)}),d(this,"_handleCancelEdit",i=>{this._stage===3&&(this.detachTransform(),this._stage=2)}),this._engine=t,e.lineColor||(e.lineColor="rgb(200, 200, 50)"),this._options=e}initSpline(){let t=this._splineDataSource=new ee,e=this._spline=this._engine.add(new sr({lineWidth:3,color:this._options.lineColor,keepSize:!0,lineJoin:"round"}));return e.dataSource=t,e}initVirtualLine(){let t=this._virtualLineDataSource=new ee,e=this._virtualLine=this._engine.add(new sr({lineWidth:2,color:this._options.lineColor,opacity:.2,keepSize:!0,lineJoin:"round"}));return e.dataSource=t,e}initHelpers(){let t=this._helpersDataSource=new ee,e=this._helpers=this._engine.add(new po({color:"rgba(0, 0, 0, 0)",mapSrc:Jt("assets/images/node.png"),size:10,uShapeType:1}));return e.dataSource=t,e}initCompeleteElement(){let t=this._completedDataSource=new ee,e=this._completedElement=this._engine.add(new sr({lineWidth:3,color:this._options.lineColor,keepSize:!0,lineJoin:"round"}));e.dataSource=t,this._engine.event.bind(e,"click",this._handleCompleteClick)}initObjects(){this.initSpline(),this.initHelpers(),this.initVirtualLine(),this.initCompeleteElement()}initEvents(){this._engine.event.bind("click",this._handleAddClick),this._drawedGraph.length>0&&(this._engine.event.bind("click",this._handleCancelEdit),this._engine.event.bind(this._completedElement,"click",this._handleCompleteClick))}graphInfo(t){const e=new Ni(this._splineBuffer.position[0],this._splineBuffer.payload);return e.index=t,{splineBuffer:this._splineBuffer,helpersBuffer:this._helpersBuffer,dataItem:e}}_getNodeNormal(t){if(t===0)return Ze(Ye(this._helpersBuffer.position[t],this._helpersBuffer.position[t+1]));if(t===this.length-1)return Ze(Ye(this._helpersBuffer.position[t-1],this._helpersBuffer.position[t]));let e=this._helpersBuffer.position[t-1],i=this._helpersBuffer.position[t],n=this._helpersBuffer.position[t+1],r=Ye(e,i),a=Ye(i,n),o=new j;return o.addVectors(r,a),Ze(o)}addNode(t,e,i){this._splineBuffer.position[0].splice(t,0,e),this._splineBuffer.payload.splice(t,0,{point:i,position:e,scale:2}),this._splineBuffer.index.push(this.length),this._splineDataSource.setData(this._splineBuffer),this._helpersBuffer.position.splice(t,0,e),this._helpersBuffer.payload.splice(t,0,{point:i,position:e,scale:2}),this._helpersBuffer.index.push(this.length),this._helpersDataSource.setData(this._helpersBuffer)}removeNode(t){this._splineBuffer.position[0].splice(t,1),this._splineBuffer.payload.splice(t,1),this._splineBuffer.index.pop(),this._splineDataSource.setData(this._splineBuffer),this._helpersBuffer.position.splice(t,1),this._helpersBuffer.payload.pop(),this._helpersBuffer.index.pop(),this._helpersDataSource.setData(this._helpersBuffer)}updateNode(t,e){let{point:i,position:n}=e;this._splineBuffer.position[0].splice(t,1,n),this._splineBuffer.payload.splice(t,1,{point:i,position:n,scale:e.width,angle:e.angle[2]}),this._splineDataSource.setData(this._splineBuffer),this._helpersBuffer.position.splice(t,1,n),this._helpersBuffer.payload.splice(t,1,{point:i,position:n,scale:e.width,angle:e.angle[2]}),this._helpersDataSource.setData(this._helpersBuffer)}overwriteNodes(t){this.clearBuffers();for(let e=0;e<t.length;e++){const i=t[e];this._splineBuffer.position[0].push(i.position),this._splineBuffer.index.push(e),this._helpersBuffer.position.push(i.position),this._helpersBuffer.index.push(e)}this._splineBuffer.payload=t,this._helpersBuffer.payload=t,this._splineDataSource.setData(this._splineBuffer),this._helpersDataSource.setData(this._helpersBuffer)}unbindEvents(){this._engine.event.unbind("click",this._handleAddClick),this._engine.event.unbind("click",this._handleCancelEdit),this._engine.event.unbind("mousemove",this._handleAddMove),this._engine.event.unbind(this._helpers,"click",this._handleNodeClick),this._engine.event.unbind(this._completedElement,"click",this._handleCompleteClick),this._engine.selection.transformControl.removeEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.removeEventListener("mouseUp",this._handleTransformChanged)}clearBuffers(){this._virtualLineBuffer={position:[[]],index:[],payload:[]},this._splineBuffer={position:[[]],index:[],payload:[]},this._helpersBuffer={position:[],index:[],payload:[]}}clearObjects(){this._splineDataSource.setData(),this._helpersDataSource.setData(),this._virtualLineDataSource.setData(),this._engine.requestRender()}dispose(){this.enabled=!1,this._engine.remove(this._spline),this._engine.remove(this._helpers),this._engine.remove(this._virtualLine)}set data(t){this.overwriteNodes(t),this._handleCancelEdit(),this._stage=2,this._isAdd=!0,this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit),this.dispatchEvent({type:"change",value:t}),this._engine.requestRender()}get data(){return this._splineBuffer.payload}get length(){return this._helpersBuffer.index.length}}class j_ extends yo{constructor(t,e={}){super(),d(this,"_circleBuffer",{position:[],index:[],payload:[]}),d(this,"_virtualLineBuffer",{position:[[]],index:[],payload:[]}),d(this,"_helpersBuffer",{position:[],index:[],payload:[]}),d(this,"_hasBeenMove",!1),d(this,"_engine"),d(this,"_options"),d(this,"_circle"),d(this,"_circleDataSource"),d(this,"_virtualLine"),d(this,"_virtualLineDataSource"),d(this,"_helpers"),d(this,"_helpersDataSource"),d(this,"_completedDataSource"),d(this,"_completedElement"),d(this,"_isAdd"),d(this,"_selectedIndex"),d(this,"_stage"),d(this,"_transformIndex"),d(this,"_lastDataItem"),d(this,"_handleCompleteClick",i=>{if(this._stage!==1){this.complete(),this._selectedIndex=i.entity.value.index,this._engine.event.unbind("click",this._handleAddClick),this._lastDataItem=this._drawedGraph.slice(this._selectedIndex,this._selectedIndex+1),this._stage=2,this._completedDataSource.setData();for(let n=0;n<this._drawedGraph.length;n++)n!==this._selectedIndex&&this._completedDataSource.add(this._drawedGraph[n].dataItem);this._circleBuffer=this._lastDataItem[0].circleBuffer,this._circleDataSource.setData(this._circleBuffer),this._virtualLineBuffer=this._lastDataItem[0].virtualLineBuffer,this._virtualLineDataSource.setData(this._virtualLineBuffer),this._helpersBuffer=this._lastDataItem[0].helpersBuffer,this._helpersDataSource.setData(this._helpersBuffer),this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.requestRender()}}),d(this,"_handleAddClick",i=>{this._isAdd=!0,this._hasBeenMove=!1,this._stage!==0&&this._stage!==1||(this._stage=1,this.addNode(i.position,i.point),this.dispatchEvent({type:"addNode",value:this.data}),this._engine.event.unbind("click",this._handleAddClick),this._engine.event.bind("mousemove",this._handleAddMove),this._engine.event.bind("click",this._handleAddFinish))}),d(this,"_handleAddFinish",i=>{this._hasBeenMove&&(this._stage===1&&(this._stage=2),this.dispatchEvent({type:"change",value:this.data}),this._engine.requestRender(),this._engine.event.unbind("click",this._handleAddFinish),this._engine.event.unbind("mousemove",this._handleAddMove),this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit))}),d(this,"_handleNodeClick",i=>{i.domEvent?i.event.domEvent.preventDefault():i.event.preventDefault(),!i.entity||this._stage!==2&&this._stage!==3||(this._transformIndex=i.entity.index,this.attachTransform(i.entity.position),this._transformIndex?this._engine.selection.transformControl.showZ=!1:this._engine.selection.transformControl.showZ=!0,this._stage=3,this._engine.selection.transformControl.addEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.addEventListener("mouseUp",this._handleTransformChanged))}),d(this,"_handleTransformChanging",i=>{let n=this._getTransformBoxState();if(this._stage===3||this._stage===4){if(this._transformIndex===0)this.moveNode(n);else{this.adjustRadius(n);let r=this._getNodeNormal().angle();this._transformBox.rotation.z=r}this.dispatchEvent({type:"change",value:this.data}),this._stage=4}}),d(this,"_handleTransformChanged",i=>{this._stage===4&&(this.dispatchEvent({type:"change",value:this.data}),this._stage=3)}),d(this,"_handleCancelEdit",i=>{this._stage===3&&(this.detachTransform(),this._engine.selection.transformControl.showZ=!0,this._stage=2)}),d(this,"_handleAddMove",i=>{const n=this._helpersBuffer.position[0],r=i.position,a=this.calcLength(n,r);this._circleBuffer.payload[0].size=2*a,this._circleDataSource.setData(this._circleBuffer),this._helpersBuffer.position[1]=r,this._helpersBuffer.payload[1]={position:r,point:i.point,scale:2},this._helpersBuffer.index[1]=1,this._helpersDataSource.setData(this._helpersBuffer),this._virtualLineBuffer.position[0]=this._helpersBuffer.position,this._virtualLineBuffer.index=this._helpersBuffer.index,this._virtualLineDataSource.setData(this._virtualLineBuffer),this.dispatchEvent({type:"moveNode",value:this.data}),this._hasBeenMove=!0}),this._engine=t,e.circleColor||(e.circleColor="rgb(200, 200, 50)"),this._options=e}initObjects(){this.initCircle(),this.initvirtualLine(),this.initHelper(),this.initCompletedElement()}initCircle(){let t=this._circleDataSource=new ee,e=this._circle=this._engine.add(new Yu({color:this._options.circleColor,borderWidth:0,opacity:.3,vertexSizes:!0}));t.setAttribute("size"),e.dataSource=t}initvirtualLine(){let t=this._virtualLineDataSource=new ee;(this._virtualLine=this._engine.add(new sr({lineWidth:2,keepSize:!0}))).dataSource=t}initHelper(){let t=this._helpersDataSource=new ee;(this._helpers=this._engine.add(new po({color:"rgba(0, 0, 0, 0)",mapSrc:Jt("assets/images/node.png"),size:10,uShapeType:1}))).dataSource=t}initCompletedElement(){let t=this._completedDataSource=new ee,e=this._completedElement=this._engine.add(new Yu({color:this._options.circleColor,borderWidth:0,opacity:.3,vertexSizes:!0}));t.setAttribute("size").setAttribute("selectedIndex"),e.dataSource=t,this._engine.event.bind(e,"click",this._handleCompleteClick)}graphInfo(t){const e=new Ni(this._circleBuffer.position[0],this._circleBuffer.payload[0]);return e.index=t,{circleBuffer:this._circleBuffer,virtualLineBuffer:this._virtualLineBuffer,helpersBuffer:this._helpersBuffer,dataItem:e}}initEvents(){this._engine.event.bind("click",this._handleAddClick),this._drawedGraph.length>0&&(this._engine.event.bind("click",this._handleCancelEdit),this._engine.event.bind(this._completedElement,"click",this._handleCompleteClick))}_getNodeNormal(){return Ze(Ye(this._helpersBuffer.position[0],this._helpersBuffer.position[1]))}calcLength(t,e){let i=Math.pow(Math.abs(t[0]-e[0]),2),n=Math.pow(Math.abs(t[1]-e[1]),2),r=Math.pow(Math.abs(t[2]-e[2]),2);return Math.pow(i+n+r,.5)}addNode(t,e){this._circleBuffer.position[0]=t,this._circleBuffer.payload[0]={point:e,position:t,scale:2,size:0},this._circleBuffer.index=[0],this._helpersBuffer.position[0]=t,this._helpersBuffer.payload[0]={point:e,position:t,scale:2,size:0},this._helpersBuffer.index=[0]}moveNode(t){let{position:e,point:i}=t;this._circleBuffer.position[0]=e,this._circleBuffer.payload[0]={...this._circleBuffer.payload[0],position:e,point:i,scale:t.width},this._circleDataSource.setData(this._circleBuffer);const n=new M(...this._helpersBuffer.position[0]),r=new M(...this._helpersBuffer.payload[0].point),a=new M(...e),o=new M(...i),l=a.sub(n),h=o.sub(r);let c=this._helpersBuffer.position;for(let u=0,p=c.length;u<p;u++){const m=this._helpersBuffer.payload[u].point,f=new M(...c[u]).add(l),g=new M(...m).add(h);c[u]=f.toArray(),this._helpersBuffer.payload[u]={position:f,point:g,scale:t.width},this._virtualLineBuffer.position[0][u]=c[u]}this._helpersDataSource.setData(this._helpersBuffer),this._virtualLineDataSource.setData(this._virtualLineBuffer)}adjustRadius(t){const{position:e,point:i}=t,n=this._helpersBuffer.position[0],r=this.calcLength(n,e);this._circleBuffer.payload[0].size=2*r,this._circleDataSource.setData(this._circleBuffer),this._helpersBuffer.position[1]=e,this._helpersBuffer.payload[1]={position:e,point:i,scale:t.width},this._helpersBuffer.index[1]=1,this._helpersDataSource.setData(this._helpersBuffer),this._virtualLineBuffer.position[0]=this._helpersBuffer.position,this._virtualLineBuffer.index=this._helpersBuffer.index,this._virtualLineDataSource.setData(this._virtualLineBuffer)}unbindEvents(){this._engine.event.unbind("click",this._handleAddClick),this._engine.event.unbind("click",this._handleCancelEdit),this._engine.event.unbind("mousemove",this._handleCancelEdit),this._engine.event.unbind(this._helper,"click",this._handleNodeClick),this._engine.event.unbind(this._completedElement,"click",this._handleCompleteClick),this._engine.selection.transformControl.removeEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.removeEventListener("mouseUp",this._handleTransformChanged)}dispose(){this.enabled=!1,this._engine.remove(this._circle),this._engine.remove(this._virtualLine),this._engine.remove(this._helper)}clearBuffers(){this._circleBuffer={position:[],index:[],payload:[]},this._virtualLineBuffer={position:[[]],index:[],payload:[]},this._helpersBuffer={position:[],index:[],payload:[]}}clearObjects(){this._circleDataSource.setData(),this._virtualLineDataSource.setData(),this._helpersDataSource.setData(),this._engine.requestRender()}overwriteNodes(t){this.clearBuffers();const e=t[0].position;this._circleBuffer.position.push(e),this._circleBuffer.index[0]=0,this._circleBuffer.payload=t,this._helpersBuffer.position.push(e),this._helpersBuffer.payload.push(t[0]);const i=[e[0]+t[0].size/2,e[1],e[2]];this._helpersBuffer.position.push(i);const n={position:i,point:this._engine.map.unprojectPointArr(i),scale:t[0].scale};this._helpersBuffer.payload.push(n),this._helpersBuffer.index.push(0,1),this._virtualLineBuffer.position[0]=this._helpersBuffer.position,this._virtualLineBuffer.index=this._helpersBuffer.index,this._virtualLineDataSource.setData(this._virtualLineBuffer),this._circleDataSource.setData(this._circleBuffer),this._helpersDataSource.setData(this._helpersBuffer)}_getProperties(t){const{scale:e,size:i}=t;return{scale:e,size:i}}get data(){return this._circleBuffer.payload}set data(t){this.overwriteNodes(t),this._handleCancelEdit(),this._stage=2,this._isAdd=!0,this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit),this.dispatchEvent({type:"change",value:t}),this._engine.requestRender()}}class G_ extends yo{constructor(t,e={}){super(),d(this,"_rectBuffer",{position:[[[]]],index:[],payload:[]}),d(this,"_helpersBuffer",{position:[],index:[],payload:[]}),d(this,"_engine"),d(this,"_options"),d(this,"_rect"),d(this,"_rectDataSource"),d(this,"_helpers"),d(this,"_helpersDataSource"),d(this,"_helpers"),d(this,"_helpersDataSource"),d(this,"_completedDataSource"),d(this,"_completedElement"),d(this,"_isAdd"),d(this,"_selectedIndex"),d(this,"_stage"),d(this,"_transformIndex"),d(this,"_lastDataItem"),d(this,"_handleCompleteClick",i=>{if(this._stage!==1){this.complete(),this._selectedIndex=i.entity.value.index,this._engine.event.unbind("click",this._handleAddClick),this._lastDataItem=this._drawedGraph.slice(this._selectedIndex,this._selectedIndex+1),this._stage=2,this._completedDataSource.setData();for(let n=0;n<this._drawedGraph.length;n++)n!==this._selectedIndex&&this._completedDataSource.add(this._drawedGraph[n].dataItem);this._rectBuffer=this._lastDataItem[0].rectBuffer,this._rectDataSource.setData(this._rectBuffer),this._helpersBuffer=this._lastDataItem[0].helpersBuffer,this._helpersDataSource.setData(this._helpersBuffer),this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.requestRender()}}),d(this,"_handleAddClick",i=>{this._isAdd=!0,this._stage!==0&&this._stage!==1||(this._stage=1,this.addNode(i.position,i.point),this._engine.event.unbind("click",this._handleAddClick),this._engine.event.bind("mousemove",this._handleAddMove),this._engine.event.bind("click",this._handleAddFinish))}),d(this,"_handleAddMove",i=>{let n=this._helpersBuffer.position[0],r=this._rectBuffer.payload[0].point;const{position:a,point:o}=i,l=[[a[0],n[1],n[2]],a,[n[0],a[1],a[2]],n],h=[{point:[o[0],r[1],r[2]],position:l[0],scale:2},{point:o,position:l[1],scale:2},{point:[r[0],o[1],o[2]],position:l[2],scale:2},{point:r,position:l[3],scale:2}];this._rectBuffer.position[0][0].splice(1,4,...l),this._rectBuffer.payload.splice(1,4,...h),this._rectBuffer.index=[0,1,2,3,4],this._rectDataSource.setData(this._rectBuffer),this._helpersBuffer.position.splice(1,3,...l.slice(0,l.length-1)),this._helpersBuffer.payload=this._rectBuffer.payload.slice(0,4),this._helpersBuffer.index=[0,1,2,3],this._helpersDataSource.setData(this._helpersBuffer),this.dispatchEvent({type:"moveNode",value:this.data})}),d(this,"_handleAddFinish",i=>{if(!(this._rectBuffer.payload.length<5)){this._stage===1&&(this._stage=2);for(let n=0;n<5;n++)this._rectBuffer.payload[n].angle=this._getNodeNormal().angle();this.dispatchEvent({type:"change",value:this.data}),this._engine.requestRender(),this._engine.event.unbind("click",this._handleAddFinish),this._engine.event.unbind("mousemove",this._handleAddMove),this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit)}}),d(this,"_handleNodeClick",i=>{i.domEvent?i.event.domEvent.preventDefault():i.event.preventDefault(),!i.entity||this._stage!==2&&this._stage!==3||(this._transformIndex=i.entity.index,this.attachTransform(i.entity.position,"x"),this._stage=3,this._engine.selection.transformControl.addEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.addEventListener("mouseUp",this._handleTransformChanged))}),d(this,"_handleTransformChanging",i=>{let n=this._getTransformBoxState();if(this._stage===3||this._stage===4){this.updateNode(this._transformIndex,n);let r=this._getNodeNormal(this._transformIndex).angle();this._transformBox.rotation.x=r,this.dispatchEvent({type:"change",value:this.data}),this._stage=4}}),d(this,"_handleTransformChanged",i=>{this._stage===4&&(this.dispatchEvent({type:"change",value:this.data}),this._stage=3)}),d(this,"_handleCancelEdit",i=>{this._stage===3&&(this.detachTransform(),this._stage=2)}),this._engine=t,e.rectColor||(e.rectColor="rgb(200, 200, 50)"),this._options=e}initObjects(){this.initRect(),this.initHelpers(),this.initCompletedElement()}initRect(){let t=this._rectDataSource=new ee,e=this._rect=this._engine.add(new fs({color:this._options.rectColor}));return e.material.side=ce,e.dataSource=t,e}initHelpers(){let t=this._helpersDataSource=new ee,e=this._helpers=this._engine.add(new po({color:"rgba(0, 0, 0, 0)",mapSrc:Jt("assets/images/node.png"),size:10,uShapeType:1}));return e.dataSource=t,e}initCompletedElement(){let t=this._completedDataSource=new ee,e=this._completedElement=this._engine.add(new fs({color:this._options.rectColor}));e.material.side=ce,e.dataSource=t,this._engine.event.bind(e,"click",this._handleCompleteClick)}graphInfo(t){const e=new Ni(this._rectBuffer.position[0],this._rectBuffer.payload);return e.index=t,{rectBuffer:this._rectBuffer,helpersBuffer:this._helpersBuffer,dataItem:e}}initEvents(){this._engine.event.bind("click",this._handleAddClick),this._drawedGraph.length>0&&(this._engine.event.bind("click",this._handleCancelEdit),this._engine.event.bind(this._completedElement,"click",this._handleCompleteClick))}_getNodeNormal(){let t=new M().fromArray(this._helpersBuffer.position[0]),e=new M().fromArray(this._helpersBuffer.position[1]),i=new M().fromArray(this._helpersBuffer.position[2]),n=new M().subVectors(e,t),r=new M().subVectors(e,i),a=n.z*r.x-r.z*n.x,o=n.x*r.y-r.x*n.y;return new j(a,o).normalize()}addNode(t,e){this._rectBuffer.payload.push({point:e,position:t,scale:2}),this._rectBuffer.position[0][0].push(t),this._rectBuffer.index.push(0),this._helpersBuffer.position.push(t),this._helpersBuffer.index.push(0)}updateNode(t,e){let{position:i,point:n,width:r}=e,a=this._getNodeNormal().angle(),o=(t+2)%4;const{position:l,point:h}=this._rectBuffer.payload[o];let c=(4+t-1)%4,u=(4+t+1)%4,p=[i[0],l[1],l[2]],m=[l[0],i[1],i[2]],f={point:[n[0],h[1],h[2]],position:p,scale:r,angle:a},g={point:[h[0],n[1],n[2]],position:m,scale:r,angle:a};this._helpersBuffer.position[t]=i,this._rectBuffer.payload[t]={point:n,position:i,scale:r,angle:a},t%2?(this._helpersBuffer.position[c]=m,this._helpersBuffer.position[u]=p,this._rectBuffer.payload[c]=g,this._rectBuffer.payload[u]=f):(this._helpersBuffer.position[c]=p,this._helpersBuffer.position[u]=m,this._rectBuffer.payload[c]=f,this._rectBuffer.payload[u]=g),this._rectBuffer.position[0][0]=[...this._helpersBuffer.position,this._helpersBuffer.position[0]],this._rectBuffer.payload[4]=this._rectBuffer.payload[0],this._helpersBuffer.payload=this._rectBuffer.payload.slice(0,4),this._rectDataSource.setData(this._rectBuffer),this._helpersDataSource.setData(this._helpersBuffer)}clearBuffers(){this._rectBuffer={position:[[[]]],index:[],payload:[]},this._helpersBuffer={position:[],index:[],payload:[]}}clearObjects(){this._rectDataSource.setData(),this._helpersDataSource.setData(),this._engine.requestRender()}overwriteNodes(t){this.clearBuffers();for(let e=0;e<t.length;e++){const i=t[e];this._rectBuffer.position[0][0].push(i.position),this._rectBuffer.index[e],e!==t.length-1&&(this._helpersBuffer.payload.push(i),this._helpersBuffer.position.push(i.position),this._helpersBuffer.index.push(e))}this._rectBuffer.payload=t,this._rectDataSource.setData(this._rectBuffer),this._rectDataSource.setData(this._rectBuffer),this._helpersDataSource.setData(this._helpersBuffer)}unbindEvents(){this._engine.event.unbind("click",this._handleAddClick),this._engine.event.unbind("click",this._handleAddFinish),this._engine.event.unbind("mousemove",this._handleAddMove),this._engine.event.unbind(this._helpers,"click",this._handleNodeClick),this._engine.event.unbind(this._completedElement,"click",this._handleCompleteClick),this._engine.selection.transformControl.removeEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.removeEventListener("mouseUp",this._handleTransformChanged)}dispose(){this.enabled=!1,this._engine.remove(this._rect),this._engine.remove(this._helpers)}get data(){return this._rectBuffer.payload}set data(t){this.overwriteNodes(t),this._handleCancelEdit(),this._stage=2,this._isAdd=!0,this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit),this.dispatchEvent({type:"change",value:t})}}class W_ extends yo{constructor(t,e={}){super(),d(this,"_polygonOpacity",.6),d(this,"_virtualOpacity",.3),d(this,"_polygonBuffer",{position:[[[]]],index:[],payload:[]}),d(this,"_strokeLineBuffer",{position:[[]],index:[],payload:[]}),d(this,"_helpersBuffer",{position:[],index:[],payload:[]}),d(this,"_engine"),d(this,"_options"),d(this,"_polygon"),d(this,"_polygonDataSource"),d(this,"_strokeLine"),d(this,"_strokeLineDataSource"),d(this,"_helpers"),d(this,"_helpersDataSource"),d(this,"_completedDataSource"),d(this,"_completedElement"),d(this,"_isAdd"),d(this,"_selectedIndex"),d(this,"_stage"),d(this,"_transformIndex"),d(this,"_transformBox"),d(this,"_lastDataItem"),d(this,"_handleCompleteClick",i=>{if(this._stage!==1){this.complete(),this._selectedIndex=i.entity.value.index,this._engine.event.unbind("click",this._handleAddClick),this._lastDataItem=this._drawedGraph.slice(this._selectedIndex,this._selectedIndex+1),this._stage=2,this._completedDataSource.setData();for(let n=0;n<this._drawedGraph.length;n++)n!==this._selectedIndex&&this._completedDataSource.add(this._drawedGraph[n].dataItem);this._polygonBuffer=this._lastDataItem[0].polygonBuffer,this._polygonDataSource.setData(this._polygonBuffer),this._strokeLineBuffer=this._lastDataItem[0].strokeLineBuffer,this._strokeLineDataSource.setData(this._strokeLineBuffer),this._helpersBuffer=this._lastDataItem[0].helpersBuffer,this._helpersDataSource.setData(this._helpersBuffer),this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.requestRender()}}),d(this,"_handleAddClick",i=>{this._isAdd=!0;let n=this.length;if(this.stage===0||this.stage===1){if(this.stage=1,this.length>2&&oo(i.position,this._helpersBuffer.position.slice(-1)[0]))return this._polygonBuffer.payload.splice(-2),this._polygonBuffer.payload.push(this._polygonBuffer.payload[0]),this._polygonDataSource.setData(this._polygonBuffer),void this._handleAddFinish();this.length>0&&(this._strokeLineBuffer.index.splice(-2),this._strokeLineBuffer.position[0].splice(-2),this._strokeLineBuffer.payload.splice(-2)),this.addNode(n,i.position,i.point),this.dispatchEvent({type:"addNode",value:this.data}),this._engine.event.bind("mousemove",this._handleAddMove)}this._engine.requestRender()}),d(this,"_handleAddMove",i=>{let n=this._helpersBuffer.position[0],r=i.position;this._strokeLineBuffer.position[0].splice(this.length,2,r,n),this._strokeLineBuffer.index.splice(this.length,2,this.length,this.length+1),this._strokeLineDataSource.setData(this._strokeLineBuffer),this._polygonBuffer.position[0]=this._strokeLineBuffer.position,this._polygonBuffer.payload.splice(this.length,2,{point:i.point,position:r,scale:2},this._polygonBuffer.payload[0]),this._polygonBuffer.index=this._strokeLineBuffer.index,this._polygonDataSource.setData(this._polygonBuffer),this.dispatchEvent({type:"moveNode",value:this.data})}),d(this,"_handleAddFinish",i=>{if(this.stage===1){this.stage=2;for(let n=0;n<this.length;n++)this._polygonBuffer.payload[n].angle=this._getNodeNormal(n).angle();this.dispatchEvent({type:"change",value:this.data}),this._engine.requestRender(),this._engine.event.unbind("click",this._handleAddClick),this._engine.event.unbind("mousemove",this._handleAddMove),this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit)}}),d(this,"_handleNodeClick",i=>{i.domEvent?i.event.domEvent.preventDefault():i.event.preventDefault(),!i.entity||this.stage!==2&&this.stage!==3||(this._transformIndex=i.entity.index,this.attachTransform(i.entity.position),this.stage=3,this._engine.selection.transformControl.addEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.addEventListener("mouseUp",this._handleTransformChanged))}),d(this,"_handleTransformChanging",i=>{let n=this._getTransformBoxState();this.stage!==3&&this.stage!==4||(this.updateNode(this._transformIndex,n),this.dispatchEvent({type:"change",value:this.data}),this.stage=4)}),d(this,"_handleTransformChanged",i=>{let n=this._getTransformBoxState();this.stage===4&&(this.updateNode(this._transformIndex,n),this.dispatchEvent({type:"change",value:this.data}),this.stage=3)}),d(this,"_handleCancelEdit",i=>{this.stage===3&&(this.detachTransform(),this.stage=2)}),this._engine=t,e.polygonColor||(e.polygonColor="rgb(200, 200, 50)"),e.borderColor||(e.borderColor="rgb(200, 50, 50)"),this._options=e}initObjects(){this.initPolygon(),this.initStrokeLine(),this.initHelpers(),this.initCompletedElement()}initPolygon(){let t=this._polygonDataSource=new ee,e=this._polygon=this._engine.add(new fs({color:this._options.polygonColor,opacity:this._virtualOpacity}));return e.material.side=ce,e.dataSource=t,e}initStrokeLine(){let t=this._strokeLineDataSource=new ee,e=this._strokeLine=this._engine.add(new sr({lineWidth:3,color:this._options.borderColor,keepSize:!0,lineJoin:"round"}));return e.dataSource=t,e}initHelpers(){let t=this._helpersDataSource=new ee,e=this._helpers=this._engine.add(new po({color:"rgba(0, 0, 0, 0)",mapSrc:Jt("assets/images/node.png"),size:10,uShapeType:1}));return e.dataSource=t,e}initCompletedElement(){let t=this._completedDataSource=new ee,e=this._completedElement=this._engine.add(new fs({color:this._options.polygonColor,opacity:this._polygonOpacity}));e.material.side=ce,e.dataSource=t,this._engine.event.bind(e,"click",this._handleCompleteClick)}initEvents(){this._engine.event.bind("click",this._handleAddClick),this._drawedGraph.length>0&&(this._engine.event.bind("click",this._handleCancelEdit),this._engine.event.bind(this._completedElement,"click",this._handleCompleteClick))}graphInfo(t){let e=new Ni(this._polygonBuffer.position[0],this._polygonBuffer.payload);return e.index=t,{polygonBuffer:this._polygonBuffer,strokeLineBuffer:this._strokeLineBuffer,helpersBuffer:this._helpersBuffer,dataItem:e}}_getNodeNormal(t){let e,i,n;t===0||t?(t=0,e=this._helpersBuffer.position[this.length-1],i=this._helpersBuffer.position[t],n=this._helpersBuffer.position[t+1]):t===this.length-1?(e=this._helpersBuffer.position[t-1],i=this._helpersBuffer.position[t],n=this._helpersBuffer.position[0]):(e=this._helpersBuffer.position[t-1],i=this._helpersBuffer.position[t],n=this._helpersBuffer.position[t+1]);let r=Ye(e,i),a=Ye(i,n),o=new j;return o.addVectors(r,a),Ze(o)}addNode(t,e,i){this._strokeLineBuffer.position[0].push(e),this._strokeLineBuffer.index.push(t),this.length>0&&(this._strokeLineBuffer.position[0].push(this._helpersBuffer.position[0]),this._strokeLineBuffer.index.push(t+1)),this._strokeLineDataSource.setData(this._strokeLineBuffer),this._polygonBuffer.position[0]=this._strokeLineBuffer.position,this._polygonBuffer.index=this._strokeLineBuffer.index,this._polygonBuffer.payload.splice(t,0,{point:i,position:e,scale:2}),this._helpersBuffer.position.push(e),this._helpersBuffer.payload.splice(t,0,{point:i,position:e,scale:2}),this._helpersBuffer.index.push(t),this._helpersDataSource.setData(this._helpersBuffer)}updateNode(t,e){let{point:i,position:n}=e,r=this._strokeLineBuffer.position[0].length;this._transformIndex===0?(this._strokeLineBuffer.position[0].splice(0,1,n),this._strokeLineBuffer.position[0].splice(r-1,1,n),this._strokeLineBuffer.payload.splice(0,1,{point:i,position:n,scale:e.width,angle:e.angle[2]}),this._strokeLineBuffer.payload.splice(r-1,1,{point:i,position:n,scale:e.width,angle:e.angle[2]}),this._strokeLineDataSource.setData(this._strokeLineBuffer)):(this._strokeLineBuffer.position[0].splice(t,1,n),this._strokeLineDataSource.setData(this._strokeLineBuffer)),this._polygonBuffer.payload=this._strokeLineBuffer.payload,this._polygonBuffer.position[0]=this._strokeLineBuffer.position,this._polygonDataSource.setData(this._polygonBuffer),this._helpersBuffer.position.splice(t,1,n),this._helpersBuffer.payload.splice(t,1,{position:n,point:i,scale:e.width,angle:e.angle[2]}),this._helpersDataSource.setData(this._helpersBuffer)}overwriteNodes(t){this.clearBuffers();for(let e=0;e<t.length;e++){const i=t[e];this._polygonBuffer.position[0][0].push(i.position),this._polygonBuffer.index.push(e),this._strokeLineBuffer.position[0].push(i.position),this._strokeLineBuffer.index.push(e),e!==t.length-1&&(this._helpersBuffer.position.push(i.position),this._helpersBuffer.payload.push(i),this._helpersBuffer.index.push(e))}this._polygonBuffer.payload=t,this._strokeLineBuffer.payload=t,this._polygonDataSource.setData(this._polygonBuffer),this._strokeLineDataSource.setData(this._strokeLineBuffer),this._helpersDataSource.setData(this._helpersBuffer)}unbindEvents(){this._engine.event.unbind("click",this._handleAddClick),this._engine.event.unbind("click",this._handleCancelEdit),this._engine.event.unbind("mousemove",this._handleAddMove),this._engine.event.unbind(this._helpers,"click",this._handleNodeClick),this._engine.event.unbind(this._completedElement,"click",this._handleCompleteClick),this._engine.selection.transformControl.removeEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.removeEventListener("mouseUp",this._handleTransformChanged)}reset(){this.clearBuffers(),this._transformBox=null,this._transformIndex=null,this.stage=0}clearBuffers(){this._polygonBuffer={position:[[[]]],index:[],payload:[]},this._strokeLineBuffer={position:[[]],index:[],payload:[]},this._helpersBuffer={position:[],index:[],payload:[]}}clearObjects(){this._polygonDataSource.setData(),this._strokeLineDataSource.setData(),this._helpersDataSource.setData(),this._engine.requestRender()}dispose(){this.enabled=!1,this._engine.remove(this._polygon),this._engine.remove(this._strokeLine),this._engine.remove(this._helpers)}get stage(){return this._stage}set stage(t){this._polygon.opacity=t===2?this._polygonOpacity:this._virtualOpacity,this._stage=t}get data(){return this._polygonBuffer.payload}set data(t){this.overwriteNodes(t),this._handleCancelEdit(),this.stage=2,this._isAdd=!0,this._engine.event.bind(this._helpers,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit),this.dispatchEvent({type:"change",value:t}),this._engine.requestRender()}get length(){return this._helpersBuffer.index.length}}const X_=63710088e-1;class Nn extends St{constructor(){super(...arguments),d(this,"_enabled",!1),d(this,"_fixedNum",2),d(this,"_addNode",t=>{}),d(this,"_moveNode",t=>{}),d(this,"_changeNode",t=>{})}afterAddToEngine(){this.initEditor(),this.initInfoMarkers()}static getLength(t,e,i){i=i||X_;const{pointToLngLat:n}=Xe.prototype,r=Xe.toRadians,a=n(new Xr(...t)),o=n(new Xr(...e)),l=r(o.lat-a.lat)/2,h=r(o.lng-a.lng)/2,c=r(a.lat),u=r(o.lat),p=Math.sin(l)*Math.sin(l)+Math.sin(h/2)*Math.sin(h/2)*Math.cos(c)*Math.cos(u),m=i*(2*Math.atan2(Math.sqrt(p),Math.sqrt(1-p))),f=Math.abs(t[2]||0-e[2]||0);return Math.sqrt(Math.pow(m,2)+Math.pow(f,2))}static getSegementLength(t){if(t.length<2)return;const e=[];let i=t[0];for(let n=1,r=t.length;n<r;n++){let a=t[n];const o=Nn.getLength(i,a);e.push(o),i=a}return e}static getArea(t,e){e=e||X_;const i=Xe.toRadians,{pointToLngLat:n}=Xe.prototype;let r=0;const a=t.length;let{lng:o,lat:l}=n(new Xr(...t[a-1]));for(let c=0;c<a;c++){let{lng:u,lat:p}=n(new Xr(...t[c]));r+=i(u-o)*(2+Math.sin(i(l))+Math.sin(i(p))),o=u,l=p}const h=r*e*e/2;return Math.abs(h)}get fixedNum(){return this._fixedNum}set fixedNum(t){this._fixedNum=t}get enabled(){return this._enabled}set enabled(t){t!==this._enabled&&(this._editor.enabled=t,this._enabled=t,t?(this._editor.addEventListener("change",this._changeNode),this._editor.addEventListener("addNode",this._addNode),this._editor.addEventListener("moveNode",this._moveNode)):(this._editor.removeEventListener("change",this._changeNode),this._editor.addEventListener("addNode",this._addNode),this._editor.addEventListener("moveNode",this._moveNode)))}}class gh{constructor(t,e){d(this,"isClippingPlane",!0),this._distance=e,this._normal=t,this.index=-1}get distance(){return this._distance}set distance(t){this._distance=t}get normal(){return this._normal}set normal(t){this._normal=t}static fromPoint(t,e){const i=new j((t[0]+e[0])/2,(t[1]+e[1])/2),n=Ze(new j(t[0]-e[0],t[1]-e[1])).normalize(),r=i.dot(n);return new gh(new M(n.x,n.y,0),-r)}}class gs extends St{constructor(t,e={}){super(),d(this,"_planes",[]),d(this,"_dirtyIndex",-1),d(this,"_multipleDirtyPlanes",!1),d(this,"_enabled",!0),d(this,"_clippingPlanesTexture"),d(this,"_useFloatPointTexture",!0),d(this,"_uint8View"),d(this,"_float32View"),d(this,"isClippingPlaneCollection",!0),this._engine=t,this.options=Object.assign(this.getDefaultOptions(),e),this.modelMatrix=e.modelMatrix||new rt;const i=e.planes;if(i){const n=i.length;for(let r=0;r<n;r++)this.add(i[r])}}getDefaultOptions(){return{}}_setIndexDirty(t){this._multipleDirtyPlanes=this._multipleDirtyPlanes||this._dirtyIndex!==-1&&this._dirtyIndex!==t,this._dirtyIndex=t}_packPlanesAsFloats(t,e){const i=this._float32View;let n=4*t;for(let r=t;r<e;r++){const a=this._planes[r],o=a.normal;i[n]=o.x,i[n+1]=o.y,i[n+2]=o.z,i[n+3]=a.distance,n+=4}}_computeTextureResolution(t){const e=new j,i=this._engine.renderer.getContext(),n=i.getParameter(i.MAX_TEXTURE_SIZE);return e.x=Math.min(t,n),e.y=Math.ceil(t/e.x),e}update(){let t=this._clippingPlanesTexture;const e=this._useFloatPointTexture,i=this._useFloatPointTexture?this.length:2*this.length;if(t){const r=t.width*t.height;(r<i||i<.25*r)&&(t.dispose(),t=void 0,this._clippingPlanesTexture=void 0)}if(this.length===0)return;if(!t){const r=this._computeTextureResolution(i);r.y*=2,t=new Dr,t.format=$t,t.flipY=!1,t.minFilter=Ft,t.magFilter=Ft,t.image={width:r.x,height:r.y},t.width=r.x,t.height=r.y,e?(t.type=Ve,this._float32View=new Float32Array(r.x*r.y*4)):(t.type=Vn,this._uint8View=new Uint8Array(r.x*r.y*4)),this._clippingPlanesTexture=t,this._multipleDirtyPlanes=!0}const n=this._dirtyIndex;(this._multipleDirtyPlanes||this._dirtyIndex!==-1)&&(this._multipleDirtyPlanes?e&&(this._packPlanesAsFloats(0,this._planes.length),t.image={width:t.width,height:t.height,data:this._float32View},t.needsUpdate=!0,this.dispatchEvent({type:"update"})):e&&(this._packPlanesAsFloats(n,n+1),t.image.data=this._float32View,t.needsUpdate=!0,this.dispatchEvent({type:"update"})),this._multipleDirtyPlanes=!1,this._dirtyIndex=-1)}getTextureResolution(){const t=new j,e=this._clippingPlanesTexture;if(e)return t.x=e.image.width,t.y=e.image.height,t;const i=this._useFloatPointTexture?this.length:2*this.length,n=this._computeTextureResolution(i);return n.y*=2,n}destroy(){this._clippingPlanesTexture=this._clippingPlanesTexture&&this._clippingPlanesTexture.dispose()}add(t){const e=this._planes.length;t.index=e,this._setIndexDirty(e),this._planes.push(t)}remove(t){const e=this._planes,i=e.indexOf(t);if(i===-1)return!1;t.index=-1;const n=e.length-1;for(let r=i;r<n;r++){const a=e[r+1];e[r]=a,a.index=r}return this._multipleDirtyPlanes=!0,e.length=n,!0}removeAll(){const t=this._planes,e=t.length;for(let i=0;i<e;++i)t[i].index=-1;this._multipleDirtyPlanes=!0,this._planes=[]}static fromPoints(t,e,i={}){const n=[],r=e.length;for(let a=0;a<r;a++){const o=(a+1)%r,l=e[a],h=e[o],c=gh.fromPoint(l,h);n.push(c)}return new gs(t,{planes:n,edgeWidth:0,...i})}get(t){return this._planes[t]}get texture(){return this._clippingPlanesTexture}get length(){return this._planes.length}get enabled(){return this._enabled}set enabled(t){this._enabled!==t&&(this._enabled=t)}}class q_{constructor(t,e={}){d(this,"_multiCollections",[]),d(this,"_dataArrayBuffer",null),d(this,"_lengthArrayBuffer",null),d(this,"_dirty",!1),d(this,"_multiClippingPlanesTexture",null),d(this,"_lengthTexture",null),d(this,"_maxCollectionLength",0),d(this,"_totalPlanesCount",0),d(this,"_owner",!1),d(this,"_unionClipping"),d(this,"_enabled"),this._engine=t,this._options=Object.assign(this.getDefaultOptions(),e),this.edgeColor=this._options.edgeColor,this.edgeWidth=this._options.edgeWidth,this.unionClipping=this._options.unionClipping||!1,this._owner=this._options.owner,this._modelMatrix=e.modelMatrix||new rt,this._enabled=this._options.enabled||!0}getDefaultOptions(){return{edgeColor:"#ffffff",edgeWidth:1}}add(t){this._multiCollections.push(t),this._dirty=!0}get(t){return this._multiCollections[t]}contains(t){return this._multiCollections.findIndex(function(e){return e===t})!==-1}remove(t){const e=this._multiCollections,i=e.findIndex(function(n){return n===t});return i!==-1&&(e.splice(i,1),t instanceof gs&&t.destroy(),this._dirty=!0,!0)}removeAll(){this._multiCollections.forEach(function(t){t instanceof gs&&t.destroy()}),this._multiCollections=[],this._dirty=!0}update(){const t=this._multiCollections;if(t.forEach(function(e){e.enabled&&e.update()}),this._dirty){let e,i=0,n=!0,r=0,a=0;for(let o=0;o<t.length;o++){const l=t[o];r+=l.length,a=Math.max(a,l.length),e=l.texture.height,i+=l.texture.width,l.texture||(n=!0)}if(this._totalPlanesCount=r,this._maxCollectionLength=a,n&&t.length>0){this._dataArrayBuffer=new Float32Array(i*e*4),this._lengthArrayBuffer=new Float32Array(4*t.length);const o=this._dataArrayBuffer,l=this._lengthArrayBuffer;let h=0;t.forEach(function(p,m){const f=p._float32View;let g=0;for(let _=0;_<p.length;_++)o[h]=f[g],o[h+1]=f[g+1],o[h+2]=f[g+2],o[h+3]=f[g+3],g+=4,h+=4;l[4*m+3]=p.length});const c=new Dr;c.type=Ve,c.format=$t,c.flipY=!1,c.minFilter=Ft,c.magFilter=Ft,c.image={width:i,height:e,data:o},c.width=i,c.height=e;const u=new Dr;u.type=Ve,u.format=$t,u.flipY=!1,u.minFilter=Ft,u.magFilter=Ft,u.image={width:t.length,height:1,data:l},c.needsUpdate=!0,u.needsUpdate=!0,this._multiClippingPlanesTexture=c,this._lengthTexture=u}this._dirty=!1}}destroy(){this._multiCollections.forEach(function(t){t instanceof gs&&t.destroy()}),this._multiCollections=void 0,this.texture&&this.texture.dispose()}get length(){return this._multiCollections.length}get totalPlanesCount(){return this._totalPlanesCount}get texture(){return this._multiClippingPlanesTexture}get maxCollectionLength(){return this._maxCollectionLength}get lengthTexture(){return this._lengthTexture}get edgeWidth(){return this._edgeWidth}set edgeWidth(t){this._edgeWidth=t}get edgeColor(){return this._edgeColor}set edgeColor(t){this._edgeColor=t instanceof tt?t:new tt(t)}get edgeStyle(){const t=this.edgeColor;return new Lt(t.r,t.g,t.b,this._edgeWidth)}get dirty(){return this._dirty}get unionClipping(){return this._unionClipping}set unionClipping(t){this._unionClipping!==t&&(this._unionClipping=t)}get enabled(){return this._enabled}set enabled(t){this._enabled!==t&&(this._enabled=t)}get modelMatrix(){if(this._owner){const{cameraOffsetX:t,cameraOffsetY:e}=this._engine.rendering.renderState,i=new rt().makeTranslation(-t,-e,0);return new rt().multiplyMatrices(this._modelMatrix,i)}return this._modelMatrix}get clippingPlanesMatrix(){const t=new rt;return t.multiplyMatrices(this._engine.camera.matrixWorldInverse,this.modelMatrix),t.invert(),t.transpose(),t}}class d2 extends Ir{constructor(t,e,i,n){super(t,e,i,n)}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=t*n*3+n;for(let a=0;a!==n;a++)e[a]=i[r+a];return e}}d2.prototype.interpolate_=function(s,t,e,i){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=2*a,l=3*a,h=i-t,c=(e-t)/h,u=c*c,p=u*c,m=s*l,f=m-l,g=-2*p+3*u,_=p-u,v=1-g,x=_-u+c;for(let y=0;y!==a;y++){const b=r[f+y+a],S=r[f+y+o]*h,w=r[m+y+a],C=r[m+y]*h;n[y]=v*b+x*S+g*w+_*C}return n},function(s,t){if(hd[s])return;const e=document,i=document.createElement("style");i.type="text/css",i.innerHTML=s;const n=e.getElementsByTagName("head")[0];try{n.appendChild(i),hd[s]=!0}catch{}}(`.mapv-controls-pane{position:absolute;z-index:15;bottom:0;left:0;right:0}.mapv-controls-pane .bottom-right-anchor{position:absolute;width:52px;bottom:40px;right:20px}.mapv-controls-pane .bottom-left-anchor{position:absolute;bottom:60px;left:20px}.mapv-controls-pane .compass{width:52px;height:54px;margin-top:10px;visibility:visible;position:relative;background-size:266px;background-repeat:no-repeat;background-position:0 0}.mapv-controls-pane .compass .compass-up{position:absolute;left:20px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-controls-pane .compass .compass-up:hover{fill:#2c82ff}.mapv-controls-pane .compass .compass-down{position:absolute;left:20px;bottom:2px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-controls-pane .compass .compass-down:hover{fill:#2c82ff}.mapv-controls-pane .compass .compass-left{cursor:pointer;position:absolute;top:5px;left:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px}.mapv-controls-pane .compass .compass-left:hover{background-position:-89px -5px}.mapv-controls-pane .compass .compass-right{cursor:pointer;position:absolute;top:5px;right:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px;transform:rotateY(180deg);-ms-transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-o-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}.mapv-controls-pane .compass .compass-right:hover{background-position:-89px -5px}.mapv-controls-pane .compass .compass-center{cursor:pointer;position:absolute;top:11px;left:19px;width:14px;height:32px;background-size:266px;background-repeat:no-repeat;background-position:-56px -10px;transform:rotate(0)}.mapv-controls-pane .zoom{width:26px;height:54px;visibility:visible;margin-left:13px;margin-top:10px}.mapv-controls-pane .zoom .zoom-add{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:2px 2px 0 0;background-position:0 0}.mapv-controls-pane .zoom .zoom-add:hover .zoom-add-tag{background-position:20px 0}.mapv-controls-pane .zoom .zoom-add-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px}.mapv-controls-pane .zoom .zoom-sub{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:0 0 2px 2px}.mapv-controls-pane .zoom .zoom-sub:hover .zoom-sub-tag{background-position:10px 0}.mapv-controls-pane .zoom .zoom-sub-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px;background-position:-10px 0}.mapv-controls-pane .scale{position:absolute;bottom:10px;left:100px;visibility:visible;width:90px;height:26px}.mapv-controls-pane .scale .scale-text{width:100%;font-size:10px;text-align:center;user-select:none;transition:width .3s}.mapv-controls-pane .scale .scale-line{position:relative;width:100%;height:8px;user-select:none}.mapv-controls-pane .scale .scale-line-mid{position:absolute;left:2px;right:2px;top:3px;bottom:2px;background-color:#333;overflow:hidden}.mapv-controls-pane .scale .scale-line-left{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden}.mapv-controls-pane .scale .scale-line-right{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden;right:0}.mapv-controls-pane .drawer{position:absolute;right:31px;bottom:164px;margin:2px;cursor:pointer}.mapv-controls-pane .drawer .drawer-btn{background-color:#fff;padding:5px 5px 0;border-radius:2px}.mapv-controls-pane .drawer .drawer-btn:hover{background-color:#f3f3f3}.mapv-controls-pane .drawer .drawer-icon{height:16px;width:16px;fill:#797979}.mapv-controls-pane .drawer .drawer-list{position:absolute;right:32px;top:0;display:none;list-style:none;background-color:#fff;box-shadow:0 0 20px #00000026;white-space:nowrap;border-radius:2px}.mapv-controls-pane .drawer .drawer-item{display:flex;align-items:center;padding:0 16px;height:24px;line-height:24px}.mapv-controls-pane .drawer .drawer-item-check{margin:0}.mapv-controls-pane .drawer .drawer-item-name{margin-left:6px;font-size:12px}.mapv-controls-pane .drawer .drawer-arrow{width:0;height:0;border-width:4px;border-style:solid;border-color:transparent transparent transparent #fff;position:absolute;top:11px;right:-7px}.mapv-controls-pane .mouse-location{position:absolute;bottom:10px;right:20px;visibility:visible;padding:2px 6px;background-color:#fff;font-size:14px;border-radius:2px}.mapv-controls-pane .logo{position:absolute;width:81px;height:27px;bottom:10px;left:5px;visibility:visible}.mapv-controls-pane .geo-locate{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-controls-pane .fullscreen{background-color:#fff;height:26px;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc}.mapv-controls-pane .export-image{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-controls-pane .geo-locate:hover .control-group-svg,.mapv-controls-pane .fullscreen:hover .control-group-svg,.mapv-controls-pane .export-image:hover .control-group-svg{fill:#2c82ff}.mapv-controls-pane .control-group-svg{margin:5px;height:16px;width:16px;fill:#999}.mapv-overlay-pane{position:absolute;z-index:10}.mapv-overlay-pane .mapv-popup{width:200px;height:110px}.mapv-overlay-pane .mapv-popup .frame{width:198px;height:98px;background:white;border-radius:4px;border:1px solid #e6e1e1}.mapv-overlay-pane .mapv-popup .title{height:30px;border-bottom:1px solid #e6e1e1;line-height:30px;padding-left:10px;font-size:18px;font-weight:500}.mapv-overlay-pane .mapv-popup .close{width:20px;height:31px;position:absolute;font-size:20px;text-align:center;right:5px;cursor:pointer}.mapv-overlay-pane .mapv-popup .triangle{width:0;height:0;border-top:10px solid white;border-left:12px solid transparent;border-right:12px solid transparent;margin-left:88px}.mapv-overlay-pane .mapv-popup .content{padding:5px}.mapv-dom-points{position:absolute;z-index:10}.mapv-measure-pane{display:inline-block;position:absolute;height:30px;border-radius:5px;padding:0 5px;line-height:30px;background-color:#797774;color:#fff;transform:translate(-50%,-130%);overflow:visible}.mapv-measure-pane:after{content:"";position:absolute;width:0;height:0;left:50%;bottom:0;border:6px solid transparent;border-top:6px solid #797774;background-color:transparent;transform:translate(-50%,10px)}.mapv-container{touch-action:none}
`),st.AreaMeasure=class extends Nn{constructor(s,t={}){super(),d(this,"_area",0),d(this,"_node",[]),d(this,"_editor"),d(this,"_infoMarkers"),d(this,"_infoMarkersDataSource"),d(this,"_infoMarkersBuffer",{position:[],index:[],payload:[]}),d(this,"_addNode",e=>{this._node=e.value}),d(this,"_movePolygonNode",e=>{this._node=e.value;const i=this._node.map(n=>n.position);this._area=Nn.getArea(i),this.setInfoMarkers(i)}),d(this,"_moveRectNode",e=>{this._node=e.value;const i=this._node.map(n=>n.position);this._area=Nn.getArea(i),this.setInfoMarkers(i)}),d(this,"_moveCircleNode",e=>{this._node=e.value;const{size:i}=e.value[0],n=Math.PI*Math.pow(i/2,2);this._area=n;const r=this._node.map(a=>a.position);this.setInfoMarkers(r)}),d(this,"_moveNode",e=>{this._adjustNode(e)}),d(this,"_changeNode",e=>{this._adjustNode(e)}),d(this,"_adjustNode",e=>{this._options.type==="rect"?this._moveRectNode(e):this._options.type==="circle"?this._moveCircleNode(e):this._movePolygonNode(e)}),this._engine=s,this._options=t}initEditor(){let s;return s=this._options.type==="rect"?this._editor=this._engine.add(new G_(this._engine,{})):this._options.type==="circle"?this._editor=this._engine.add(new j_(this._engine,{})):this._editor=this._engine.add(new W_(this._engine,{})),s}initInfoMarkers(){let s=this._infoMarkers=this._engine.add(new mo({callback:this.createInfoMarkers,offset:[0,0]}));s.renderItem=this.createInfoMarkers;let t=this._infoMarkersDataSource=new ee;this._infoMarkersDataSource.setAttribute("payload","area"),s.dataSource=t}createInfoMarkers(s){const t=document.createElement("div");return t.innerText=s>1e4?Math.round(s/1e6*100)/100+" km²":Math.round(100*s)/100+" m²",xt(t,`${te}-measure-pane`),t}setInfoMarkers(s){let t;t=this._editor.selectedIndex===-1?this._editor.drawedGraph.length:this._editor.selectedIndex,this._infoMarkersBuffer.position.splice(t,1,s[0]),this._infoMarkersBuffer.index.splice(t,1,t),this._infoMarkersBuffer.payload.splice(t,1,{area:this._area}),this._infoMarkersDataSource.setData(this._infoMarkersBuffer)}clearBuffer(){this._infoMarkersBuffer={position:[],index:[],payload:[]}}clearAll(){this.enabled=!1,this._editor.clearAll(),this.clearBuffer(),this._infoMarkersDataSource.setData()}dispose(){this.clearAll(),this._infoMarkers&&this._engine.remove(this._infoMarkers)}get area(){return this._area}},st.BubblePoint=class extends Si{constructor(s){super(s),d(this,"geometry"),d(this,"material"),d(this,"color"),d(this,"size"),d(this,"duration"),d(this,"trail"),d(this,"type"),this.parameters=s,this.defineMaterialProxyProperties(["color","size","duration","trail","size3","height","opacity"])}initObject(){this.geometry=new ah,this.material=new Rw(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}},st.CSVDataSource=d_,st.Circle=Yu,st.CircleEditor=j_,st.ClippingPlane=gh,st.ClippingPlaneCollection=gs,st.ClusterPoint=class extends L_{constructor(s={}){super(s),d(this,"_ready"),d(this,"_cluster"),d(this,"_clusterDataSource"),d(this,"_icon"),d(this,"_label"),d(this,"_minUpdateInterval"),d(this,"isEventEntitySupported",!0),d(this,"_minUpdateInterval",300),d(this,"_lastUpdateTime",0),d(this,"_updateTimeoutHandler",null),d(this,"_updateRenderingData",()=>{const{map:t}=this.engine,e=t.getBoundingBox(),i=Math.round(t.getZoom()),n=this.engine.map.unprojectPointArr(e.min.toArray()),r=this.engine.map.unprojectPointArr(e.max.toArray()),a=this._cluster.getClusters([...n,...r],i);this._clusterDataSource.setData(a),this._clusterDataSource.update();for(const o of this.children)o.setData()}),this.parameters=s,this._ready=!1,this._cluster=new Zw(Object.assign({},eS,s.cluster)),this._cluster.load([]),(this._clusterDataSource=new us).setAttribute("size").setAttribute("icon").setAttribute("text",t=>(t&&t.cluster?t.point_count:0)+"")}initObject(){}afterAddToEngine(s){super.afterAddToEngine(s);const t=this.parameters;t.icon&&(this._icon=this.addComponent(new w_(Object.assign({},$w,t.icon)))),t.label&&(this._label=this.addComponent(new S_(Object.assign({},tS,t.label)))),this._ready=!0}setData(){let s=this.dataSource.data;this.cachedData=s,this._cluster.load(this.dataSource._geoFeatures),this.needsUpdate=!1}onBeforeScenePrepareRender(s,t,e,i){if(!this._ready||!this.dataSource)return;this._needsUpdate&&this._updateRenderingData(),clearTimeout(this._updateTimeoutHandler);const n=i.time;if(n-this._lastUpdateTime>this._minUpdateInterval)return this._updateRenderingData(),void(this._lastUpdateTime=n);this._updateTimeoutHandler=setTimeout(()=>{this._updateRenderingData(),s.requestRender()},this._minUpdateInterval),super.onBeforeScenePrepareRender(s,t,e,i)}getChildDataSource(){return this._clusterDataSource}getEntityByIndex(s){const t=this._clusterDataSource;if(!t)return;const e={index:s,value:t.getOriginData(s),itemIndex:t.getOriginDataIndex(s),pairs:{}},i=t.data;for(const n of Object.keys(i))e.pairs[n]=i[n][s];return e}get minUpdateInterval(){return this._minUpdateInterval}set minUpdateInterval(s){s<16&&(s=16),this._minUpdateInterval=s}get clusterDataSource(){return this._clusterDataSource}},st.Cone=class extends Si{constructor(s){super(s),d(this,"geometry"),d(this,"material"),d(this,"opacity"),d(this,"height"),d(this,"size"),d(this,"getInstanceLocalMatrix",(t,e,i)=>{const{vertexHeights:n,vertexSizes:r}=this.parameters,{height:a,size:o}=this.dataSource.data;let l=new rt;if(n&&a){const h=new rt;h.makeScale(1,1,a[i]),l.multiply(h)}if(r&&o){const h=new rt;h.makeScale(o[i],o[i],1),l.multiply(h)}return l}),d(this,"addCustomAttributes",()=>{this.calcMaxHeight(),this.getSphereIndex()}),this.parameters=s,this.defineMaterialProxyProperties(["opacity","color","size"])}initObject(){this.geometry=new QS(this.parameters),this.material=new t2(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}calcMaxHeight(){const{vertexHeights:s}=this.parameters,{height:t}=this.dataSource.data;let e=-1;if(!s||!t)return e;for(let i=0;i<t.length;i++)e<t[i]&&(e=t[i]);this.material.uniforms.maxHeight.value=e}getSphereIndex(){const{sphereIndex:s}=this.geometry.parameters;this.material.uniforms.sphereIndex.value=s}},st.CustomStaticSky=Uf,st.DOMOverlay=td,st.DataItem=Ni,st.DataSource=rs,st.Default3DTiles=class extends St{constructor(s){super(),d(this,"options",null),d(this,"_tilesRenderer",null),d(this,"_elementsManager",null),d(this,"_elementsGroup",null),d(this,"_editableElementManager",null),d(this,"engine",null),d(this,"_tileMaxLevel",19),d(this,"is3DTiles",!0),d(this,"_materialManager",null),d(this,"_debugTilesRenderer",null),d(this,"_freezeUpdate",!1),d(this,"_excludeCastShadowMaterials",{road:!0,green:!0,isolation:!0}),d(this,"_instancedElementManager",null),d(this,"_identityType",1),d(this,"_visibile",!0),d(this,"_loaders",[]),d(this,"handleBeforeRender",(n,r)=>{this._debugTilesRenderer||(!this._freezeUpdate&&this._visibile&&(this._elementsManager&&this._elementsManager.tick(r),this._tilesRenderer.update()),this._editableElementManager.refreshTiles())}),d(this,"handleLoadTileSet",(n,r,a)=>{this.engine.requestRender()}),d(this,"handleUpdateModel",n=>{this._materialManager?n.traverse(r=>{if(r.originalMaterial){const a=r.originalMaterialName,o=this._materialManager.getMaterialByKey(a);r.material=o||r.originalMaterial}}):n.traverse(r=>{r.originalMaterial&&(r.material=r.originalMaterial)}),this.engine.requestRender()}),d(this,"parseTileInfo",n=>{const r=n.content.uri,a=r.substring(r.lastIndexOf("/")+1).split(".")[0],o=a.split("-");n.__id=a,n.__level=parseInt(o[0],10),n.__lodLevel=this._tileMaxLevel-n.__level}),d(this,"handleLoadModel",(n,r)=>{this._materialManager&&n.traverse(a=>{if(a.material){const o=a.material.name;a.originalMaterial=a.material,a.originalMaterialName=o;const l=this._materialManager.getMaterialByKey(o);l&&(a.material=l),this._excludeCastShadowMaterials[o]||(a.castShadow=!0),a.receiveShadow=!0}}),n._tileUri=r.content.uri,this.parseTileInfo(r),this._instancedElementManager.onTileLoad(r,n),this._elementsManager.onTileLoad(r,n),this._editableElementManager.onTileLoad(r,n),this.engine.requestRender()}),d(this,"handleDisposeModel",(n,r)=>{this._instancedElementManager.onTileDispose(r,n),this._elementsManager.onTileDispose(r,n),this._editableElementManager.onTileDispose(r,n)}),d(this,"handleTileVisibleChanged",(n,r)=>{r?(this._editableElementManager.onTileShow(n),this._instancedElementManager.onTileShow(n),this._elementsManager.onTileShow(n)):(this._editableElementManager.onTileHide(n),this._instancedElementManager.onTileHide(n),this._elementsManager.onTileHide(n))}),d(this,"handleDebugBeforeengineRender",()=>{this._freezeUpdate||this._debugTilesRenderer.update()}),d(this,"_updateTilesCustomLoaders",n=>{for(const r of this._loaders)n.manager.addHandler(r[0],r[1])}),d(this,"handleDebugLoadTileSet",()=>{this.engine.requestRender()}),d(this,"handleDebugLoadModel",()=>{this.engine.requestRender()}),d(this,"transformFromEcefToPlane",(n,r,a=0)=>{let o=ui.eastNorthUpToFixedFrame(ui.lnglatToEcef(n,r,a));o.invert();const l=new rt,h=Wr([n,r]);l.makeTranslation(h[0],h[1],0);const c=new rt;c.multiplyMatrices(l,o),c.decompose(this.position,this.quaternion,this.scale)}),d(this,"disposeTilesRender",n=>{n.forEachLoadedModel((r,a)=>{n.disposeTile(a)})}),this.options=s;const t=this._tilesRenderer=new Su(this.options.url);t.fetchOptions=s.fetchOptions||{},t.errorTarget=s.errorTarget||64,t.preprocessURL=s.preprocessURL||null,t.errorThreshold=s.errorThreshold||1/0,t.maxDepth=s.maxDepth||1/0,t.loadSiblings=s.loadSiblings===void 0||s.loadSiblings,t.displayActiveTiles=s.displayActiveTiles!==void 0&&s.displayActiveTiles,t.autoDisableRendererCulling=s.autoDisableRendererCulling===void 0||s.autoDisableRendererCulling,s.lruCache_maxSize&&(t.lruCache.minSize=Math.max(.25*s.lruCache_maxSize,100),t.lruCache.maxSize=s.lruCache_maxSize),t.downloadQueue.priorityCallback=Og,s.maxDownloadJobs&&(t.downloadQueue.maxJobs=s.maxDownloadJobs),t.parseQueue.priorityCallback=Og,s.maxParseJobs&&(t.parseQueue.maxJobs=s.maxParseJobs),this.add(t.group);const e=this._elementsGroup=new De;this.add(e),(this._elementsManager=new LM(this._elementsGroup)).tilesRenderer=t;const i=this._instancedElementManager=new FM;i.tilesRenderer=t,this.add(i.group),(this._editableElementManager=new BM).tilesRenderer=t,Array.isArray(s.loaders)?this._loaders=s.loaders:this._loaders=[],this._updateTilesCustomLoaders(t)}afterAddToEngine(s){this.engine=s;const t=this._tilesRenderer;t.setCamera(s.camera),t.setResolutionFromRenderer(s.camera,s.renderer),t.onLoadTileSet=this.handleLoadTileSet,t.onLoadModel=this.handleLoadModel,t.onDisposeModel=this.handleDisposeModel,t.onTileVisibleChanged=this.handleTileVisibleChanged,s.addPrepareRenderListener(this.handleBeforeRender),this._instancedElementManager.engine=s,this._elementsManager.engine=s,this._editableElementManager.engine=s}beforeRemoveFromEngine(s){this.dispose()}getBounds(){const s=new He,t=this._tilesRenderer.getBounds(s);return t&&s.applyMatrix4(this.matrixWorld),t?s:null}createDebugTilesRenderer(){this._tilesRenderer.group.visible=!1;const s=this._debugTilesRenderer=new DM(this.options.url),t=this.engine;s.setCamera(t.camera),s.setResolutionFromRenderer(t.camera,t.renderer),s.errorTarget=this._tilesRenderer.errorTarget,s.loadSiblings=this._tilesRenderer.loadSiblings,s.displayActiveTiles=this._tilesRenderer.displayActiveTiles,s.autoDisableRendererCulling=this._tilesRenderer.autoDisableRendererCulling,s.preprocessURL=this._tilesRenderer.preprocessURL,s.errorThreshold=this._tilesRenderer.errorThreshold,s.maxDepth=this._tilesRenderer.maxDepth,s.displayBoxBounds=!0,s.onLoadTileSet=this.handleLoadTileSet,s.onLoadModel=this.handleLoadModel,t.addPrepareRenderListener(this.handleDebugBeforeengineRender),this._updateTilesCustomLoaders(s),this.add(this._debugTilesRenderer.group)}isEntityVisible(s){return!s.id||!this._editableElementManager.hasDeletedId(s.id)}destoryDebugTilesRenderer(){this.remove(this._debugTilesRenderer.group),this.engine.removePrepareRenderListener(this.handleDebugBeforeengineRender),this.disposeTilesRender(this._debugTilesRenderer),this._debugTilesRenderer.dispose(),this._tilesRenderer.group.visible=!0}dispose(){this.remove(this._tilesRenderer.group),this.engine.removePrepareRenderListener(this.handleBeforeRender),this.disposeTilesRender(this._tilesRenderer),this._tilesRenderer.dispose(),this._debugTilesRenderer&&(this.remove(this._debugTilesRenderer.group),this.engine.removePrepareRenderListener(this.handleDebugBeforeengineRender),this.disposeTilesRender(this._debugTilesRenderer),this._debugTilesRenderer.dispose())}set materialManager(s){s&&(s.engine=this.engine,s.tiles=this,s.init(),s.Identity3DTilesMaterialManager&&(s.type=this._identityType)),this._materialManager=s,this._tilesRenderer.forEachLoadedModel(this.handleUpdateModel)}get materialManager(){return this._materialManager}set showDebug(s){s?this._debugTilesRenderer||this.createDebugTilesRenderer():this._debugTilesRenderer&&(this.destoryDebugTilesRenderer(),this._debugTilesRenderer=null),this.engine.requestRender()}get showDebug(){return!!this._debugTilesRenderer}get debugTilesRenderer(){return this._debugTilesRenderer}get elementsManager(){return this._elementsManager}get freezeUpdate(){return this._freezeUpdate}set freezeUpdate(s){this._freezeUpdate=s}get errorTarget(){return this._tilesRenderer.errorTarget}set errorTarget(s){this._tilesRenderer.errorTarget=s,this._debugTilesRenderer&&(this._debugTilesRenderer.errorTarget=s),this.engine.requestRender()}get tilesGroup(){return this._tilesRenderer.group}get tilesRenderer(){return this._tilesRenderer}get instancedElementManager(){return this._instancedElementManager}get editableElementManager(){return this._editableElementManager}get identityType(){return this._identityType}set identityType(s){this._identityType=s,this._materialManager&&this._materialManager.isIdentity3DTilesMaterialManager&&(this._materialManager.type=s)}get loadSiblings(){return this._tilesRenderer.loadSiblings}set loadSiblings(s){this._tilesRenderer.loadSiblings=s,this._debugTilesRenderer&&(this._debugTilesRenderer.loadSiblings=s)}get displayActiveTiles(){return this._tilesRenderer.displayActiveTiles}set displayActiveTiles(s){this._tilesRenderer.displayActiveTiles=s,this._debugTilesRenderer&&(this._debugTilesRenderer.displayActiveTiles=s)}get autoDisableRendererCulling(){return this._tilesRenderer.autoDisableRendererCulling}set autoDisableRendererCulling(s){this._tilesRenderer.autoDisableRendererCulling=s,this._debugTilesRenderer&&(this._debugTilesRenderer.autoDisableRendererCulling=s)}get preprocessURL(){return this._tilesRenderer.preprocessURL}set preprocessURL(s){this._tilesRenderer.preprocessURL=s,this._debugTilesRenderer&&(this._debugTilesRenderer.preprocessURL=s)}get errorThreshold(){return this._tilesRenderer.errorThreshold}set errorThreshold(s){this._tilesRenderer.errorThreshold=s,this._debugTilesRenderer&&(this._debugTilesRenderer.errorThreshold=s)}get maxDepth(){return this._tilesRenderer.maxDepth}set maxDepth(s){this._tilesRenderer.maxDepth=s,this._debugTilesRenderer&&(this._debugTilesRenderer.maxDepth=s)}set visible(s){this._visibile=s,this._tilesRenderer&&(this._tilesRenderer.group.visible=s)}get visible(){return this._visibile}},st.Default3DTilesMaterialManager=Yl,st.DomPoints=mo,st.DynamicInstancedMesh=Au,st.DynamicSky=Jf,st.DynamicWeather=Ec,st.EffectModelPoint=class extends Sn{constructor(s){super(),d(this,"_model"),d(this,"_normalize"),d(this,"_rotateToZUp"),d(this,"_keepSize"),d(this,"_size"),d(this,"_size3"),d(this,"_useSize3"),d(this,"_height"),d(this,"_animationRotate"),d(this,"_animationRotatePeriod"),d(this,"_animationJump"),d(this,"_animationJumpPeriod"),d(this,"_animationJumpHeight"),d(this,"isEventEntitySupported",!0),d(this,"_model",null),d(this,"_normalize",!0),d(this,"_rotateToZUp",!0),d(this,"_keepSize",!0),d(this,"_size",1),d(this,"_size3",[1,1,1]),d(this,"_useSize3",!1),d(this,"_height",0),d(this,"_animationRotate",!1),d(this,"_animationRotatePeriod",3e3),d(this,"_animationJump",!1),d(this,"_animationJumpPeriod",3e3),d(this,"_animationJumpHeight",30),d(this,"_updateModel",()=>{this._cleanOldMesh();const t=Wl(this._model,this._normalize,this._rotateToZUp);for(const e of t){const i=e.material;let n=new nS;n.setCommonUniforms(this.engine.rendering.uniforms),n.transparent=i.transparent,n.opacity=i.opacity,n.side=i.side,n.depthWrite=i.depthWrite,n.depthTest=i.depthTest,n.depthFunc=i.depthFunc,n.blendDst=i.blendDst,n.blendDstAlpha=i.blendDstAlpha,n.blendEquation=i.blendEquation,n.blendEquationAlpha=i.blendEquationAlpha,n.blending=i.blending,n.blendSrc=i.blendSrc,n.blendSrcAlpha=i.blendSrcAlpha,n.premultipliedAlpha=i.premultipliedAlpha,n.color=i.color,n.colorWrite=i.colorWrite,n.emissive=i.emissive,n.keepSize=this._keepSize,n.size=this._size,n.size3=this._size3,n.useSize3=this._useSize3,n.height=this._height,n.animationRotate=this._animationRotate,n.animationRotatePeriod=this._animationRotatePeriod,n.animationJump=this._animationJump,n.animationJumpPeriod=this._animationJumpPeriod,n.animationJumpHeight=this._animationJumpHeight;const r=e.geometry,a=r.getAttribute("color");a&&(a.itemSize===4?n.vertexColors4=!0:a.itemSize===3&&(n.vertexColors3=!0));const o=new Si(r,n);o.engine=this.engine,o.dataAutoUpdate=!1,o.__eventProxyByParent=!0,this.dataSource&&(o.dataSource=this.dataSource),this.add(o)}this.needsUpdate=!0}),d(this,"_cleanOldMesh",()=>{const t=this.children;for(const e of t)this.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),d(this,"_defineChildrenMaterialProperty",t=>{Object.defineProperty(this,t,{get:function(){return this["_"+t]},set:function(e){this["_"+t]=e;for(const i of this.children)i.material[t]=e}})}),s=Object.assign({},sS,s),this._normalize=s.normalize,this._rotateToZUp=s.rotateToZUp,["size","size3","useSize3","height","keepSize","animationRotate","animationRotatePeriod","animationJump","animationJumpPeriod","animationJumpHeight"].forEach(t=>{s[t]!==void 0&&(this["_"+t]=s[t]),this._defineChildrenMaterialProperty(t)})}setData(){const s=this.dataSource;for(const t of this.children)t.dataSource=s,t.setData();this.needsUpdate=!1}onDispose(){this._cleanOldMesh()}set model(s){s!==this._model&&(this._model=s,this._updateModel())}get model(){return this._model}},st.EmptySky=Fr,st.Engine=class{constructor(s,t={}){d(this,"_container"),d(this,"_event"),d(this,"_map"),d(this,"_rendering"),d(this,"_selection"),d(this,"_controls"),d(this,"isEngine",!0),this._container=s,this._event=new Zi(this,t.event),this._map=new eb(this,t.map),this._map.init();const e=this.map.getResolution();this._rendering=new T1(this,{resolution:e,...t.rendering}),this._rendering.init(),this._map.afterInit(),this._rendering.startRenderLoop(),this._selection=new lb(this,t.selection),this._controls=new vb(this,t.controls),this.trackingRequest()}add(s){return this._rendering.add(s)}remove(s){this._rendering.remove(s)}requestRender(){this._rendering.requestRender()}addPrepareRenderListener(s){this._rendering.addPrepareRenderListener(s)}addBeforeRenderListener(s){this._rendering.addBeforeRenderListener(s)}removeBeforeRenderListener(s){this._rendering.removeBeforeRenderListener(s)}removePrepareRenderListener(s){this._rendering.removePrepareRenderListener(s)}addBeforePrepareRenderObject(s){this._rendering.addBeforePrepareRenderObject(s)}removeBeforePrepareRenderObject(s){this._rendering.removeBeforePrepareRenderObject(s)}addBeforeRenderObject(s){this._rendering.addBeforeRenderObject(s)}removeBeforeRenderObject(s){this._rendering.removeBeforeRenderObject(s)}lockCamera(){this.camera._isLocked=!0}unlockCamera(){this.camera._isLocked=!1}get container(){return this._container}get map(){return this._map}get rendering(){return this._rendering}get controls(){return this._controls}get renderer(){return this._rendering.renderer}get scene(){return this._rendering.scene}get camera(){return this._rendering.camera}get event(){return this._event}get selection(){return this._selection}dispose(){this._controls.dispose(),this._event.dispose(),this._selection.dispose(),this._rendering.dispose(),this._map.dispose()}trackingRequest(){const s=`http://api.map.baidu.com/images/blank.gif?product=jsapi&sub_product=mapvthree&usebmap=${window.BMapGL?1:0}&ak=${window.BMAP_AUTHENTIC_KEY}`;let t=new Image;t.src=s,t.onload=()=>{t=null},t.onerror=()=>{t=null}}},st.ExtendMeshStandardMaterial=jl,st.FanPoint=class extends Si{constructor(s){super(s),d(this,"geometry"),d(this,"material"),d(this,"color"),d(this,"opacity"),d(this,"size"),d(this,"height"),d(this,"speed"),d(this,"type"),d(this,"segmentAngle"),d(this,"sideColor"),this.parameters=s,this.defineMaterialProxyProperties(["color","size","size3","height","opacity","speed","segmentAngle","sideColor"])}initObject(){this.geometry=new ah,this.material=new Aw(this.parameters),this.material.animationRotate=!0,this.material.setCommonUniforms(this.engine.rendering.uniforms)}},st.FatLine=sr,st.FlyManager=class extends St{constructor(){super(...arguments),d(this,"_engine"),d(this,"_isRunning",!1),d(this,"_animationStartTime",0),d(this,"_animationDuration",0),d(this,"_animationStartState",null),d(this,"_animationFinishState",null),d(this,"update",(s,t)=>{if(!this._isRunning)return;const e=t.time-this._animationStartTime;let i=1;this._animationDuration>0&&(i=e/this._animationDuration),i>1&&(i=1);const n=this._animationStartState,r=this._animationFinishState,a=this._engine.map;let o={};n.heading!==void 0&&(o.heading=ps(n.heading,r.heading,i)),n.pitch!==void 0&&(o.pitch=ps(n.pitch,r.pitch,i)),n.zoom!==void 0&&(o.zoom=ps(n.zoom,r.zoom,i)),n.range!==void 0&&(o.range=ps(n.range,r.range,i));let l=Fu(n.center,r.center,i);a.lookAt(l,o),e>=this._animationDuration||i>=1?(this._isRunning=!1,this.onFinish&&this.onFinish()):this._engine.requestRender()}),d(this,"restrictHeading",(s,t)=>Math.abs(t-s+360)<180?t+360:Math.abs(t-s-360)<180?t-360:t)}afterAddToEngine(s){this._engine=s,s.addPrepareRenderListener(this.update)}flyTo(s,t={}){let{center:e,pitch:i,heading:n,zoom:r,range:a}=s;const{duration:o=300}=t,l={},h={},c=this._engine.map,u=c.getCenter(),p=e||c.getCenter();!u[2]&&(u[2]=0),!p[2]&&(p[2]=0),l.center=u,h.center=p,isNaN(i)||(l.pitch=c.getPitch(),h.pitch=i),isNaN(n)||(n=this.restrictHeading(c.getHeading(),n),l.heading=c.getHeading(),h.heading=n),isNaN(r)||(l.zoom=c.getZoom(),h.zoom=r),isNaN(a)||(l.range=c.getCameraDistance(),h.range=a),this._animationStartState=l,this._animationFinishState=h,this._animationDuration=o,this._isRunning=!0,this._animationStartTime=new Date().getTime(),this._engine.requestRender(),this.onStart&&this.onStart()}beforeRemoveFromEngine(){this._engine.removePrepareRenderListener(this.update),this.removeFromParent()}},st.FoliageLeafMaterial=Gl,st.GeoInstancedMesh=Si,st.GeoJSONDataSource=us,st.Grid=class extends Si{constructor(s){super(s),d(this,"geometry"),d(this,"material"),d(this,"color"),d(this,"height"),d(this,"radialSegments"),d(this,"radiusTop"),d(this,"radiusBottom"),d(this,"openEnded"),d(this,"heightSegments"),d(this,"isMultiColor"),d(this,"multiColor"),d(this,"isLight"),d(this,"lightPos"),this.parameters=s,this.defineGeometryProxyProperties(["height","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded"]),this.defineMaterialProxyProperties(["color","multiColor","isMultiColor","lightPos"])}initObject(){this.geometry=new XS(this.parameters),this.material=new YS(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}},st.Heatmap=class extends as{constructor(s){super(s),d(this,"isHeatmap",!0),d(this,"frustumCulled",!1),d(this,"geometry"),d(this,"material"),d(this,"scene"),d(this,"pointMesh"),d(this,"pointMaterial"),d(this,"pointGeometry"),d(this,"renderTarget"),d(this,"depthMaterial"),d(this,"depthRenderTarget"),this.parameters=s,this.defineMaterialProxyProperties(["resolution"])}getDefaultParams(){return{radius:100,maxValue:1,gradient:{0:"rgba(0,0,255,1)",.3:"rgba(0,255,0,1)",.6:"rgba(255,255,0,1)",1:"rgba(255,0,0,1)"}}}initObject(){let s=this.parameters;const t=this.geometry=new Pt;t.setAttribute("position",new se(new Float32Array([-1,1,0,1,1,0,-1,-1,0,1,-1,0]),3)),t.setAttribute("uv",new se(new Float32Array([0,1,1,1,0,0,1,0]),2)),t.setIndex([0,2,1,2,3,1]),(this.material=new uS({})).setCommonUniforms(this.engine.rendering.uniforms);const[e,i]=this.resolution||[],n=this.scene=new Gp;this.renderTarget=new de(e,i),this.depthRenderTarget=new de(e,i,{}),this.depthMaterial=new fS({keepSize:this.parameters.keepSize});const r=this.pointGeometry=new gS,a=this.pointMaterial=new pS({keepSize:this.parameters.keepSize});a.setCommonUniforms(this.engine.rendering.uniforms),this.depthMaterial.setCommonUniforms(this.engine.rendering.uniforms);const o=this.pointMesh=new Si(r,a);o.engine=this.engine,this.pointMesh.matrixAutoUpdate=!0,o.frustumCulled=!1,n.add(o),this.material.uniforms.heatmap.value=this.renderTarget.texture,this.material.uniforms.heatmapDepth.value=this.depthRenderTarget.texture,s.gradient!==void 0&&(this.gradient=s.gradient),s.radius!==void 0&&(this.radius=s.radius),s.minValue!==void 0&&(this.minValue=s.minValue),s.maxValue!==void 0&&(this.maxValue=s.maxValue),s.opacity!==void 0&&(this.opacity=s.opacity),s.keepSize!==void 0&&(this.keepSize=s.keepSize),s.attenuateMValueFactor!==void 0&&(this.attenuateMValueFactor=s.attenuateMValueFactor)}onBeforeSceneRenderHook(s,t,e,i){let n=s.renderer;this.scene.position.set(-i.cameraOffsetX,-i.cameraOffsetY,0),n.setRenderTarget(this.renderTarget),n.autoClear===!1&&n.clear(),n.render(this.scene,e),n.setRenderTarget(this.depthRenderTarget),n.autoClear===!1&&n.clear(),this.scene.overrideMaterial=this.depthMaterial,n.render(this.scene,e),this.scene.overrideMaterial=null,n.setRenderTarget(null)}set dataSource(s){this.pointMesh.dataSource=s}get dataSource(){return this.pointMesh.dataSource}setData(){this.pointMesh.dataSource&&(this.pointMesh.addCustomAttributes=(s,t)=>{let e=t.data,i=[];for(let n=0;n<e.position.length;n++){const r=e.count[n]?e.count[n]:1;i.push(r)}s.setAttribute("instancedWeight",new Xi(new Float32Array(i),1))},this.pointMesh.setData())}dispose(){this.material.dispose(),this.geometry.dispose(),this.pointGeometry.dispose(),this.pointMaterial.dispose(),this.renderTarget.dispose(),this.depthMaterial.dispose(),this.depthRenderTarget.dispose()}set gradient(s){Object.prototype.toString.call(s)==="[object Object]"&&(this.material.gradient=s)}set radius(s){!isNaN(s)&&s>0&&(this.pointMaterial.radius=s,this.depthMaterial.radius=s)}get radius(){return this.pointMaterial.radius}set minValue(s){isNaN(s)||(this.pointMaterial.minValue=s)}get minValue(){return this.pointMaterial.minValue}set maxValue(s){isNaN(s)||(this.pointMaterial.maxValue=s)}get maxValue(){return this.pointMaterial.maxValue}set opacity(s){isNaN(s)||(this.material.opacity=s)}get opacity(){return this.material.opacity}set keepSize(s){this.pointMaterial.keepSize=s,this.depthMaterial.keepSize=s}get keepSize(){return this.pointMaterial.keepSize}set attenuateMValueFactor(s){this.pointMaterial.attenuateMValueFactor=s}},st.Heatmap3D=class extends as{constructor(s){super(s),d(this,"_gradient"),d(this,"_radius"),d(this,"_maxValue"),d(this,"isHeatmap3D",!0),d(this,"frustumCulled",!1),d(this,"geometry"),d(this,"material"),d(this,"opacity"),d(this,"heightRatio"),this.parameters=s,this._gradient=this.parameters.gradient!==void 0?this.parameters.gradient:{.4:"rgba(0,0,255,1)",.6:"rgba(0,255,0,1)",.8:"rgba(255,255,0,1)",1:"rgba(255,0,0,1)"},this._radius=this.parameters.radius!==void 0?this.parameters.radius:100,this._maxValue=this.parameters.maxValue!==void 0?this.parameters.maxValue:1,this.defineMaterialProxyProperties(["resolution","opacity","heightRatio"])}initObject(){const{radius:s,maxValue:t,...e}=this.parameters;this.geometry=new Rs,(this.material=new vS(e)).setCommonUniforms(this.engine.rendering.uniforms)}setData(){let s=this.dataSource.data,t=1/0,e=1/0,i=1/0,n=-1/0,r=-1/0,a=-1/0,o=[];for(let x=0;x<s.position.length;x++){const y=s.position[x],b=s.count?s.count[x]:1;t=Math.min(y[0],t),e=Math.min(y[1],e),i=Math.min(y[2],i),n=Math.max(y[0],n),r=Math.max(y[1],r),a=Math.max(y[2],a),o.push([y[0],y[1],b])}let l=[(t+n)/2,(e+r)/2,(i+a)/2];this.position.set(...l);let h=Math.ceil(n-t)+2*this._radius,c=Math.ceil(r-e)+2*this._radius,u=Math.min(h*c/4e4,2048),p=u/2,m=new yS(u,u);o.forEach(x=>{x[0]=x[0]-t+this._radius,x[1]=x[1]-e+this._radius});let f=xS(m),g=f._ctx;g.save(),g.scale(u/h,u/c),f.data(o).radius(this._radius).max(this._maxValue).gradient(this._gradient).draw(),g.restore(),this.geometry&&this.geometry.dispose();const _=this.geometry=new Rs(h,c,p,p);_.computeBoundingSphere(),_.computeBoundingBox(),this.texture&&this.texture.dispose();let v=this.texture=new Le(m);this.material.uniforms.map.value=v,this.needsUpdate=!1}onDispose(){this.texture&&this.texture.dispose()}get gradient(){return this._gradient}set gradient(s){this._gradient=s}get radius(){return this._radius}set radius(s){this._radius=s}get maxValue(){return this._maxValue}set maxValue(s){this._maxValue=s}},st.Icon=w_,st.IconPoint=po,st.Identity3DTilesMaterialManager=class extends Yl{constructor(){super(),d(this,"_type",1),d(this,"isIdentity3DTilesMaterialManager",!0),this.material=new WM({color:35020})}onInit(){this.updateType()}updateType(){this.tiles.instancedElementManager.idEnabled=this._type===1,this.tiles.instancedElementManager.dataTypeEnabled=this._type===2,this.material.type=this._type}getMaterialByKey(s){return this.material}dispose(){this.material.dispose()}set type(s){this._type=s,this.updateType()}get type(){return this._type}},st.JSONDataSource=Nu,st.LODDynamicInstancedMesh=Pg,st.LODModel=class extends St{constructor(s){super(s),d(this,"_hysteresis",.1),d(this,"_levels",[]),d(this,"_currentLevel"),d(this,"_currentModel"),d(this,"_generateModelMesh",async t=>new Promise((e,i)=>{_M.load(t,n=>{e(n.scene)},null,i)})),d(this,"update",async()=>{if(!this.visible)return;const t=this._engine.camera,e=this.levels,i=this.position,n=e.length;if(n>0){const r=t.position.distanceTo(i),a=e[n-1].hysteresis||this.hysteresis;if(r>e[n-1].distance*(1+a))return this._modelMeshSingleton.keys.forEach(async h=>{(await this._modelMeshSingleton.get(h)).visible=!1}),this._currentLevel=void 0,void(this._currentModel=void 0);let o,l;for(let h=0;h<n;h++){const c=e[h];let u=c.distance;c.init&&(await this._modelMeshSingleton.get(c.file)).visible===!0&&(u+=u*(c.hysteresis||this.hysteresis)),o===void 0&&r<=u?o=h:c.init&&((await this._modelMeshSingleton.get(c.file)).visible=!1)}if(o>=0){let h=e[o],c=await this._modelMeshSingleton.get(h.file);h.init?c.visible=!0:(this.add(c),h.init=!0,this.handleLoaded(c)),l=c}this._currentLevel=o,this._currentModel=l}}),s.hysteresis&&(this.hysteresis=s.hysteresis),s.levels&&(this.levels=s.levels)}afterAddToEngine(s){this._engine=s,this._modelMeshSingleton=new gM,this._modelMeshSingleton.generate=this._generateModelMesh,this._engine.rendering.addPrepareRenderListener(this.update)}beforeRemoveFromEngine(s){this.dispose()}addLevel(s,t=0,e=0){t=Math.abs(t);const i=this.levels;let n;for(n=0;n<i.length&&!(t<i[n].distance);n++);return i.splice(n,0,{distance:t,hysteresis:e,file:s,init:!1}),this}removeLevel(s){for(let t=0;t<this.levels.length;t++)if(s===this.levels[t].file){this.levels.splice(t,1);break}return this}getCurrentLevel(){return this._currentLevel}getCurrentModel(){return this._currentModel}async getModel(s){let t=this.levels[s];if(t)return await this._modelMeshSingleton.get(t.file)}handleLoaded(s){this.dispatchEvent({type:"loaded",value:s}),this._engine.event.markEventProxy(this),this.levels.every(t=>t.init)&&this.dispatchEvent({type:"complete",value:this})}dispose(){if(this._loaded){this._engine.rendering.removePrepareRenderListener(this.update),this._modelMeshSingleton.keys.forEach(async s=>{let t=await this._modelMeshSingleton.get(s);this.remove(t)});for(let s=0;s<this.levels.length;s++)this.levels[s].init=!1}}set transform(s){s.translate&&(s.translate instanceof M?this.position.copy(s.translate):this.position.set(...s.translate)),s.rotation&&(s.rotation instanceof M?this.rotation.copy(s.rotation):this.rotation.set(...s.rotation)),s.scale&&(s.scale instanceof M?this.scale.copy(s.scale):typeof s.scale=="number"?this.scale.setScalar(s.scale):this.scale.set(...s.scale))}get transform(){return{translate:this.position,rotation:this.rotation,scale:this.scale}}set levels(s){this._levels=s.map(t=>(t.init=!1,t))}get levels(){return this._levels}set hysteresis(s){this._hysteresis=s}get hysteresis(){return this._hysteresis}set lodFactor(s){this._lodFactor=s}get lodFactor(){return this._lodFactor}},st.Label=S_,st.LengthMeasure=class extends Nn{constructor(s,t={}){super(),d(this,"_editor",null),d(this,"_node"),d(this,"_moveMarker"),d(this,"_moveMarkerDataSource"),d(this,"_infoMarkers"),d(this,"_infoMarkersDataSource"),d(this,"_totalMarker"),d(this,"_totalMarkerDataSource"),d(this,"_length",0),d(this,"_segmentLengths",[]),d(this,"_indexOffset",[0,0]),d(this,"_infoMarkersBuffer",{position:[],index:[],payload:[]}),d(this,"_moveMarkerBuffer",{position:[],index:[],payload:[]}),d(this,"_totalMarkerBuffer",{position:[],index:[],payload:[]}),d(this,"createInfoMarkers",e=>{const i=document.createElement("div");return i.innerText=e.toFixed(this.fixedNum),xt(i,`${te}-measure-pane`),i}),d(this,"createTotalMarker",e=>{const i=document.createElement("div");return i.innerText=`总长度:${e.toFixed(this.fixedNum)}`,xt(i,`${te}-measure-pane`),i}),d(this,"_addNode",e=>{this._node=e.value;const i=this._node.map(h=>h.position);if(i.length<2)return;this._segmentLengths=Nn.getSegementLength(i),this._length=this._segmentLengths.reduce((h,c)=>h+c,0);const n=this._editor._helpersBuffer,{position:r}=n,a=[];for(let h=0,c=r.length;h<c-1;h++){const u=r[h],p=r[h+1];a.push([(u[0]+p[0])/2,(u[1]+p[1])/2,(u[2]+p[2])/2])}let o=a.length;this._indexOffset[this.selectedIndex+1]=this._indexOffset[this.selectedIndex]+a.length;let l=this._indexOffset[this.selectedIndex];this._infoMarkersBuffer.position.splice(l,o,...a),this._infoMarkersBuffer.index.splice(l,o,...new Array(o).fill(0).map((h,c)=>c+l)),this._infoMarkersBuffer.payload.splice(l,o,...this._segmentLengths.map(h=>({length:h}))),this._infoMarkersDataSource.setData(this._infoMarkersBuffer),this._moveMarkerDataSource.setData([])}),d(this,"_moveNode",e=>{const i=this._node[this._node.length-1],n=Nn.getLength(i.position,e.value);this._moveMarkerBuffer.position=[e.value],this._moveMarkerBuffer.index=[0],this._moveMarkerBuffer.payload=[{length:n}],this._moveMarkerDataSource.setData(this._moveMarkerBuffer)}),d(this,"_changeNode",e=>{this._node=e.value;const i=this._node.map(n=>n.position);i.length<2||(this._addNode(e),this._moveMarkerDataSource.setData([]),this._totalMarkerBuffer.position.splice(this.selectedIndex,1,i[i.length-1]),this._totalMarkerBuffer.index.splice(this.selectedIndex,1,this.selectedIndex),this._totalMarkerBuffer.payload.splice(this.selectedIndex,1,{length:this._length}),this._totalMarkerDataSource.setData(this._totalMarkerBuffer))}),this._engine=s,this._options=t,t.fixedNum&&(this.fixedNum=t.fixedNum)}initEditor(){return this._editor=this._engine.add(new ed(this._engine,{lineColor:this._options.lineColor}))}initInfoMarkers(){let s=this._infoMarkers=this._engine.add(new mo({callback:this.createInfoMarkers,offset:[0,0]})),t=this._moveMarker=this._engine.add(new mo({callback:this.createInfoMarkers,offset:[0,0]})),e=this._totalMarker=this._engine.add(new mo({callback:this.createTotalMarker,offset:[0,0]}));s.renderItem=this.createInfoMarkers,t.renderItem=this.createInfoMarkers,e.renderItem=this.createTotalMarker;let i=this._infoMarkersDataSource=new ee,n=this._moveMarkerDataSource=new ee,r=this._totalMarkerDataSource=new ee;this._infoMarkersDataSource.setAttribute("payload","length"),this._moveMarkerDataSource.setAttribute("payload","length"),this._totalMarkerDataSource.setAttribute("payload","length"),s.dataSource=i,t.dataSource=n,e.dataSource=r}clearBuffer(){this._infoMarkersBuffer={position:[],index:[],payload:[]},this._moveMarkerBuffer={position:[],index:[],payload:[]},this._totalMarkerBuffer={position:[],index:[],payload:[]}}clearAll(){this._editor.enabled=!1,this._editor.clearAll(),this.clearBuffer(),this._infoMarkersDataSource.setData(),this._moveMarkerDataSource.setData(),this._totalMarkerDataSource.setData()}dispose(){this.clearAll(),this._infoMarkers&&this._engine.remove(this._infoMarkers),this._moveMarker&&this._engine.remove(this._moveMarker),this._totalMarker&&this._engine.remove(this._totalMarker)}get selectedIndex(){let s;return s=this._editor.selectedIndex===-1?this._editor.drawedGraph.length:this._editor.selectedIndex,s}get length(){return this._length}get segmentLengths(){return this._segmentLengths}},st.LightSphere=class extends Si{constructor(s){super(s),d(this,"geometry"),d(this,"material"),d(this,"radius"),d(this,"color"),d(this,"widthSegments"),d(this,"heightSegments"),d(this,"phiStart"),d(this,"phiLength"),d(this,"thetaStart"),d(this,"thetaLength"),d(this,"animationEffect"),d(this,"animationEffectPeriod"),this.parameters=s,this.defineMaterialProxyProperties(["radius","color","widthSegments","heightSegments","phiStart","phiLength","thetaStart","thetaLength"])}initObject(){this.geometry=new jS(this.parameters),this.material=new WS(this.parameters),this.material.animationRotate=!0,this.material.setCommonUniforms(this.engine.rendering.uniforms)}},st.Marker=class extends td{constructor(s={}){super(s),d(this,"_icon"),d(this,"_width"),d(this,"_height"),this.isMarker=!0}initDom(){let s=document.createElement("img");return xt(s,`${te}-marker`),s}afterInit(){this.icon=this.parameters.icon||"",this.width=this.parameters.width||20,this.height=this.parameters.height||20}get icon(){return this._icon}set icon(s){this.dom&&(this.dom.src=s),this._icon=s}get width(){return this._width}set width(s){this.dom&&(this.dom.width=s),this._width=s}get height(){return this._height}set height(s){this.dom&&(this.dom.height=s),this._height=s}},st.Measure=Nn,st.MeshHeightMaterial=class extends jl{constructor(s){super({uniforms:{minAltitude:{value:0},maxAltitude:{value:870},noiseMap:{value:null},noiseUvScale:{value:.001},noiseScale:{value:.21},noiseBais:{value:-.2}}}),d(this,"_gradient",null),d(this,"_cachedGradientMap",null),d(this,"isMeshHeightMaterial",!0),this.defineMaterialNormalProperties(this,["minAltitude","maxAltitude","noiseUvScale","noiseScale","noiseBais"]),this.vertexShaderChunks=i2,this.fragmentShaderChunks=n2,this.createGradientMap(),this.setValues(s)}get gradient(){return this._gradient}set gradient(s){this._gradient=s,this.updateGradientMap()}get noiseMap(){return this.uniforms.noiseMap.value}set noiseMap(s){this.uniforms.noiseMap.value=s,s?this.defines.USE_NOISE_MAP=!0:delete this.defines.USE_NOISE_MAP,this.needsUpdate=!0}createGradientMap(){let s=document.createElement("canvas");s.width=64,s.height=2;let t=s.getContext("2d"),e=t.createLinearGradient(0,0,64,0);e.addColorStop(0,"#062516"),e.addColorStop(.2,"#85765d"),e.addColorStop(.6,"#032a21"),e.addColorStop(.9,"#001323"),e.addColorStop(.95,"#051420"),e.addColorStop(1,"#263241"),t.fillStyle=e,t.fillRect(0,0,64,2),this._cachedGradientMap=new Le(s),this.map=this._cachedGradientMap}updateGradientMap(){let s=this._cachedGradient;if(Object.prototype.toString.call(s)!=="[object Object]")return;let t=this._cachedGradientMap.image.getContext("2d");t.clearRect(0,0,64,2);let e=t.createLinearGradient(0,0,64,0);for(const i in s)Object.hasOwnProperty.call(s,i)&&e.addColorStop(i,s[i]);t.fillStyle=e,t.fillRect(0,0,64,2),this._cachedGradientMap.needsUpdate=!0}dispose(){this.noiseMap&&this.noiseMap.dispose(),super.dispose()}},st.MultiClippingPlaneCollection=q_,st.ObjectTracker=lo,st.PathTracker=class extends St{constructor(){super(...arguments),d(this,"_isRunning",!1),d(this,"_animationStartTime",0),d(this,"_animationDuration",0),d(this,"_animationTransform",{}),d(this,"_animationCurrenState",null),d(this,"_engine",null),d(this,"_track",null),d(this,"_frameInfo",null),d(this,"_sampledPath",[]),d(this,"_isPause",!1),d(this,"_pauseTime",0),d(this,"_pauseTimestamp",0),d(this,"_object",null),d(this,"_interpolateDirectThreshold",10),d(this,"_interpolateDirectThresholdPercent",.4),d(this,"_lockView",!1),d(this,"_viewFollow",!0),d(this,"_viewMode",H_),d(this,"_arcInfo",{})}afterAddToEngine(s){this._engine=s,s.map.mapType!=="blank"&&s.map.mapType!=="blank_3dcontrol"&&console.error("PathTracker is not compatible with current type of Map.")}onBeforeScenePrepareRender(s,t,e,i){if(!this._isRunning||this._isPause)return;const n=i.time-this._pauseTime-this._animationStartTime;let r=1;this._animationDuration>0&&(r=n/this._animationDuration),r>1&&(r=1);const a=this._interpolatePath(r);this._animationCurrenState=a;const o=this._engine.map;if(a.position!==void 0&&a.pitch!==void 0&&a.direction!==void 0){let l=a.direction;const h=this._engine._container.clientHeight;let c=this._animationTransform.distance/(h/2)*Math.tan(o.fov/2*Math.PI/180),u=this._engine.map.getZoomByZoomUnits(c);this.viewFollow&&this._updateCamera(e,a.position,u,c,l-Math.PI/2,a.pitch),this.object&&(this.object.position.set(...a.position),this.object.rotation.y=l,this.object.rotation.z=a.pitch)}n>=this._animationDuration||r>=1?(this.stop(),this._arcInfo={}):this._engine.requestRender()}_updateCamera(s,t,e,i,n,r){let a=this._engine.map;a.mapType==="blank"?this._computeCameraMatrixBlankMap(s,t,e,i,n,r):a.mapType==="blank_3dcontrol"&&this._computeCameraMatrixBlankMap3D(s,t,e,i,n,r)}_computeCameraMatrixBlankMap(s,t,e,i,n,r){const a=this._engine.map,{distance:o,heading:l,pitch:h}=this._animationTransform,c=this._engine._container.clientWidth,u=this._engine._container.clientHeight;if(s.position.set(0,0,0),s.quaternion.set(0,0,0,1),s.up.set(0,0,1),s.translateX(t[0]),s.translateY(t[1]),t[2]&&s.translateZ(t[2]),this.lockView)s.rotateOnAxis(new M(0,0,1),l*Math.PI/180+n),s.rotateOnAxis(new M(1,0,0),h*Math.PI/180+r),s.translateZ(o);else{s.rotateOnAxis(new M(0,0,1),a.getHeading()*Math.PI/180),s.rotateOnAxis(new M(1,0,0),a.getPitch()*Math.PI/180);const m=u/2/Math.tan(a.fov/2*Math.PI/180)*a.getZoomUnits();s.translateZ(m)}s.updateMatrix(),s.updateMatrixWorld(),s.aspect=c/u;let p=i;p<1&&(p=1),s.near=a.near,s.far=a.far*p,s.updateProjectionMatrix(),a.map.center=t,this.lockView&&(a.map.cameraDistance=o,a.map.zoomUnits=i,a.map.zoom=e,a.map.heading=l+n/Math.PI*180,a.map.pitch=h+r/Math.PI*180)}_computeCameraMatrixBlankMap3D(s,t,e,i,n,r){const a=this._engine.map,{distance:o,heading:l,pitch:h}=this._animationTransform;let c=a.unprojectPointArr(t);this.lockView?a.lookAt(c,{heading:l+re.radToDeg(n),pitch:h+re.radToDeg(r),range:o}):a.lookAt(c,{heading:a.getHeading(),pitch:a.getPitch(),range:a.getCameraDistance()})}_interpolatePath(s){const t=this._engine.map;for(let r=1;r<this._sampledPath.length;r++){const a=this._frameInfo[r],o=this._frameInfo[r-1],l=this._sampledPath[r],h=this._sampledPath[r-1],c=this._sampledPath[r+1];if(s>=h.percent&&s<l.percent){const u=(s-h.percent)/(l.percent-h.percent);let p=Fu(h.point,l.point,u);const[m,f]=l.position,[g,_]=h.position;let v=new j(m-g,f-_).angle(),x=ps(h.pitch,l.pitch,u);const y=this._arcInfo.startRatio&&u<this._arcInfo.startRatio;let b=0;if(c){const w=l.distance-h.distance,C=c.distance-l.distance,L=Math.min(w,C),T=this.interpolateDirectThreshold/L,E=T<.5?T:this._interpolateDirectThresholdPercent,I=w<C?E:C*E/w,z=C<w?E:w*E/C,B=u>1-I,O=[h.position,l.position,I],F=[l.position,c.position,z];if(B||y){B&&(this._arcInfo.line1=O),B&&(this._arcInfo.line2=F),B&&(this._arcInfo.startRatio=z);const Q=(u-(1-I))/I,k=u/this._arcInfo.startRatio,X=B?Q:k,{point:U,direction:H}=g_(this._arcInfo.line1,this._arcInfo.line2,B?X:1+X),Z=t.unprojectPointArr(U);U&&(p[0]=Z[0])&&(p[1]=Z[1]),v=new j(...H).angle()+Math.PI/2,b=B?X/2:(1+X)/2}}else if(y){const w=u/this._arcInfo.startRatio,{point:C,direction:L}=g_(this._arcInfo.line1,this._arcInfo.line2,1+w);C&&(p[0]=C[0])&&(p[1]=C[1]),v=new j(...L).angle()+Math.PI/2,b=(1+w)/2}const S=t.projectPointArr(p);if(a&&o)switch(this._viewMode){case c2:if(v=o.yaw+(a.yaw-o.yaw)*b,x=o.pitch+(a.pitch-o.pitch)*b,o.aim){const{aim:w}=o,C=t.projectPointArr(w),[L,T,E]=C;v=new j(L-S[0],T-S[1]).angle();const I=ds(S,C);x=Math.PI/2-Math.asin(Math.abs(E-S[2])/I)}break;case u2:v=o.yaw+(a.yaw-o.yaw)*u,x=o.pitch+(a.pitch-o.pitch)*u}return{percent:s,point:p,position:S,distance:ps(h.distance,l.distance,u),direction:v,pitch:x}}}const[e,i]=this._sampledPath[this._sampledPath.length-1].direction;let n={...this._sampledPath[this._sampledPath.length-1],direction:new j(e,i).angle()};if(this._frameInfo[this._sampledPath.length-1])if(this._frameInfo[this._sampledPath.length-1].aim){const{aim:r}=this._frameInfo[this._sampledPath.length-1],{position:a}=this._sampledPath[this._sampledPath.length-1],o=t.projectPointArr(r),[l,h,c]=o;n.direction=new j(l-a[0],h-a[1]).angle();const u=ds(a,o);n.pitch=Math.PI/2-Math.asin(Math.abs(c-a[2])/u)}else n.direction=this._frameInfo[this._sampledPath.length-1].yaw,n.pitch=this._frameInfo[this._sampledPath.length-1].pitch;return n}_createSampledPath(s){const t=this._engine.map;if(!s)return;let e=0,i=[0],n=[],r=[],a=0,o=[0];for(let p=1;p<s.length;p++){const m=s[p],f=s[p-1],g=s[p+1],_=ds(t.projectPointArr(f),t.projectPointArr(m));if(i[p]=_+e,e+=_,this._frameInfo&&this._frameInfo.length&&this._frameInfo.every(v=>v.speed)){const v=_/this._frameInfo[p-1].speed*1e3;o[p]=v+a,a+=v}if(this._frameInfo&&this._frameInfo.length&&this._frameInfo.every(v=>v.time)){const v=this._frameInfo[p-1];o[p]=v.time+a,a+=v.time}if(p===1&&(n[0]=Ye(f,m).toArray(),r[0]=this._getRadians(f,m)),g){const v=Ye(f,m).toArray(),x=Ye(m,g).toArray(),y=(h=x,c=.5,[(l=v)[0]+(h[0]-l[0])*c,l[1]+(h[1]-l[1])*c]);n[p]=y;const b=this._getRadians(f,m),S=this._getRadians(m,g);r[p]=ps(b,S,.5)}else n[p]=Ye(f,m).toArray(),r[p]=this._getRadians(f,m)}var l,h,c;const u=[];for(let p=0;p<s.length;p++){const m=s[p][2]?s[p]:[s[p][0],s[p][1],0];i[p]-this.interpolateDirectThreshold>i[p-1]&&p!==0&&s.length;const f={percent:(i[p]/e).toFixed(6),point:m,position:t.projectPointArr(m),distance:i[p],direction:n[p],pitch:r[p]};a&&o&&(f.percent=(o[p]/a).toFixed(6)),u.push(f),i[p]+this.interpolateDirectThreshold<i[p+1]&&p!==0&&s.length}return u.sort((p,m)=>p.percent-m.percent),this._sampledPath=u,u}_getRadians(s,t){const e=this._engine.map,i=ds(s=e.projectPointArr([s[0],s[1],s[2]||0]),t=e.projectPointArr([t[0],t[1],t[2]||0])),n=(r=s,a=t,Math.sqrt(Math.pow(r[0]-a[0],2)+Math.pow(r[1]-a[1],2)));var r,a;const o=Math.acos(n/i);return s[2]>=t[2]?-o:o}start(s={}){const{duration:t=1e3,heading:e=0,pitch:i=60,distance:n=100}=s;if(this.track){if(this.lockView&&this._engine.lockCamera(),this._isPause)return this._pauseTime+=new Date().valueOf()-this._pauseTimestamp,this._isPause=!1,void this._engine.requestRender();if(!this._isRunning){if(this._isRunning=!0,this._animationTransform={heading:e,pitch:i,distance:n},this._animationDuration=t,this._frameInfo&&this._frameInfo.length&&this._frameInfo.every(r=>r.time)){this._animationTransform={heading:0,pitch:0,distance:n};let r=0;this._frameInfo.forEach(a=>{const{time:o}=a;r+=o}),this._animationDuration=r}this._animationStartTime=new Date().getTime(),this._engine.requestRender(),this.onStart&&this.onStart()}}}pause(s){return this._isPause=!0,this._pauseTimestamp=new Date().valueOf(),s&&this.lockView&&(this._engine.unlockCamera(),this._engine.requestRender()),this._animationCurrenState}stop(){this._isRunning&&(this._isRunning=!1,this._engine.unlockCamera(),this._engine.requestRender(),this._pauseTimestamp=0,this._pauseTime=0,this._animationCurrenState=null,this.onFinish&&this.onFinish())}set track(s){if(s){if(s instanceof Array&&s[0]instanceof Array&&typeof s[0][0]=="number"&&s.length>=2)this._track=s,this._createSampledPath(s);else if(s.constructor===Object&&s.geometry&&s.geometry.type==="LineString"&&Array.isArray(s.geometry.coordinates)){const{properties:t={}}=s;this._track=s.geometry.coordinates,this._frameInfo=t.frameInfo||[],this._createSampledPath(s.geometry.coordinates)}else if(s instanceof Array){const t=[],e=[];s.forEach(i=>{const{x:n,y:r,z:a,pitch:o,yaw:l,aim:h,speed:c,time:u}=i;t.push([n,r,a]),e.push({pitch:o,yaw:l,aim:h,speed:c,time:u})}),this._track=t,this._frameInfo=e,this._createSampledPath(t)}}else this._track=null}get track(){return this._track}set interpolateDirectThreshold(s){this._interpolateDirectThreshold!==s&&(this._interpolateDirectThreshold=s,this._createSampledPath(this.track))}get interpolateDirectThreshold(){return this._interpolateDirectThreshold}set interpolateDirectThresholdPercent(s){this._interpolateDirectThresholdPercent!==s&&(this._interpolateDirectThresholdPercent=s,this._createSampledPath(this.track))}get interpolateDirectThresholdPercent(){return this._interpolateDirectThresholdPercent}set viewMode(s){switch(this._viewMode=s,s){case H_:this.lockView=!1,this.viewFollow=!0;break;case l2:this.lockView=!0,this.viewFollow=!0;break;case h2:this.lockView=!1,this.viewFollow=!1;break;default:this.lockView=!0,this.viewFollow=!0}}get viewMode(){return this._viewMode}set lockView(s){this._lockView=s,this._isRunning&&s===!0?this._engine.lockCamera():this._engine.unlockCamera()}get lockView(){return this._lockView}set object(s){this._object=s}get object(){return this._object}get viewFollow(){return this._viewFollow}set viewFollow(s){this._viewFollow!==s&&(this._viewFollow=s)}},st.Pillar=class extends Si{constructor(s){super(s),d(this,"geometry"),d(this,"material"),d(this,"opacity"),d(this,"height"),d(this,"radiusSegments"),d(this,"radius"),d(this,"gradient"),d(this,"vertexHeights"),d(this,"openEnded"),d(this,"getInstanceLocalMatrix",(t,e,i)=>{const{vertexHeights:n}=this.parameters,{height:r}=this.dataSource.data;if(n&&r){const a=new rt;return a.makeScale(1,1,r[i]),a}return null}),d(this,"addCustomAttributes",()=>{const{vertexHeights:t}=this.parameters,{height:e}=this.dataSource.data;let i=-1;if(!t||!e)return i;for(let n=0;n<e.length;n++)i<e[n]&&(i=e[n]);this.material.uniforms.maxHeight.value=i}),this.parameters=s}initObject(){this.geometry=new ZS(this.parameters),this.material=new KS(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}},st.PointEditor=class extends yo{constructor(s,t={}){super(),d(this,"_pointBuffer",{position:[],index:[],payload:[]}),d(this,"_hasBeenPush",!1),d(this,"_engine"),d(this,"_options"),d(this,"_point"),d(this,"_pointDataSource"),d(this,"_completedDataSource"),d(this,"_completedElement"),d(this,"_isAdd"),d(this,"_selectedIndex"),d(this,"_stage"),d(this,"_transformIndex"),d(this,"_lastDataItem"),d(this,"_handleAddClick",e=>{this._isAdd=!0,this._stage!==0&&this._stage!==1||(this._stage=1,this.addNode(e.position,e.point),this._handleAddFinish()),this._engine.requestRender()}),d(this,"_handleCompleteClick",e=>{if(this._stage!==1){this.complete(),this._selectedIndex=e.entity.selectedIndex,this._engine.event.unbind("click",this._handleAddClick),this._lastDataItem=this._drawedGraph.slice(this._selectedIndex,this._selectedIndex+1),this._stage=2,this._completedDataSource.setData();for(let i=0;i<this._drawedGraph.length;i++)i!==this._selectedIndex&&this._completedDataSource.add(this._drawedGraph[i].dataItem);this._pointBuffer=this._lastDataItem[0].pointBuffer,this._pointDataSource.setData(this._pointBuffer),this._engine.event.bind(this._point,"click",this._handleNodeClick),this._engine.requestRender()}}),d(this,"_handleAddFinish",e=>{this._stage===1&&(this._stage=2),this._hasBeenPush=!1,this.dispatchEvent({type:"change",value:this.data}),this._engine.requestRender(),this._engine.event.unbind("click",this._handleAddClick),this._engine.event.bind(this._point,"click",this._handleNodeClick),this._engine.event.bind("click",this._handleCancelEdit)}),d(this,"_handleNodeClick",e=>{e.domEvent?e.event.domEvent.preventDefault():e.event.preventDefault(),!e.entity||this._stage!==2&&this._stage!==3||(this._transformIndex=e.entity.index,this.attachTransform(e.entity.position),this._stage=3,this._engine.selection.transformControl.addEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.addEventListener("mouseUp",this._handleTransformChanged))}),d(this,"_handleTransformChanging",e=>{let i=this._getTransformBoxState();this._stage!==3&&this._stage!==4||(this.updateNode(this._transformIndex,i),this.dispatchEvent({type:"change",value:this.data}),this._stage=4)}),d(this,"_handleTransformChanged",e=>{let i=this._getTransformBoxState();this._stage===4&&(this.updateNode(this._transformIndex,i),this.dispatchEvent({type:"change",value:this.data}),this._stage=3)}),d(this,"_handleCancelEdit",e=>{this._stage===3&&(this.detachTransform(),this._stage=2)}),this._engine=s,t.pointColor||(t.pointColor="rgb(200, 200, 50)"),t.pointSize||(t.pointSize=10),this._options=t}initObjects(){this.initPoint(),this.initCompleteElement()}initPoint(){let s=this._pointDataSource=new ee;(this._point=this._engine.add(new Bu({color:this._options.pointColor,size:1.1*this._options.pointSize}))).dataSource=s}initCompleteElement(){let s=this._completedDataSource=new ee,t=this._completedElement=this._engine.add(new Bu({color:this._options.pointColor,size:this._options.pointSize}));s.setAttribute("selectedIndex"),t.dataSource=s,this._engine.event.bind(t,"click",this._handleCompleteClick)}initEvents(){this._engine.event.bind("click",this._handleAddClick),this._drawedGraph.length>0&&(this._engine.event.bind("click",this._handleCancelEdit),this._engine.event.bind(this._completedElement,"click",this._handleCompleteClick))}graphInfo(s){this._pointBuffer.payload[0].selectedIndex=s;const t=new Ni(this._pointBuffer.position[0],this._pointBuffer.payload[0]);return{pointBuffer:this._pointBuffer,dataItem:t}}addNode(s,t){this._pointBuffer.position.push(s),this._pointBuffer.index=[0],this._pointBuffer.payload.push({point:t,position:s,scale:2}),this._pointDataSource.setData(this._pointBuffer)}updateNode(s,t){const{point:e,position:i}=t;this._pointBuffer.position.splice(s,1,i),this._pointBuffer.payload.splice(s,1,{point:e,position:i,scale:t.width,angle:t.angle[2]}),this._pointDataSource.setData(this._pointBuffer)}unbindEvents(){this._engine.event.unbind("click",this._handleAddClick),this._engine.event.unbind("click",this._handleCancelEdit),this._engine.event.unbind("mousemove",this._handleAddMove),this._engine.event.unbind(this._point,"click",this._handleNodeClick),this._engine.event.unbind(this._completedElement,"click",this._handleCompleteClick),this._engine.selection.transformControl.removeEventListener("objectChange",this._handleTransformChanging),this._engine.selection.transformControl.removeEventListener("mouseUp",this._handleTransformChanged)}clearBuffers(){this._pointBuffer={position:[],index:[],payload:[]}}clearObjects(){this._pointDataSource.setData(),this._engine.requestRender()}dispose(){this.enabled=!1,this._engine.remove(this._point)}overwriteNodes(s){this.clearBuffers(),this._pointBuffer.position[0]=s[0].position,this._pointBuffer.index=[0],this._pointBuffer.payload=s,this._pointDataSource.setData(this._pointBuffer)}_getProperties(s){const{scale:t}=s;return{scale:t}}get data(){return this._pointBuffer.payload}set data(s){this.overwriteNodes(s),this._handleCancelEdit(),this._stage=2,this._isAdd=!0,this.dispatchEvent({type:"change",value:s}),this._engine.requestRender()}},st.PointGroup=L_,st.PointerLockControl=class extends o2{constructor(s){super(s.camera,s.map.container),d(this,"_enableKeyboardEvent",!1),d(this,"_moveForward",!1),d(this,"_moveBackward",!1),d(this,"_moveLeft",!1),d(this,"_moveRight",!1),d(this,"_prevTime"),d(this,"_velocity",new M),d(this,"_direction",new M),d(this,"handleKeyDownEvent",t=>{switch(t.keyCode){case 87:this._moveForward=!0;break;case 83:this._moveBackward=!0;break;case 65:this._moveLeft=!0;break;case 68:this._moveRight=!0;break;case 76:!this.isLocked&&this.lock()}}),d(this,"animationMove",()=>{if(!this._enableKeyboardEvent)return;const t=performance.now();requestAnimationFrame(this.animationMove);const e=(t-this._prevTime)/1e3;this._velocity.x-=10*this._velocity.x*e,this._velocity.z-=10*this._velocity.z*e,this._direction.z=Number(this._moveForward)-Number(this._moveBackward),this._direction.x=Number(this._moveRight)-Number(this._moveLeft),this._direction.normalize(),(this._moveForward||this._moveBackward)&&(this._velocity.z-=this._direction.z*this.forwardStepSize*e),(this._moveLeft||this._moveRight)&&(this._velocity.x-=this._direction.x*this.rightStepSize*e),this.moveRight(-this._velocity.x),this.moveForward(-this._velocity.z),this._prevTime=t}),d(this,"handleKeyUpEvent",t=>{switch(t.keyCode){case 87:this._moveForward=!1;break;case 83:this._moveBackward=!1;break;case 65:this._moveLeft=!1;break;case 68:this._moveRight=!1}}),this._engine=s,this._engine.camera.up.set(0,0,1),this.stepSize=10,this.addEventListener("change",t=>{s.requestRender()})}dispose(){super.dispose(),this.enableKeyboardEvent=!1}get forwardStepSize(){return this._forwardStepSize}set forwardStepSize(s){this._forwardStepSize=s}get rightStepSize(){return this._rightStepSize}set rightStepSize(s){this._rightStepSize=s}set stepSize(s){this.forwardStepSize=s,this.rightStepSize=s}set enableKeyboardEvent(s){s!==this._enableKeyboardEvent&&(this._enableKeyboardEvent=s,s?(this._prevTime=performance.now(),requestAnimationFrame(this.animationMove),window.addEventListener("keydown",this.handleKeyDownEvent),window.addEventListener("keyup",this.handleKeyUpEvent)):(window.removeEventListener("keydown",this.handleKeyDownEvent),window.removeEventListener("keyup",this.handleKeyUpEvent)))}},st.Polygon=fs,st.PolygonEditor=W_,st.Popup=class extends td{constructor(s){super(s),d(this,"_titleDiv"),d(this,"_contentDiv"),d(this,"_title"),d(this,"_content"),d(this,"_closePopup"),d(this,"click",()=>{this.visible=!1}),this.isPopup=!0}initDom(){const s=document.createElement("div");xt(s,`${te}-popup`);const t=document.createElement("div");xt(t,"frame");const e=this._titleDiv=document.createElement("div");xt(e,"title"),e.innerText=this.title;const i=this._closePopup=document.createElement("div");xt(i,"close"),i.innerText="x",i.addEventListener("click",this.click);const n=this._contentDiv=document.createElement("div");xt(n,"content"),n.innerText=this.content,t.appendChild(i),t.appendChild(e),t.appendChild(n);const r=document.createElement("div");return xt(r,"triangle"),s.appendChild(t),s.appendChild(r),s}afterInit(){this.title=this.parameters.title||"title",this.content=this.parameters.content||"content"}onDispose(){this._closePopup.removeEventListener("click",this.click)}get title(){return this._title}set title(s){s&&(this._title=s,this._titleDiv&&(this._titleDiv.innerText=s))}get content(){return this._content}set content(s){this._content=s,this._contentDiv&&(this._contentDiv.innerText=s)}},st.Realistic3DTilesMaterialManager=class extends Yl{constructor(){super(...arguments),d(this,"isRealistic3DTilesMaterialManager",!0),d(this,"_autoTimingLight",!0),d(this,"_nightLightDensity",0),d(this,"getTexture",(s,t,e,i,n)=>{const r=la.load(Tc(pl(),"assets/textures/realistic",`TexturesCom_${s}_${t}.${i.format||"jpg"}`),n);return r.wrapS=r.wrapT=ze,r.repeat=e,r}),d(this,"createPbrMaterial",(s,t,e,i={},n={})=>{e||(e=new j(.5,.5)),t||(t={albedo:!0,normal:!0,roughness:!0,ao:!1});const r={...i,envMapIntensity:2};return t.albedo&&(r.map=this.getTexture(s,"albedo",e,n)),t.normal&&(r.normalMap=this.getTexture(s,"normal",e,n)),t.roughness&&(r.roughnessMap=this.getTexture(s,"roughness",e,n)),t.ao&&(r.aoMap=this.getTexture(s,"ao",e,n)),t.emissive&&(r.emissiveMap=this.getTexture(s,"emissive",e,n)),new yn(r)}),d(this,"createBuildingMaterial",()=>{const s=la.load(Jt("assets/textures/building/building3_atlas_diffuse.jpg"));s.wrapS=s.wrapT=ze;const t=la.load(Jt("assets/textures/building/building3_atlas_normal.jpg"));t.wrapS=t.wrapT=ze;const e=la.load(Jt("assets/textures/building/building3_atlas_metallic_roughness.jpg"));e.wrapS=e.wrapT=ze;const i=la.load(Jt("assets/textures/building/building_atlas_emissive.jpg"));i.wrapS=i.wrapT=ze;const n=la.load(Jt("assets/textures/building/ac1.png"));n.flipY=!1;const r=new jl({roughness:.5,metalness:.2,map:s,normalMap:t,roughnessMap:e,metalnessMap:e,emissiveMap:i,uniforms:{acMap:{value:n}},vertexShaderChunks:{pars:`
                    attribute float _mt;
                    varying float vMt;
                `,main_before:`
                    vMt = _mt;
                `},fragmentShaderChunks:{pars:`
                    uniform sampler2D acMap;
                    varying float vMt;
                    #define USE_CUSTOM_MAP
                `,main_before:`
                    if (vMt < 100.0) {
                        float row = floor(vMt / 4.0);
                        float col = mod(vMt, 4.0);
                        uv.x = col * 0.25 + mod(vUv.x / 36.0,  0.25);
                        if (vUv.y < 3.0) {
                            uv.y = 0.02;
                            uv.x = 0.02;
                        } else {
                            // uv.y = vUv.y / 9.0;
                            uv.y = 1.0 - (row * 0.25 + 0.25 - mod(vUv.y / 36.0,  0.25));
                        }
                    }
                `,custom_map:`
                    vec4 sampledDiffuseColor;
                    if (vMt < 100.0) {
                        sampledDiffuseColor = texture2D( map, uv );
                    }
                    else {
                        sampledDiffuseColor = texture2D( acMap, vUv );
                    }
                `,color_after:`
                    // diffuseColor.xyz = vec3(vMt / 15.0, 0, 0);
                `}});return r.uniforms.acMap.value=n,r}),d(this,"handleWeatherChanged",s=>{let t=.8,e=1,i=!1;s==="cloudy"||s==="partlyCloudy"?(t=.4,e=1):s==="rainy"?(t=.2,e=1,i=!0):s==="snow"&&(t=.2,e=.2);const n=this._materrialMap.get("road");if(n.envMapIntensity=t,n.roughness=e,i){const r=this.getTexture("Ground_MudWet_512","roughness",new j(.1,.1),{},()=>{this.engine.requestRender()});n._roughnessMap=n.roughnessMap,n.roughnessMap=r,n.map.repeat=new j(.05,.05)}else n._roughnessMap&&(n.roughnessMap=n._roughnessMap,n._roughnessMap=null,n.map.repeat=new j(.5,.5));this._materrialMap.get("buildingSide").envMapIntensity=t}),d(this,"handleTimeChanged",s=>{if(!this._autoTimingLight)return;let t=0;t=s>66600||s<19800?1:s>63e3?(s-63e3)/3600:s<23400?(23400-s)/3600:0,this.updateLightDensity(t)})}onInit(){this.addMaterials();const s=this.engine,t=s.rendering.sky;t&&(t.addTimeChangedListener(this.handleTimeChanged),this.handleTimeChanged(t.time));const e=s.rendering.weather;e&&(e.addWeatherChangedListener(this.handleWeatherChanged),this.handleWeatherChanged(e.weather))}addMaterials(){this._materrialMap.set("road",this.createPbrMaterial("Asphalt_Base10_2x2_512",null,null,{color:11184810,roughness:.8,side:ce,emissiveIntensity:0,emissive:new tt(920067)})),this._materrialMap.set("isolation",this.createPbrMaterial("Nature_Pebbles_512",null,null,{})),this._materrialMap.set("green",this.createPbrMaterial("Nature_Moss_512",null,null,{color:13434828})),this._materrialMap.set("buildingSide",this.createBuildingMaterial()),this._materrialMap.set("buildingRoof",this.createPbrMaterial("Roofing_Bitumen_512",{},new j(1,1),{color:5592405,metalness:.2,roughness:.8},{format:"jpg"}));const s=new zg;this._materrialMap.set("water",s),this.engine.addBeforeRenderObject(s)}updateLightDensity(s){const t=this._materrialMap.get("buildingSide");this._materrialMap.get("road"),t.uniforms.emissive.value.copy(GM).multiplyScalar(.3*s)}get autoTimingLight(){return this._autoTimingLight}set autoTimingLight(s){if(s=!!s,this._autoTimingLight=s,s){const t=this.engine.sky;t&&this.handleTimeChanged(t.time)}else this.updateLightDensity(this._nightLightDensity)}get nightLightDensity(){return this._nightLightDensity}set nightLightDensity(s){this._nightLightDensity=s,this._autoTimingLight||this.updateLightDensity(s)}},st.RectEditor=G_,st.RoadLight3DTilesElement=class extends kg{constructor(){super(...arguments),d(this,"subscribedDataTypeIds",[101]),d(this,"_tickInterval",0),d(this,"_scaleSize",.04),d(this,"_powerStates",new Set),d(this,"_colorStates",new Map),d(this,"_allPowerOn",!1)}createMeshFromGeometry(s){return new XM(s)}_refreshPowerViewState(s,t){this._allPowerOn||this._powerStates.has(s)?(t.visible=!0,this._colorStates.has(s)&&(t.color=this._colorStates.get(s))):t.visible=!1}onEntityShow(s,t){this._refreshPowerViewState(s,t)}setPowerState(s,t){if(t?this._powerStates.add(s):this._powerStates.delete(s),this._visibleIdMap.has(s)){const e=this._visibleIdMap.get(s);this._refreshPowerViewState(s,e),this.engine.requestRender()}}togglePowerState(s){this.setPowerState(s,!this.isPowerOn(s)),this.engine.requestRender()}isPowerOn(s){return this._powerStates.has(s)}setColor(s,t){if(this._colorStates.set(s,t),this._visibleIdMap.has(s)){const e=this._visibleIdMap.get(s);this._refreshPowerViewState(s,e),this.engine.requestRender()}}set allPowerOn(s){this._allPowerOn=s}get allPowerOn(){return this._allPowerOn}},st.ShapePoint=class extends Si{constructor(s){super(s),this.parameters=s,this.defineGeometryProxyProperties(["shapeType"])}getDefaultParams(){return{shapeType:"cube"}}initObject(){const{shapeType:s,...t}=this.parameters;this.geometry=new Dw(this.parameters),this.material=new Iw(t),this.material.setCommonUniforms(this.engine.rendering.uniforms)}},st.SimplePoint=Bu,st.Spark=class extends rS{constructor(s){super(s),d(this,"geometry"),d(this,"material"),d(this,"color"),d(this,"vertexColors"),d(this,"height"),d(this,"vertexHeights"),d(this,"speed"),d(this,"tailLength"),d(this,"idle"),d(this,"emissive"),this.parameters=s,this.defineMaterialProxyProperties(["color","height","tailLength","speed","idle","emissive","vertexColors","vertexHeights"])}getDefaultParams(){return{height:100}}initObject(){this.geometry=new aS(this.parameters),this.material=new lS(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}setData(){const s=this.dataSource.data,t=[],e=[],i=[],n=[],r=[];for(let a=0;a<s.position.length;a++){let o=s.position[a];if(t.push(o[0],o[1],o[2]),this.parameters.vertexHeights&&s.height?(t.push(o[0],o[1],o[2]+s.height[a]),i.push(s.height[a],s.height[a]),n.push(0,s.height[a])):(t.push(o[0],o[1],o[2]+this.parameters.height),n.push(0,this.parameters.height)),this.parameters.vertexColors&&s.color){let l=es(s.color[a]);e.push(...l.toArray(),...l.toArray())}r.push(2*a,2*a+1)}this.geometry.setData({aPositions:t,aColors:e,aHeights:i,aLengths:n,indices:r}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,t),this.needsUpdate=!1}},st.SpecialPoint=class extends Si{constructor(s){super(s),d(this,"geometry"),d(this,"material"),d(this,"color"),d(this,"opacity"),d(this,"size"),d(this,"height"),this.parameters=s,this.defineMaterialProxyProperties(["color","size","height","opacity"])}initObject(){this.geometry=new ah,this.material=new Ew(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms),this.needsUpdate=!0}},st.SplineAreaEditor=class extends St{constructor(s,t={}){super(),d(this,"_fillBuffer",{position:[[[]]],index:[],payload:[]}),d(this,"_strokeBuffer",{position:[[]],index:[],payload:[]}),d(this,"_engine"),d(this,"_splineEditor"),d(this,"_options"),d(this,"_stroke"),d(this,"_strokeDataSource"),d(this,"_fill"),d(this,"_fillDataSource"),d(this,"_handleSplineChange",e=>{let i=e.value;this.clearBuffers(),this._drawSplineArea(i),this.dispatchEvent({type:"change",value:{polygon:this.positions,spline:i}})}),d(this,"_drawSplineArea",e=>{let i=this._parseSplineToArea(e);for(let n=0;n<i.length;n++){const r=i[n];this._strokeBuffer.position[0].push(r),this._strokeBuffer.index.push(n),this._fillBuffer.position[0][0].push(r),this._fillBuffer.index.push(n)}this._strokeDataSource.setData(this._strokeBuffer),this._fillDataSource.setData(this._fillBuffer),this._engine.requestRender()}),this._engine=s,this._splineEditor=s.add(new ed(s,t)),t.fillColor||(t.fillColor="rgba(40, 70, 150)"),t.strokeColor||(t.strokeColor="rgb(255, 255, 255)"),this._options=t}afterAddToEngine(){this.initObjects()}initStroke(){let s=this._strokeDataSource=new ee,t=this._stroke=this._engine.add(new sr({lineWidth:3,color:this._options.strokeColor,keepSize:!0,lineJoin:"round"}));return t.dataSource=s,t}initFill(){let s=this._fillDataSource=new ee,t=this._fill=this._engine.add(new fs({color:this._options.fillColor,opacity:.2}));return t.dataSource=s,t}initObjects(){this.initFill(),this.initStroke()}_parseSplineToArea(s){let t=[],e=new j(0,0);for(let i=0;i<s.length;i++){const n=s[i];let r=new j(1,0);r=r.rotateAround(e,n.angle),r.normalize();let a=[n.position[0]+r.x*n.scale,n.position[1]+r.y*n.scale,n.position[2]];t.push(a)}for(let i=s.length-1;i>=0;i--){const n=s[i];let r=new j(1,0);r=r.rotateAround(e,n.angle),r.normalize();let a=[n.position[0]-r.x*n.scale,n.position[1]-r.y*n.scale,n.position[2]];t.push(a)}return t.push(t[0]),t}clearBuffers(){this._strokeBuffer={position:[[]],index:[],payload:[]},this._fillBuffer={position:[[[]]],index:[],payload:[]}}clearObjects(){this._strokeDataSource.setData(),this._fillDataSource.setData(),this._engine.requestRender()}dispose(){this.enabled=!1,this._engine.remove(this._stroke),this._engine.remove(this._fill)}get spline(){return this._splineEditor}set positions(s){this._splineEditor.data=s}get positions(){return this._fillBuffer.position[0][0]}get enabled(){return this._splineEditor.enabled}set enabled(s){s!==this._enabled&&(this._splineEditor.enabled=s,this._splineEditor.clearAll(),s?(this.clearBuffers(),this._splineEditor.addEventListener("change",this._handleSplineChange)):(this._splineEditor.removeEventListener("change",this._handleSplineChange),this.clearObjects()))}},st.SplineEditor=ed,st.StaticSky=class extends Uf{constructor(){super(),d(this,"isStaticSky",!0),d(this,"_phase","default"),d(this,"_lastPhase",null),d(this,"_lastWeather",null),d(this,"_nightStartTime",64800),d(this,"_nightEndTime",21600),d(this,"_afternoonTime",55800),d(this,"_duskTime",61200),d(this,"_engine",null),d(this,"_PMREMGenerator",null),this.time=43200}afterAddToEngine(s){super.afterAddToEngine(s),this._engine=s,this._PMREMGenerator=new La(s.renderer),this.loadSkyTexture()}onTimeChanged(s){s>=this._nightStartTime||s<=this._nightEndTime?this._phase="night":s>=this._duskTime?this._phase="dusk":s>=this._afternoonTime?this._phase="afternoon":this._phase="default",this.loadSkyTexture()}onWeatherChanged(s){this._weather=s,this.loadSkyTexture()}loadSkyTexture(){if(!this._engine||this._phase===this._lastPhase&&this.weather===this._lastWeather)return;let s=Tc(pl(),"assets/textures/sky",this.weather,this._phase,"/"+this._phase+".jpg");this.textureURL=s,this._lastPhase=this._phase,this._lastWeather=this._weather}},st.TerrainClipPlan=class extends St{constructor(s={}){super(),d(this,"_coveragePosition",[]),d(this,"_splitNum",100),d(this,"_bottomImg"),d(this,"_wallImg"),d(this,"_bottomPolygon"),d(this,"_sideWall"),d(this,"_multiClippingPlaneCollection"),d(this,"_terrainHeight"),d(this,"_dirty"),d(this,"_dirtyList",{lists:[[]],lastIndex:0}),d(this,"isClockWise",t=>{let e=t.length,i=0;for(let n=e-1,r=0;r<e;n=r++)i+=t[n][0]*t[r][1]-t[r][0]*t[n][1];return i<0}),this._options=s,this._terrain=this._options.terrain,this._height=this._options.height||1e3,this._terrainHeight=this._options.terrainHeight,this._isTerrainHeight=this._options.isTerrainHeight||!1,this.coveragePosition=this._options.coveragePosition||[],this._options.splitNum&&(this._splitNum=this._options.splitNum),this._bottomImg=this._options.bottomImg,this._wallImg=this._options.wallImg}afterAddToEngine(s){this._engine=s}updateData(){this.clear();const s=this.coveragePosition;if(s.length===0)return;if(!this._terrain)return void console.warn("The excavation terrain must be bound");this.excavateMinHeight=1e4;const t=this.isConcavePoly(s);if(this.dirty){this._clearMultiClippingPlane();const e=new q_(this._engine,{owner:!0,edgeWidth:0});if(t){const i=pa.exports.flatten([s]);this._cutCoordinates=i,this._cutTriangle=pa.exports(i.vertices,i.holes,i.dimensions);const n=this._cutCoordinates.vertices,r=this._cutTriangle;for(let a=0;a<this._cutTriangle.length;){const o=r.slice(a,a+3).map(h=>n.slice(3*h,3*(h+1))),l=gs.fromPoints(this._engine,o,{});this._updateExcavateMinHeight(o),e.add(l),a+=3}}else{const i=gs.fromPoints(this._engine,s,{});this._updateExcavateMinHeight(s),e.add(i)}this._multiClippingPlaneCollection=e,this.dirty=!1}else if(t){const e=this._cutCoordinates.vertices,i=this._cutTriangle;for(let n=0;n<this._cutTriangle.length;){const r=i.slice(n,n+3).map(a=>e.slice(3*a,3*(a+1)));this._updateExcavateMinHeight(r),n+=3}}else this._updateExcavateMinHeight(s);this._prepareData(),this.build()}_updateExcavateMinHeight(s){for(let t=0;t<s.length;t++){const e=s[t],i=this._terrain.getHeight(e)||0;i<this.excavateMinHeight&&(this.excavateMinHeight=i)}}_clearMultiClippingPlane(){this._multiClippingPlaneCollection&&(this._multiClippingPlaneCollection.destroy(),this._multiClippingPlaneCollection=null,this._terrain.multiClippingPlanes=null,this.dirty=!0)}_prepareData(){const s=this._coveragePosition;let t=0;this.isTerrainHeight&&(this.height=this.excavateMinHeight-this.terrainHeight),t=this.excavateMinHeight-this.height;const e=[],i=[],n=[];if(this.length>0)for(let r=0;r<this.length;r++){const a=(r+1)%this.length,o=new j().fromArray(s[r]),l=new j().fromArray(s[a]);e.push([o.x,o.y]),i.push([o.x,o.y,t]),n.push([o.x,o.y,0]);for(let h=1;h<this._splitNum;h++){const{x:c,y:u}=new j().lerpVectors(o,l,h/this._splitNum);e.push([c,u]),n.push([c,u,0])}}this.prepareData={lerp_pos:e,bottom_pos:i,no_height_top:n}}build(){const{bottom_pos:s,lerp_pos:t}=this.prepareData;s.push(s[0]);const e=[],i=s[0][2];this.excavateMaxHeight=-1e4,this.lerpExcavateMinHeight=1e4;for(let n=0;n<t.length;n++){const r=t[n];let a=this._terrain.getHeight(r);if(a===void 0){let{lists:o,lastIndex:l}=this._dirtyList;const h=o[l];h.length<2?h.push(n):h[1]+1===n?h[1]=n:(l+=1,o[l]=[n],this._dirtyList.lastIndex=l),a=0}else a>this.excavateMaxHeight&&(this.excavateMaxHeight=a),a<this.lerpExcavateMinHeight&&(this.lerpExcavateMinHeight=a),a<i&&(a=i);e.push([...r,a])}this._handleDirtyList(e),e.push(e[0]),this._terrain.multiClippingPlanes=this._multiClippingPlaneCollection,this._createBottomSurface(s),this._createWall(e)}_handleDirtyList(s){const{lists:t}=this._dirtyList,e=s.length;let i=t.length;i>1&&t[0][0]===0&&t[i-1][1]===e-1&&(t[0][0]=t[i-1][0],t.splice(i-1,1),i-=1);for(let n=0;n<i;n++){const r=t[n];if(r.length!==2)continue;let a,o;a=r[0]===0?e-1:r[0]-1,o=r[1]===e-1?0:r[1]+1;const l=s[a][2],h=s[o][2]-l;let c=0;o>a?c=o-a:o<a&&(c=e-a+o);let u=1;for(let p=a;p!==o;){const m=(p+1)%e,f=l+(u+1)/c*h;u+=1,s[p][2]=f,p=m}}}_createBottomSurface(s){const t=us.fromGeoJSONObject({type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:{coordinates:[s]}}]}),e=this._bottomPolygon=new fs({color:"white",mapSrc:this._bottomImg,mapScale:1});this._engine.add(e),e.geometry.useUV=!0,e.dataSource=t}_createWall(s){const t=[];let e;e=this.isTerrainHeight?this.excavateMaxHeight>this.terrainHeight?this.excavateMaxHeight-this.terrainHeight:this.terrainHeight-this.excavateMinHeight:this.height+(this.excavateMaxHeight-this.lerpExcavateMinHeight);const i=e+(this.excavateMaxHeight-this.lerpExcavateMinHeight)+500;for(let a=0;a<s.length;a++){const o=[...s[a]];o[2]-=i,t.push(o)}const n=us.fromGeoJSONObject({type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:{type:"LineString",coordinates:t}}]}),r=this._sideWall=new F_({height:i,mapSrc:this._wallImg,depthWrite:!0,color:"#ffffff"});this._engine.add(r),r.geometry.useUV=!0,r.dataSource=n}isConcavePoly(s){let t,e;for(let i=1,n=s.length;i<n-1;i++){const r=new j().fromArray(s[i-1]),a=new j().fromArray(s[i]),o=new j().fromArray(s[i+1]),l=new j().subVectors(a,r),h=new j().subVectors(o,a);if(e=l.cross(h)>=0?1:-1,t!==void 0&&t!==e)return!0;t=e}return!1}clear(){this._bottomPolygon&&this._engine.remove(this._bottomPolygon),this._sideWall&&this._engine.remove(this._sideWall),this._bottomPolygon&&this._bottomPolygon.setData(),this._sideWall&&this._sideWall.setData(),this._dirtyList={lists:[[]],lastIndex:0}}dispose(){this.clear(),this._clearMultiClippingPlane()}get dirty(){return this._dirty}set dirty(s){this._dirty!==s&&(this._dirty=s)}get bottomImg(){return this._bottomImg}set bottomImg(s){this._bottomImg=s}get wallImg(){return this._wallImg}set wallImg(s){this._wallImg=s}get height(){return this._height}set height(s){this._height=s}get isTerrainHeight(){return this._isTerrainHeight}set isTerrainHeight(s){s!==this._isTerrainHeight&&(this._isTerrainHeight=s)}get terrainHeight(){return this._terrainHeight}set terrainHeight(s){this._terrainHeight=s}get coveragePosition(){return this._coveragePosition}set coveragePosition(s){const t=s.length;if(s&&t>2){const e=this.isClockWise(s);this._coveragePosition=e?[...s].reverse():s}else this._coveragePosition=[];this.dirty=!0}get length(){return this._coveragePosition.length}set terrain(s){this._terrain=s}},st.TerrainMap=class extends St{constructor(s={}){super(),d(this,"visible",!0),d(this,"freezeUpdate",!1),d(this,"_engine"),d(this,"_mapView"),d(this,"handleNodeCreated",n=>{this._engine&&this._engine.requestRender(),n.receiveShadow=this.tileReceiveShadow,n.castShadow=this.tileCastShadow}),d(this,"handleStateChange",()=>{this._engine&&this._engine.requestRender()});let t=new Pn;this.tileReceiveShadow=s.receiveShadow||!1,this.tileCastShadow=s.castShadow||!1;let e=new $i;e.getUrl=s.getTerrainUrl;const i=this._mapView=new Se(Se.HEIGHT,t,e,s.overrideMaterial);i.rotateX(Math.PI/2),this.add(i),i.onNodeReady=this.handleStateChange,i.onNodeCreated=this.handleNodeCreated,i.onNodeSubdivided=this.handleStateChange,i.children[0].receiveShadow=this.tileReceiveShadow,i.children[0].castShadow=this.tileCastShadow}afterAddToEngine(s){this._engine=s}onBeforeScenePrepareRender(){!this.visible||this.freezeUpdate||this._mapView.update(this._engine.rendering.camera)}get mapView(){return this._mapView}},st.TextMesh=bl,st.TrafficLight3DTilesElement=class extends kg{constructor(s){super(s),d(this,"subscribedDataTypeIds",[110,111,112,113]),d(this,"_tickInterval",1e3),d(this,"_typeConfigMap",{110:{slots:[0,0,0],stateType:1},111:{slots:[1,1,1]},112:{slots:[4,5]},113:{slots:[-1]},xxx:{slots:[0,0,0,-1]},xxx1:{slots:[0,0,-1],stateType:2}}),d(this,"_scaleSize",.1),d(this,"_stateMap",new Map),d(this,"_timeTableMap",new Map),d(this,"_refreshObjectViewState",(t,e)=>{if(this._timeTableMap.has(t))e.timeTable=this._timeTableMap.get(t);else if(e.timeTable=null,this._stateMap.has(t)){const i=this._stateMap.get(t);e.lightState=i.state,e.number=i.number,e.stateStartTime=i.startAt}else e.lightState=null;e.updateState(Date.now()/1e3)})}createMeshFromGeometry(s,t){const e=new Ug(s);e.lightStatus=-1,e.dataType=t.dataType;const i=this._typeConfigMap[t.dataType];return e.slots=i.slots,e.stateType=i.stateType,e}tickObject(s,t){s.updateState(t)}onEntityShow(s,t){this._refreshObjectViewState(s,t)}setLightState(s,t,e=0){if(t!=null?this._stateMap.set(s,{state:t,number:e,startAt:Date.now()/1e3}):this._stateMap.delete(s),this._visibleIdMap.has(s)){const i=this._visibleIdMap.get(s);this._refreshObjectViewState(s,i),this.engine.requestRender()}}setTimeTable(s,t){if(t?this._timeTableMap.set(s,t):this._timeTableMap.delete(s),this._visibleIdMap.has(s)){const e=this._visibleIdMap.get(s);this._refreshObjectViewState(s,e),this.engine.requestRender()}}getTimeTable(s){return this._timeTableMap.get(s)}getLightState(s){return this._stateMap.get(s)}getRealtimeState(s){let t=this._visibleIdMap.get(s);if(t){const e=this._timeTableMap.get(s);if(e)t=Fg,t.timeTable=e;else{const i=this.getLightState(s);i&&(t=Fg,t.lightState=i.state,t.number=i.number,t.stateStartTime=i.startAt)}}return t?(t.updateStatus(Date.now()),{lightState:t.lightState,number:t.number}):null}},st.TransformControl=zf,st.Twin=class extends St{constructor(s={}){super(),d(this,"engine",null),d(this,"_dataProvider",null),d(this,"_modelConfig",{}),d(this,"_modelLoaded",!0),d(this,"_buffers",{}),d(this,"_instances",{}),d(this,"_objects",[]),d(this,"_objectAttributes",{}),d(this,"handleBeforeRender",(t,e)=>{if(!this._entityManager||this._isPause)return;let{buffers:i,modelIndexMap:n}=this._entityManager.tick(t,e.time);if(this._buffers=i,this._modelLoaded){Object.keys(this._instances).forEach(r=>{let a=this._instances[r],o=this._filterBuffer(n,r);a&&(a.setBufferData(o),a.update())});for(let r=0;r<this._objects.length;r++)this._objects[r].dataSource.setData(i);this.onTicking&&this.onTicking(i),this._trackInfo&&this._track()}}),this.options=s,s.modelConfig&&(this.modelConfig=s.modelConfig),this._delay=s.delay||2e3,this._objectAttributes=s.objectAttributes||{},this._dataProvider=new mw,this._entityManager=new _w({delay:this._delay,twin:this}),this._objectTracker=new lo}afterAddToEngine(s){this.engine=s,this.objects=this.options.objects||[],this.engine.add(this._objectTracker),s.addPrepareRenderListener(this.handleBeforeRender)}push(s){if(!s||s.length===0)return;let t=this._dataProvider.provide(s);if(!this._isStarted){this._isStarted=!0;const e=new Date().valueOf();this._entityManager.startTime=e,this._entityManager.timeOffset=e-t[0].time}this._entityManager.push(t)}pause(){this._isPause=!0,this._pauseTime=new Date().valueOf()}start(){this._isPause=!1;const s=new Date().valueOf();this._entityManager.startTime=s-this._entityManager.delay,this._entityManager.timeOffset+=s-this._pauseTime,this._pauseTime=null}reset(){console.warn("twin: reset"),Object.values(this._instances).forEach(s=>{s.clear()}),this._trackInfo=null,this._isStarted=!1}_filterBuffer(s,t){if(!s||!s[t])return null;const e=s[t],i=[],n=[],r=[],a=[],o=[],l=[];for(let h=0;h<e.length;h++){const c=e[h];i.push(this._buffers.id[c]),n.push(this._buffers.translation[3*c],this._buffers.translation[3*c+1],this._buffers.translation[3*c+2]),r.push(this._buffers.rotation[3*c],this._buffers.rotation[3*c+1],this._buffers.rotation[3*c+2]),a.push(this._buffers.scale[3*c],this._buffers.scale[3*c+1],this._buffers.scale[3*c+2]),l.push(this._buffers.color[c]),o.push(this._buffers.modelType[c])}return{id:i,translation:n,rotation:r,scale:a,modelType:o,color:l}}loadModelAsync(s){return new Promise((t,e)=>{vw.load(s,i=>{let n=Wl(i.scene,!1,!0);t(n)})})}modelClear(){this._modelConfig={},Object.values(this._instances).forEach(s=>{this.engine.remove(s)}),this._instances={}}getCurrentBuffers(){return this._buffers}setColorById(s,t){this._modelLoaded&&Object.keys(this._instances).forEach(e=>{this._instances[e].setColor(s,new tt(t))})}_track(){if(this._modelLoaded){const{id:s,option:t}=this._trackInfo;Object.keys(this._instances).forEach(e=>{let i=this._instances[e];const n=i._idIndexMap[s];n!==void 0&&this._objectTracker.track({instance:i,instanceIndex:n},t)})}}trackById(s,t={radius:100,pitch:1.2}){this._trackInfo={id:s,option:t}}clearTrack(){this._trackInfo=null,this._objectTracker.stop()}get dataProvider(){return this._dataProvider}get entityManager(){return this._entityManager}get objectAttributes(){return this._objectAttributes}set objectAttributes(s){this._objectAttributes=s}get objects(){return this._objects}set objects(s){for(let t=0;t<this._objects.length;t++){const e=this._objects[t];this.engine.remove(e)}this._objects=s;for(let t=0;t<this._objects.length;t++){const e=this._objects[t];e.__initInEngine||this.engine.add(e);const i=new ee;i.setAttributes(this._objectAttributes),e.dataSource=i}}get modelConfig(){return this._modelConfig}set modelConfig(s){this._modelLoaded=!1;let t=Object.keys(s),e=Object.values(s).map(i=>this.loadModelAsync(i));Promise.all(e).then(i=>{this.modelClear();for(let n=0;n<t.length;n++){const r=t[n],a=i[n];this._modelConfig[r]=a,this._instances[r]=this.engine.add(new Au(a))}this._modelLoaded=!0,this.dispatchEvent({type:"modelLoaded",modelMap:this._instances})})}},st.UltraDynamicSky=Jf,st.VerticalGradientSky=class extends lM{createMaterial(){return new cM}get gradients(){return this._material.gradients}set gradients(s){this._material.gradients=s}},st.Wall=F_,st.WaterMaterial=zg,st.Wireframe3DTilesMaterialManager=class extends Yl{constructor(){super(),this.material=new ae({color:35020,wireframe:!0})}getMaterialByKey(s){return this.material}dispose(){this.material.dispose()}},st.colorUtils=qy,st.geojsonUtils=r1,st.modelUtils=NM,st.urlUtils=Ty,Object.defineProperties(st,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})})})(ld,ld.exports);var o0=ld.exports;const R2=A2(o0),L2=P2({__proto__:null,default:R2},[o0]);export{L2 as m};
